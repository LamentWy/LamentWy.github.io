import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o,c,a as e,b as a,d as i,e as s}from"./app-CfdduGO6.js";const l={},p=s('<h1 id="java-util-concurrent-包简介" tabindex="-1"><a class="header-anchor" href="#java-util-concurrent-包简介"><span>java.util.concurrent 包简介</span></a></h1><p>平时说 JUC ，实际上默认为以下三个包的统称： java.util.concurrent java.util.concurrent.atomic java.util.concurrent.locks</p><p>大体可以分为以下几个部分：</p><ul><li><p>locks 包含 <em><strong>AQS</strong></em>, <em><strong>LockSupport</strong></em> ，以及基于 AQS 的锁实现：ReentrantLock,ReentrantReadWriteLock 等。</p></li><li><p>原子类 atomic<br> 一堆原子类组成的包，可以看作是工具包，主要用来支持对变量进行非阻塞的线程安全编程。</p></li><li><p>同步辅助类</p></li></ul><p>CountDownLatch（赛车），CyclicBarrier（厨房），Phaser（前面二者的加强版），Semaphore（信号量），Exchanger（这个是线程之间交换变量值的）</p><ul><li><p>线程执行和管理<br> Future ：代表异步计算的返回结果。</p><p>Executor, ExecutorService ：线程任务的执行，执行各种已提交的 Runnable 任务. （Note: 线程的设计把执行机制和执行内容分开，各种 Runnable,Callable 任务就是执行内容，而执行机制，也就是具体如何执行 task 交给 Executor）。</p><p><em><strong>ThreadPoolExecutor</strong></em>： 线程池版Executor，它的基本逻辑是从线程池里获取线程，然后执行。</p><p>Executers： 工具类，他是 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和工具方法的合集。</p></li><li><p>并发集合 ArrayBlockingQueue，ConcurrentHashMap，ConcurrentLinkedDeque，ConcurrentLinkedQueue，ConcurrentSkipListMap，ConcurrentSkipListSet</p></li></ul><p>CopyOnWriteArrayList CopyOnWriteArraySet</p><p>LinkedBlockingDeque LinkedBlockingQueue LinkedTransferQueue</p><p>PriorityBlockingQueue 等等</p><h2 id="文档翻译" tabindex="-1"><a class="header-anchor" href="#文档翻译"><span>文档翻译</span></a></h2><p>java.util.concurrent 包，简称JUC，是 Java 为并发编程提供的标准化可扩展的框架。</p><p>主要组件包括以下部分：Executor、Queues、Timing、Synchronizers、concurrent Collections、Memory Consistency Properties。</p><h3 id="memory-consistency-properties" tabindex="-1"><a class="header-anchor" href="#memory-consistency-properties"><span>Memory Consistency Properties</span></a></h3><p>内存一致性属性，文档中这部分实际上就是介绍了一下 juc 包中如何实践 happen-before 原则和一些例子。 比如 线程必须事先将元素放入并发集合类中这个动作 happen-before于 线程从并发集合类中访问 or 删除这个元素。 详见文档，如果还是对 happen-before 不理解，请重新阅读之前关于 happen-before 以及 偏序关系的介绍。</p><h3 id="concurrent-collections" tabindex="-1"><a class="header-anchor" href="#concurrent-collections"><span>concurrent Collections</span></a></h3><p>并发集合类，就是用于并发环境下的集合类，比如 <strong>ConcurrentHashMap</strong> 可以看成是同步版本的<strong>HashMap</strong>，<strong>ConcurrentSkipListMap</strong> 同步版本的 <strong>TreeMap</strong>等等。</p><p>包中的很多类都带有 concurrent 前缀，它的含义不仅仅是线程安全，还可以“并发”访问。</p><p>比如我们可以通过<code>Collections.synchronizedMap(new HashMap())</code>来保证 hashMap 线程安全，但它不是 <strong>concurrent</strong> 的，因为这里 hashMap 只是通过排它锁，以阻塞同步的方式来保证了线程安全，本质上同一时间只有一个线程访问它并没有并发<strong>concurrent</strong>。 而并发集合类，比如<strong>ConcurrentHashMap</strong>则是在特定情况下可以允许任意数量线程并发读取 or 可控数量线程并发写入，同时还保证线程安全。</p><p>所以阅读这部分源码or文档时需要注意 <strong>synchronized</strong> 和 <strong>concurrent</strong> 的区别，<code>Collections.synchronizedMap(new HashMap())</code>是同步的（<strong>synchronized</strong>），<strong>ConcurrentHashMap</strong> 是并发的（<strong>concurrent</strong>）。</p><h3 id="synchronizers" tabindex="-1"><a class="header-anchor" href="#synchronizers"><span>Synchronizers</span></a></h3><p>主要是五个常见场景的同步器：Semaphore、CountDownLatch、CyclicBarrier、Phaser、Exchanger。</p><h3 id="timing" tabindex="-1"><a class="header-anchor" href="#timing"><span>Timing</span></a></h3><p>主要就是 TimeUnit 类，提供了基于不同时间粒度的操作方法，比如 sleep wait join 啥的。同时附带了一堆时间转换的方法以及时间单位的定义。</p><h3 id="queues" tabindex="-1"><a class="header-anchor" href="#queues"><span>Queues</span></a></h3><p>这部分提供了阻塞/非阻塞的各种线程安全队列。 详情看文档。</p><h3 id="executor" tabindex="-1"><a class="header-anchor" href="#executor"><span>Executor</span></a></h3><p>Executor 是个非常简单的标准化接口，只有一个方法 <code>void execute(Runnable command);</code>，它可以用来定义线程池、异步IO、轻量级任务框架这类型的线程类子系统。</p><p>一个特定/具体的 Executor 实现可以是正在创建 Thread，或者是一个正在执行中的 Executor ，或者是 一个线程调用 <code>execute()</code>方法（异步 or 顺序执行）。</p><p>可以通过 JUC 包内的例子来理解上面的定义。</p><p>以异步任务执行框架为例，ExecutorService (<code>interface ExecutorService extends Executor</code>)在 Executor 基础上进行扩展，通过提供线程状态方法、任务的提交关闭调用等方法，定义了一个异步任务执行框架。</p><p>更进一步 ScheduledExecutorService 接口，它通过继承 ExecutorService 接口进一步扩展出了延迟任务和周期任务的执行。</p><h5 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现"><span>具体实现</span></a></h5><blockquote><p>Classes ThreadPoolExecutor and ScheduledThreadPoolExecutor provide tunable, flexible thread pools. The Executors class provides factory methods for the most common kinds and configurations of Executors, as well as a few utility methods for using them. Other utilities based on Executors include the concrete class FutureTask providing a common extensible implementation of Futures, and ExecutorCompletionService, that assists in coordinating the processing of groups of asynchronous tasks.</p></blockquote><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>reference</span></a></h2>',34),u={href:"https://docs.oracle.com/javase/8/docs/api/overview-summary.html",target:"_blank",rel:"noopener noreferrer"};function h(d,m){const r=t("ExternalLinkIcon");return o(),c("div",null,[p,e("p",null,[e("a",u,[a("oracle java8 doc"),i(r)])])])}const v=n(l,[["render",h],["__file","01-intro.html.vue"]]),y=JSON.parse('{"path":"/docs/java/juc/01-intro.html","title":"java.util.concurrent 包简介","lang":"zh-CN","frontmatter":{"description":"java.util.concurrent 包简介 平时说 JUC ，实际上默认为以下三个包的统称： java.util.concurrent java.util.concurrent.atomic java.util.concurrent.locks 大体可以分为以下几个部分： locks 包含 AQS, LockSupport ，以及基于 AQS 的...","head":[["meta",{"property":"og:url","content":"https://lament-z.com/docs/java/juc/01-intro.html"}],["meta",{"property":"og:site_name","content":"鲸鱼气球"}],["meta",{"property":"og:title","content":"java.util.concurrent 包简介"}],["meta",{"property":"og:description","content":"java.util.concurrent 包简介 平时说 JUC ，实际上默认为以下三个包的统称： java.util.concurrent java.util.concurrent.atomic java.util.concurrent.locks 大体可以分为以下几个部分： locks 包含 AQS, LockSupport ，以及基于 AQS 的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-15T14:52:18.000Z"}],["meta",{"property":"article:author","content":"lament-z"}],["meta",{"property":"article:modified_time","content":"2024-02-15T14:52:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java.util.concurrent 包简介\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-15T14:52:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"lament-z\\",\\"url\\":\\"https://lament-z.com\\"}]}"]]},"headers":[{"level":2,"title":"文档翻译","slug":"文档翻译","link":"#文档翻译","children":[{"level":3,"title":"Memory Consistency Properties","slug":"memory-consistency-properties","link":"#memory-consistency-properties","children":[]},{"level":3,"title":"concurrent Collections","slug":"concurrent-collections","link":"#concurrent-collections","children":[]},{"level":3,"title":"Synchronizers","slug":"synchronizers","link":"#synchronizers","children":[]},{"level":3,"title":"Timing","slug":"timing","link":"#timing","children":[]},{"level":3,"title":"Queues","slug":"queues","link":"#queues","children":[]},{"level":3,"title":"Executor","slug":"executor","link":"#executor","children":[]}]},{"level":2,"title":"reference","slug":"reference","link":"#reference","children":[]}],"git":{"createdTime":1708008738000,"updatedTime":1708008738000,"contributors":[{"name":"Lament","email":"lament.wy@gmail.com","commits":1}]},"readingTime":{"minutes":3.61,"words":1084},"filePathRelative":"docs/java/juc/01-intro.md","localizedDate":"2024年2月15日","autoDesc":true,"excerpt":"\\n<p>平时说 JUC ，实际上默认为以下三个包的统称：\\njava.util.concurrent\\njava.util.concurrent.atomic\\njava.util.concurrent.locks</p>\\n<p>大体可以分为以下几个部分：</p>\\n<ul>\\n<li>\\n<p>locks\\n包含 <em><strong>AQS</strong></em>, <em><strong>LockSupport</strong></em> ，以及基于 AQS 的锁实现：ReentrantLock,ReentrantReadWriteLock 等。</p>\\n</li>\\n<li>\\n<p>原子类 atomic<br>\\n一堆原子类组成的包，可以看作是工具包，主要用来支持对变量进行非阻塞的线程安全编程。</p>\\n</li>\\n<li>\\n<p>同步辅助类</p>\\n</li>\\n</ul>"}');export{v as comp,y as data};
