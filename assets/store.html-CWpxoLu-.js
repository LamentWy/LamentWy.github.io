import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as t,c as p,a as n,b as o,d as c,e as i}from"./app-BwsoMA_K.js";const l={},u=i(`<h1 id="rocketmq-的消息存储和持久化" tabindex="-1"><a class="header-anchor" href="#rocketmq-的消息存储和持久化"><span>RocketMQ 的消息存储和持久化</span></a></h1><p>本文会先从概念上介绍 RocketMQ 消息存储的设计，为了达成设计目标实现了哪些机制，顺便补充一些背景知识方便读者理解机制的实现。之后会结合源码来详解具体机制的实现。</p><h2 id="消息存储模块的设计概要与分析" tabindex="-1"><a class="header-anchor" href="#消息存储模块的设计概要与分析"><span>消息存储模块的设计概要与分析</span></a></h2><blockquote><p>先笼统的解释 MQ 产品的方案，然后具体到 RocketMQ</p></blockquote><h3 id="常见持久化-存储方案简介" tabindex="-1"><a class="header-anchor" href="#常见持久化-存储方案简介"><span>常见持久化/存储方案简介</span></a></h3><p>任意应用的存储方案常见的基本上就三种：要么你直接使用文件系统进行数据存储，这个在桌面应用里很常见；要么使用各类 KV 存储，比如使用 redis 作为数据库并开启持久化；要么用关系型数据库，比如 MySQL。</p><p>文件系统操作效率最高，但可靠性最低，经典场景就是“突然停电/死机/重启，我忘记保存了！！！”； KV存储方式基本介于中间，这也是为什么大家都喜欢在数据库前加一层 Redis；数据库可靠性最高，但是性能相对前两者最差，这也是为啥所有性能压力的场景我们都要想方设法不让请求直接打在数据库上，同时还要让数据库尽可能的具备更大的抗压能力。</p><h3 id="rocketmq-的持久化设计" tabindex="-1"><a class="header-anchor" href="#rocketmq-的持久化设计"><span>RocketMQ 的持久化设计</span></a></h3><p>RocketMQ 作为一款分布式、高性能、高可用的消息队列产品，为了提供持久化能力，并且还要满足使用中可以通过多种方式查找消息的要求，它采用的是自研文件系统的方案。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>基于文件编程：<br> 日常我们接触最多的是基于内存编程，就比如数组、链表、HashMap 这些数据结构的读写都是直接对内存操作。而文件编程则是对磁盘上的数据（文件）进行操作，这就跟内存编程产生了极大的不同。</p><p>首先内存编程直接操作内存非常简单，而文件编程需要访问硬盘进行读写，这就来到了 I/O 的领域；然后是访问速读，内存的数据传输速读天然比硬盘要快，而且是数量级的快；硬盘的物理设计本身也会对数据读写有很大的影响，无论是普通硬盘还是SSD，进行文件编程时往往会对此进行特殊的优化，比如 MySQL InnoDB 引擎的默认索引的数据结构。</p></div><p>RocketMQ 的自研文件系统，后面就叫他存储模块(rocketmq/store)，主要包括三种文件: CommitLog、ConsumeQueue、Index File。</p><p>其中 CommitLog 文件采用顺序写的方式用于存储所有消息数据，它是最基础也是最核心的数据文件。ConsumeQueue 是为了提升消费效率的设计，当消息存入 CommitLog 后，会被异步转发至 ConsumeQueue 中，用于供给给消费端进行消费。Index 则是为快速检索/查找消息服务，它里面存储的是 msg key 与 offset 的关系。</p><p>至此，我们可以对存储模块有个大致的认识，当 Broker 收到消息后，它会存入 CommitLog 进行持久化，同时异步转发给 ConsumeQueue 供客户端进行消费，当需要检索消息时，则通过 Index 定位消息在文件中的具体位置。</p><p>接下来详细介绍一下这三种文件的具体信息。</p><h3 id="存储模块的目录结构" tabindex="-1"><a class="header-anchor" href="#存储模块的目录结构"><span>存储模块的目录结构</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code># 仅供参考
.
├── checkpoint
├── commitlog
│   └── 00000000000000000000
├── config
│   ├── consumerFilter.json
│   ├── consumerFilter.json.bak
│   ├── consumerOffset.json
│   ├── consumerOffset.json.bak
│   ├── delayOffset.json
│   ├── delayOffset.json.bak
│   ├── subscriptionGroup.json
│   ├── topics.json
│   └── topics.json.bak
├── consumequeue
│   └── TopicTest
│       ├── 0
│       │   └── 00000000000000000000
│       ├── 1
│       │   └── 00000000000000000000
│       ├── 2
│       │   └── 00000000000000000000
│       └── 3
│           └── 00000000000000000000
├── index
└── lock
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="commitlog" tabindex="-1"><a class="header-anchor" href="#commitlog"><span>CommitLog</span></a></h3><p>对于文件编程，或者通俗的说就是往硬盘里写数据，最快的方式就是顺序写，这跟硬盘的物理设计有关（虽然 SSD 跟普通硬盘磁盘式的写入方式不同，导致顺序写比随机写快的原因不同，但结论一致）。</p><div class="hint-container note"><p class="hint-container-title">为避免翻译带来的歧义</p><p>顺序读写 Sequential Access<br> 随机读写 Random Access<br> Random Access: the process of transferring information to or from memory in which every memory location can be accessed directly rather than being accessed in a fixed sequence. 随机读写/存取，这个是翻译上存在已久的争议，不必深究，简单的说就是可以对任意位置直接进行读写。</p></div><div class="hint-container note"><p class="hint-container-title">不同硬盘 IO 的区别</p><p>普通硬盘读取数据是从磁道中读取，先定位磁道，然后在磁道中读写，因此对于普通硬盘而言连续 IO (Sequential IO) 效率高于随机 IO （Random IO），因为磁盘寻道更少。</p><p>而 SSD 读取数据的方式有点像内存，它最小可读单元是 Page，Page 大小由硬盘本身决定，家用版有 2k、4k、8k、16k 等等，服务器版会有一些超大页的，不过通常是 4k（ps：这就是“4k对齐”的底层逻辑）。</p><p>扯远了，SSD 的优势除了天然比传统机械硬盘更快之外，实际它是 random IO 效率很高，跟传统硬盘比，它不需要寻道，跟自身 Sequential IO 比也要更快，当然综合来看其实差别不大。SSD IO 的另一个特点是读的速读远大于写。只看数据写入的话，由于 “erase-before-write” 机制的存在，连续写好于随机写（比如连续写入 1m &gt; 随机写入 256 个 4k）。</p></div><p>因此 RocketMQ 采用将所有消息按抵达 broker 的次序顺序写入 CommitLog，每个文件大小固定，写满一个就去写新的。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>// CommitLog 源码位置
org.apache.rocketmq.store.CommitLog
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>CommitLog</code> 这个类你简单理解它内部包含一个 <code>MappedFileQueue</code>，而 <code>MappedFileQueue</code> 由 <code>MappedFile</code> 组成。</p><p><code>MappedFileQueue</code> 可以暂且看作是一个 <code>MappedFile</code> 组成的数组，它的真实类型是: <code>CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles = new CopyOnWriteArrayList&lt;MappedFile&gt;();</code>。对应到存储模块的目录结构中，你可以暂且认为它就是那个 <code>commitlog/</code> 目录，具体细节在后面会详细展开。</p><p><code>MappedFile</code> 目前可以简单理解为就是 <code>commitLog/</code> 目录下的 commitLog 文件，它内部数据就是系统写入的消息，具体细节在后面会详细展开。</p><p>然后我们来介绍下 CommitLog 文件的设计，首先单个文件大小固定，默认为 1GB，文件名长度固定为 20，文件名格式为 <code>偏移量+高位补0 ｜ 000... + offset </code>，看起来就是<code>00000000000000000321</code>这种样子。</p><p>文件大小的配置：Broker 配置文件中的 <code>mapedFileSizeCommitLog</code> 选项。</p><p>CommitLog 文件内部的结构大致为：<code>已写入的全部消息：大小不定 + maxBlank(空闲空间大小)：4字节 + BLANK_MAGIC_CODE：4字节</code>。</p><p>存储目录: 默认值：<code>\${ROCKET_HOME}/store/commitlog</code>，这里的 <code>\${ROCKET_HOME}</code> 通常就是你用户目录，你可以理解为<code>~</code>。可以通过修改 broker 配置文件中的 <code>storePathRootDir</code> 来自定义存储目录。</p><ul><li><p>简单总结</p><p>先回顾一下 commitlog 文件的命名方式，看似平平无奇的设计里隐藏着一个优秀的特性。</p><p>这个设计巧妙的地方在于，只要给出任意一个消息的偏移量 (offset)，就可以利用二分查找迅速定位这个消息存储在哪个 CommitLog 中，定位到文件后只需要<code>msg.offset - commitLog.name</code> 就能得到消息在 commitLog 中的绝对位置。</p><p>以上这个查找流程相当于轻松实现了一套基于文件系统的高效随机访问 (Random Access) 的功能。文件系统的随机访问，尤其是传统机械硬盘上的随机访问是一个非常低效的过程，同理可参考之前提到的 MySQL 索引的数据结构选择，也是为了实现相同的目标。</p><p>之前说了写入方式就是顺序写入，一个文件写满之后写入下一个文件，实际上你想想看就知道，消息本身长度是不可控的，不可能把 1GB 正好写满，如果一个消息来写 CommitLog 时发现自己的长度 + 8 超过当前 commitLog 文件的剩余空间时，就会直接创建一个新的 commitLog 并写入消息。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// CommitLog::doAppend</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>msgLen <span class="token operator">+</span> <span class="token constant">END_FILE_MIN_BLANK_LENGTH</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> maxBlank<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>前面说的 + 8，也就是代码中的<code>END_FILE_MIN_BLANK_LENGTH</code>，实际上就是说每个 CommitLog 文件至少会有 8 个字节的空闲，高 4 位用于记录 CommitLog 文件剩余的空闲空间，低 4 位存放魔数。</p><p>最后，通过详细介绍（其实还是有很多细节没讲，会在后面分析具体机制时讲解）CommitLog 文件，我们不难发现该文件的设计核心就是在强调写入效率的最大化，同时兼顾了高效的根据 offset 进行随机读的能力（因为消息只写不删，而写入全是顺序写，删除是直接删 CommitLog 文件）。至此作为消息队列，消息写入的能力有了，而消费并没有实现，毕竟 RocketMQ 的卖点是基于消息主题 Topic 进行消息传输，很明显虽然 CommitLog 写入很高效，但它完全没有提供根据 topic 去找到消息的能力，总不可能去遍历 commitLog 去找 topic，何况相同 topic 下的消息很可能分布在不同的 commitLog 文件中，所以接下来我们就来看看专门为<strong>消息消费</strong>服务的 ConsumeQueue。</p></li></ul><h3 id="consumequeue" tabindex="-1"><a class="header-anchor" href="#consumequeue"><span>ConsumeQueue</span></a></h3><p>ConsumeQueue 设计目的也非常明确，那就是为消费端提供高效的根据 topic 查找消息的能力。</p><p>而同一个 topic 中的消息在 CommitLog 文件中的分布基本上可以认为是不连续和随机的，想要根据 topic 快速查找消息，ConsumeQueue 的做法相当于是给 commitlog 加了 Topic 索引。</p><p>从前文的目录结构中就可以清楚的看到，<code>ConsumeQueue/</code> 下的一级目录名就是主题 topic 名称，二级目录名就是该主题包含的队列ID，二级目录下的文件就是<em>待消费的消息队列</em>，这个<em>待消费的消息队列</em>就是 ConsumeQueue 文件。</p><p>前面已经提到，ConsumeQueue 中的数据来自 CommitLog 写入完成后的异步转发。这里异步转发的数据实际上就是 ConsumeQueue 文件中最小的数据单元。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>// 源码位置
org.apache.rocketmq.store.ConsumeQueue
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ConsumeQueue</code> 这个类内部依然包含一个 <code>MappedFileQueue</code>，而 <code>MappedFileQueue</code> 依然 <code>MappedFile</code> 组成。</p><p><code>MappedFileQueue</code> 在这里相当于是 <code>ConsumeQueue/queueid/</code> 目录，而 <code>MappedFile</code> 相当于是 ConsumeQueue 文件，它里面存储的就是异步转发来的数据。</p><p>然后来看 ConsumeQueue 文件的设计，ConsumeQueue 整体都采用了固定长度的设计，其最小数据单元，随便起个名字，cqNode，定长 20 byte，内部结构为:</p><table><thead><tr><th>8 byte</th><th>4 byte</th><th>8 byte</th></tr></thead><tbody><tr><td>commitlog-offset</td><td>msg.size</td><td>hash(msg.tag)</td></tr><tr><td>该消息在 commitlog 中的偏移量</td><td>消息的总长度</td><td>消息的 tag 的 hash 值</td></tr></tbody></table><p>单个 ConsumeQueue 文件默认包含 30w 个 cqNode，因此 ConsumeQueue 文件的固定大小为：<code>300000 * ConsumeQueue.CQ_STORE_UNIT_SIZE</code>(CQ_STORE_UNIT_SIZE 就是 cqNode 的定长 20 byte)。</p><p>ConsumeQueue 同样是顺序写，文件命名的方式与 commitlog 文件一致，也是 <code>offset + 高位补0</code>，唯一的区别是这里的 offset 永远是 20 的整数倍。</p><p>存储目录: <code>$HOME/store/consumequeue/{topic}/{queueID}/{ConsumeQueueFile}</code>。</p><ul><li><p>总结分析<br> 了解 ConsumeQueue 的设计之后我们来看它为消费消息带来了什么变化。</p><p>消费端可以根据 topic 和 queueid 轻松定位到具体的 ConsumeQueue 文件，接下来要找到需要的 cqNode。</p><p>消费端在当前主题的当前队列下的消费进度实际上就是所需 cqNode 在 ConsumeQueue 中的偏移量， 比如你消费到第3条消息，那么 3 * 20 就是第四条消息的 cqNode 在 ConsumeQueue 中的偏移量。</p><p>觉得不好理解可以参考下表:</p><table><thead><tr><th>消费进度</th><th>0</th><th>1</th><th>2</th><th>...</th></tr></thead><tbody><tr><td>cqNode-head-position</td><td>0*20</td><td>1*20</td><td>2*20</td><td>...</td></tr><tr><td>ConsumeQueue</td><td>cqNode-0</td><td>cqNode-1</td><td>cqNode-2</td><td>....</td></tr></tbody></table><p>其实仔细思考一下你会发现由于全是定长设计，ConsumeQueue 完全可以看作是一个数组，它的每个元素都是一个 cqNode，数组下标和对应 cqNode 在文件中的起始位置就是<code>下标*20</code>的线性关系。</p><p>无论消费进度在这里代表最新已消费进度还是下一个未消费进度，无非就是计算消息起始位置时候 +20/-20 的区别，常数计算反正不会影响线性关系。</p><p>准确定位到 cqNode 后，通过 commitlog-offset 可以从 commitlog 中准确定位到消息所处具体的文件的具体位置起始， msg.size 可以准确读出消息的全部数据。而 hash(msg.tag) 是用来支持消息过滤功能的，也就是去 commitLog 中查找之前多加一个根据 tag 过滤的环节，需要注意的是，为了满足定长设计，这里存储的是 tag 的 hash 值，注意哈希冲突。</p></li></ul><h3 id="index-file" tabindex="-1"><a class="header-anchor" href="#index-file"><span>Index File</span></a></h3><p>有了 CommitLog 和 ConsumeQueue，其实 RocketMQ 的基础功能基本齐活儿了。</p><p>Index 文件的引入则可以看作是产品功能增强，它为 rocketmq 提供了按照消息属性进行检索的能力。 这里说的消息属性就是 <code>Message</code> 类里的 <code>private Map&lt;String/*name*/, String/*value*/&gt; properties;</code>。 后面提到的 <code>Key</code> 实际上是 <code>Key = Topic + &quot;#&quot; + msg.key</code>，<code>msg.key</code> 就是 <code>Message.properties.name</code>，但是要注意 <code>Message.getKeys()</code> 方法返回的是所有 name + 空格拼接的字符串。</p><p>源码位置：<code>org.apache.rocketmq.store.index.IndexFile</code></p><p>Index 文件也是定长设计，主要由三个部分组成：文件头、哈希槽(Hash Slot)、索引数据(indexData)。其中文件头固定 40 byte，Hash Slot 500万个，indexData 槽 2000万个。数据也是来自 commitlog，消息写完 commitlog 后会转发 key 和 commitlog-offset（phyoffset）过来。</p><ul><li><p>大体结构：</p><table><thead><tr><th>文件头 indexHeader</th><th>Hash Slot</th><th>indexData Slot</th></tr></thead><tbody><tr><td>40 byte</td><td>4 byte * 500w</td><td>20 byte * 2000w</td></tr></tbody></table></li><li><p>文件头 indexHeader：</p><table><thead><tr><th>beginTimestamp</th><th>endTimestamp</th><th>beginPhyoffset</th><th>endPhyoffset</th><th>hashSlotCount</th><th>index count</th></tr></thead><tbody><tr><td>8 byte</td><td>8 byte</td><td>8 byte</td><td>8 byte</td><td>4 byte</td><td>4 byte</td></tr><tr><td>首个消息 put 的存储时间</td><td>最新消息的存储时间</td><td>首个的消息在 commitlog 中的偏移量</td><td>最新消息的偏移量</td><td>已使用的 hashSlot</td><td>消息已使用的 indexData 的总数</td></tr></tbody></table><p>文件头实际上当成临时变量存储区域就好了。begin 开头的就是 index 文件中收到的第一个消息的信息，end 开头的就是最新消息 put 时的信息，hashSlotCount 是有消息的 key 落到任意槽时自增 +1，index count 是每次有消息进来就自增+1。</p></li><li><p>hashSlot：</p><p>4 byte，里面的数据是 indexcount，实际上 40 + 4*500w + indexcount * 20 = index-offset，你把它当成 hashMap 里链表的尾指针就好。</p></li><li><p>indexData:</p><table><thead><tr><th>hashcode</th><th>phyoffset</th><th>timedif</th><th>preIndexNo</th></tr></thead><tbody><tr><td>消息的 key 的 hashcode</td><td>消息在 commitlog 中的 offset</td><td>timedif = 该消息存入 index 文件时的timestamp - indexHeader.beginTimestamp (秒)</td><td>0 or indexcount，其实就是冲突时前一个结点的 offset，计算方式跟 hashSlot 里面一样，当成前指针即可</td></tr></tbody></table></li><li><p>总结</p><p>根据以上说明你可以发现每个 index file 实际上就是一个 hashMap。与 ConsumeQueue 类似，它的数据也来自 commitlog，不同于前两个文件的顺序写，IndexFile 中只有 indexData 部分是顺序写。</p><p>每当消息的 key 和 commitlog-offset 转发给 IndexFile 后，它会先拼接生成 Key，然后对 Key 进行哈希，哈希方法就是简单的 <code>String::hash</code> 取绝对值，然后对 hashSlotNum(500w) 取模得到 hashSlot 的逻辑位置 slotPos，<code>int slotPos = keyHash % this.hashSlotNum;</code>，之后定长计算得到 slot 在 IndexFile 中的 offset。indexData 的 index-offset 计算方式也差不多，因为这部分是顺序写，所以直接 <code>40 + 4*500w + indexHeader.indexcount * 20</code>。</p><p>所谓根据属性查找消息，其实就是根据 key 得到 hashcode，根据 hashcode 找到 slot-offset，从中取出 indexcount，计算出 indexData 的 index-offset，取出 commitlog-offset，有了 commitlog-offset 就可以去 commitlog 里取消息了。</p><p>所以你看，不管是 consumequeue 还是 IndexFile 都是 先找到消息的 commitlog-offset，然后回到 commitlog 中查找。</p></li></ul><h3 id="checkpoint" tabindex="-1"><a class="header-anchor" href="#checkpoint"><span>CheckPoint</span></a></h3><p>源码:<code>StoreCheckpoint</code></p><p>这个文件就是用来记录刷盘时间点的。</p><table><thead><tr><th>physicMsgTimestamp</th><th>logicsMsgTimestamp</th><th>indexMsgTimestamp</th></tr></thead><tbody><tr><td>CommitLog 刷盘时间点</td><td>ConsumeQueue 刷盘时间点</td><td>IndexFile 刷盘时间点</td></tr></tbody></table><p>因为是记录时间戳，所以都是占 8 byte。</p><h2 id="核心机制" tabindex="-1"><a class="header-anchor" href="#核心机制"><span>核心机制</span></a></h2><div class="hint-container tip"><p class="hint-container-title">MMAP</p><p>简单介绍一下 MMAP，前文中反复出现的 MappedFile 就是这种技术的应用。</p><p>它是一种通过系统调用将文件映射到内存的技术，零拷贝方案之一。</p><p>简单的说就是可以直接从内核空间映射到用户空间，并且数据的修改和数据写入硬件（刷盘）是分开的。 你可以使用修改内存的方式修改文件数据，并且可以自行决定在什么时间点将修改刷盘。</p><p>对 MMAP 感兴趣可以先去看操作系统（Linux）、内存、IO 等相关知识。</p></div><h3 id="commitlog-刷盘" tabindex="-1"><a class="header-anchor" href="#commitlog-刷盘"><span>CommitLog 刷盘</span></a></h3><p>在 Broker 上篇中我们提到了接收消息时会发起异步调用进行刷盘，也就是 <code>SendMessageProcessor::asyncSendMessage</code> 中的 <code>this.brokerController.getMessageStore().asyncPutMessage(msgInner);</code>。</p><p>现在来具体看一下刷盘流程，源码位置:<code>DefaultMessageStore::asyncPutMessage</code>。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
 <span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PutMessageResult</span><span class="token punctuation">&gt;</span></span> <span class="token function">asyncPutMessage</span><span class="token punctuation">(</span><span class="token class-name">MessageExtBrokerInner</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>

     <span class="token comment">// 首先检查 MsgStore 状态是否正常，正常则返回 PUT_OK。</span>
     <span class="token comment">// 以下四种状态均为异常</span>
     <span class="token comment">// 1. MsgStore 是否为 shutdown 状态。</span>
     <span class="token comment">// 2. Broker 是否为 Slave</span>
     <span class="token comment">// 3. MsgStore 是否为可写状态</span>
     <span class="token comment">// 4. 是否缓存页繁忙</span>
     <span class="token class-name">PutMessageStatus</span> checkStoreStatus <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkStoreStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// 不正常直接返回</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>checkStoreStatus <span class="token operator">!=</span> <span class="token class-name">PutMessageStatus</span><span class="token punctuation">.</span><span class="token constant">PUT_OK</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PutMessageResult</span><span class="token punctuation">(</span>checkStoreStatus<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 检查消息状态，检查 topic 和属性长度 不能过长</span>
     <span class="token class-name">PutMessageStatus</span> msgCheckStatus <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>msgCheckStatus <span class="token operator">==</span> <span class="token class-name">PutMessageStatus</span><span class="token punctuation">.</span><span class="token constant">MESSAGE_ILLEGAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PutMessageResult</span><span class="token punctuation">(</span>msgCheckStatus<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">long</span> beginTime <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSystemClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// 异步调用 coomitlog 存储消息</span>
     <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PutMessageResult</span><span class="token punctuation">&gt;</span></span> putResultFuture <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commitLog<span class="token punctuation">.</span><span class="token function">asyncPutMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

     putResultFuture<span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
         <span class="token keyword">long</span> elapsedTime <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSystemClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> beginTime<span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>elapsedTime <span class="token operator">&gt;</span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;putMessage not in lock elapsed time(ms)={}, bodyLength={}&quot;</span><span class="token punctuation">,</span> elapsedTime<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>storeStatsService<span class="token punctuation">.</span><span class="token function">setPutMessageEntireTimeMax</span><span class="token punctuation">(</span>elapsedTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> result <span class="token operator">||</span> <span class="token operator">!</span>result<span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token keyword">this</span><span class="token punctuation">.</span>storeStatsService<span class="token punctuation">.</span><span class="token function">getPutMessageFailedTimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">return</span> putResultFuture<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后来到 <code>this.commitLog.asyncPutMessage(msg);</code>，该方法有两种实现，一种是分布式 CommitLog ，另一种就是普通的 commitLog，这里我们看普通的即可，5.0 之前不建议使用分布式。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// CommitLog::asyncPutMessage</span>

<span class="token comment">// 前面 msg 组装啥的省略</span>

<span class="token comment">// 先上锁 默认是 ReentrantLock</span>
putMessageLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//spin or ReentrantLock ,depending on store config</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到最新的 mappedFile，mmap，其实就是最新的 commitlog 文件</span>
  <span class="token class-name">MappedFile</span> mappedFile <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileQueue<span class="token punctuation">.</span><span class="token function">getLastMappedFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 继续省略  </span>

  <span class="token comment">// 注意同名方法，前面那个 getLastMappedFile() 是会返回 null的。</span>
  <span class="token comment">// mappedFile 为空 or 写满，则创建新文件</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> mappedFile <span class="token operator">||</span> mappedFile<span class="token punctuation">.</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 实际调用的是 tryCreateMappedFile(0) -&gt; doCreateMappedFile -&gt; ...</span>
      <span class="token comment">// 调用链太长了，正常情况下，最后负责创建 mappedFile 的一定是 allocateMappedFileService::mmapOperation</span>
      mappedFile <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileQueue<span class="token punctuation">.</span><span class="token function">getLastMappedFile</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mark: NewFile may be cause noise</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// mappedFile.appendMessage 就是 前文说的 消息会顺序写入 CommitLog</span>
  <span class="token comment">// 调用链结尾是 CommitLog.doAppend</span>
  result <span class="token operator">=</span> mappedFile<span class="token punctuation">.</span><span class="token function">appendMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>appendMessageCallback<span class="token punctuation">,</span> putMessageContext<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//...</span>
      <span class="token comment">/* 这里看这好几个分支，实际上就三种状态：
      PUT_OK 代表写入成功，
      END_OF_FILE 代表文件写满了，创建一个新文件重新 appendMessage，
      其他就是消息格式异常和未知错误，理论上客户端如果正确校验过消息，消息格式异常也不会出现在这里（防御性编程）。
      所以真的看到消息错误的异常时要小心，特别要注意该消息的来源。
      */</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>

   <span class="token comment">// submitFlushRequest 就是刷盘方法，里面有同步刷盘 SYNC_FLUSH，异步刷盘 ASYNC_FLUSH 两种逻辑</span>
   <span class="token comment">// 无论是哪种刷盘，都是创建请求，然后提交给 xxService(就是不同类型的刷盘线程)，Service/线程去完成刷盘操作</span>

   <span class="token comment">// 就比如 flushCommitLogService 可以是 GroupCommitService 类型(同步) ，也可以是 FlushRealTimeService(异步)。</span>
   <span class="token comment">// 最终执行的方法是 mappedByteBuffer.force(); 或者 fileChannel.force();</span>
   <span class="token comment">// 执行成功，则 pageCache 内的数据就被写入硬盘</span>
   <span class="token comment">// 这里还有个概念是 GroupCommit，后面再详细说明</span>
   <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PutMessageStatus</span><span class="token punctuation">&gt;</span></span> flushResultFuture <span class="token operator">=</span> <span class="token function">submitFlushRequest</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// 这个提交重复请求，就是 broker 高可用，master 写完给 slave 转发。</span>
   <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PutMessageStatus</span><span class="token punctuation">&gt;</span></span> replicaResultFuture <span class="token operator">=</span> <span class="token function">submitReplicaRequest</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>CommitLog::submitFlushRequest</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PutMessageStatus</span><span class="token punctuation">&gt;</span></span> <span class="token function">submitFlushRequest</span><span class="token punctuation">(</span><span class="token class-name">AppendMessageResult</span> result<span class="token punctuation">,</span> <span class="token class-name">MessageExt</span> messageExt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Synchronization flush</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">FlushDiskType</span><span class="token punctuation">.</span><span class="token constant">SYNC_FLUSH</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFlushDiskType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">GroupCommitService</span> service <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">GroupCommitService</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>flushCommitLogService<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>messageExt<span class="token punctuation">.</span><span class="token function">isWaitStoreMsgOK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">// 构造 request</span>
                <span class="token class-name">GroupCommitRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroupCommitRequest</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getWroteOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">getWroteBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSyncFlushTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 提交 request  多眼熟几遍</span>
                service<span class="token punctuation">.</span><span class="token function">putRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> request<span class="token punctuation">.</span><span class="token function">future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                service<span class="token punctuation">.</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token class-name">PutMessageStatus</span><span class="token punctuation">.</span><span class="token constant">PUT_OK</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// Asynchronous flush</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTransientStorePoolEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 默认情况，真实类型 FlushRealTimeService</span>
                flushCommitLogService<span class="token punctuation">.</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token punctuation">{</span>
                <span class="token comment">// 开启 TransientStorePool 机制时</span>
                <span class="token comment">// 真实类型 CommitRealTimeService</span>
                commitLogService<span class="token punctuation">.</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token class-name">PutMessageStatus</span><span class="token punctuation">.</span><span class="token constant">PUT_OK</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>自动创建 MappedFile 的线程: <code>allocateMappedFileService</code></p><p><code>allocateMappedFileService::mmapOperation</code>这里稍微补充说明以下，<code>allocateMappedFileService</code> 这个线程专门负责自动创建 MappedFile 文件，它里面维护一个 <code>requestTable</code>，不管是 CommitLog 还是 ConsumeQueue ，只要需要创建文件的时候就会生成一个创建请求 <code>AllocateRequest</code>，然后放入 <code>requestTable</code>， 配合 <code>CountDownLatch</code> ,<code>allocateMappedFileService</code> 就会自动从这个表里取出信息然后创建文件。成功创建好文件之后会对文件预热，<code>MappedFile::warmMappedFile</code>，预热行为就是给文件里写满0。全部完成后创建好的 mappedFile 会 set 回 <code>AllocateRequest</code> 里，这样请求方就可以直接从 <code>requestTable</code> 里读取了。</p></li><li><p>组提交 GroupCommit ：</p><p><code>GroupCommitService</code>里面有一个“组提交(GroupCommit)”的概念，里面应用了一个读写分离的小技巧。</p><p><code>GroupCommitService</code> 里维护了两个 List，requestsRead 和 requestsWrite，刷盘请求（GroupCommitRequest）会进入 requestsWrite，而刷盘线程从 requestsRead 里读取刷盘请求。 每当 requestsRead 里的请求全部执行完后，就会把 requestsRead 重置为一个空 List，然后去和 requestsWrite 交换数据。 整个过程中只有交换数据这一步是阻塞的。（实际代码中的交换流程好像是直接 Read = Write，然后 write = new List()，不重要，反正一个意思）</p></li><li><p>flushCommitLogService</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">FlushDiskType</span><span class="token punctuation">.</span><span class="token constant">SYNC_FLUSH</span> <span class="token operator">==</span> defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFlushDiskType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>flushCommitLogService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroupCommitService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>flushCommitLogService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlushRealTimeService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>GroupCommitService</code> 不会在没有刷盘任务的时候一直空转，他会停个 10ms，如果还是没有刷盘任务，则继续停。</p><p><code>FlushRealTimeService</code> 的线程间隔默认是 200ms。</p><p>他俩的源码就不展开看了，感兴趣可以自行浏览，他们仨（包括 <code>CommitRealTimeService</code>）都是线程，直接看 <code>run</code> 方法即可。</p></li><li><p>commitLogService</p><p><code>CommitLog</code> 类里还有一个线程叫做 <code>commitLogService</code>，这个线程只有在开启 TransientStorePool 机制时才会启动，他是用来代替 <code>flushCommitLogService</code>的。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// CommitLog::start</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>flushCommitLogService<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTransientStorePoolEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>commitLogService<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的真实类型是 <code>CommitRealTimeService</code>，它刷盘的方式跟前面都不一样，有兴趣可以先看一下后面的 TransientStorePool 机制的介绍，然后再去看他的代码，这里就只注明个别参数的含义，不展开看了。</p></li><li><p><code>MessageStoreConfig.commitIntervalCommitLog</code>：</p><p><code>CommitRealTimeService</code> 线程的间隔，默认 200ms，跟异步刷盘那个线程一致，这个 TransientStorePool 机制通常也是用来替换异步刷盘的，毕竟如果你都开启实时刷盘的模式了，说明数据安全高于性能，而 TransientStorePool 机制下一旦发生意外，丢的可是一大块内存的消息。</p></li><li><p><code>MessageStoreConfig.commitCommitLogLeastPages</code>：</p><p>一次至少提交几个页(Page)的数据，默认为 4。页数不满足的时候会直接跳过，等下次提交。</p></li><li><p><code>MessageStoreConfig.commitCommitLogThoroughInterval</code>：</p><p>两次有效提交的最大间隔，默认 200ms。 注意跟线程间隔区分，因为有前一个参数在，所以 <code>CommitRealTimeService</code> 是有可能拿着一部分的数据一直不提交的，该参数你可以认为是用来强制要求线程提交数据的。</p><p><code>MessageStoreConfig</code> 里面有一部分属性是有英文注释，可以参考。</p></li></ul><h3 id="consumequeue-刷盘" tabindex="-1"><a class="header-anchor" href="#consumequeue-刷盘"><span>ConsumeQueue 刷盘</span></a></h3><p>开始阅读前可以先对比以下 CommitLog 和 ConsumeQueue 的属性字段(field)，看起来 ConsumeQueue 似乎没有自己的 Service，实际上是有的，只不过是在 <code>DefaultMessageStore</code> 中。</p><p>前文一直说消息写完 commitLog 后会转发给 ConsumeQueue 和 IndexFile，现在我们来看这个转发。</p><p>源码位置：<code>org.apache.rocketmq.store.DefaultMessageStore</code>。</p><p><code>DefaultMessageStore</code> 应该也算是 RocketMQ-store 的核心类了，它这里管理着很多线程（Service）。 前面提到的线程基本都是它来创建和启动。在它的构造方法里，你能看到如下代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// from DefaultMessageStore field</span>
<span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CommitLogDispatcher</span><span class="token punctuation">&gt;</span></span> dispatcherList<span class="token punctuation">;</span>

<span class="token comment">// from DefaultMessageStore Constructor</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>dispatcherList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>dispatcherList<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CommitLogDispatcherBuildConsumeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>dispatcherList<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CommitLogDispatcherBuildIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里你就把 dispatcherList 看成是任务列表，后面的对象就是任务，这个任务必须实现<code> void dispatch(final DispatchRequest request);</code>方法。</p><p>然后 <code>DefaultMessageStore</code> 中有个 <code>ReputMessageService</code>，<code>ReputMessageService</code> 这个线程就不停的执行 <code>doReput()</code>，实际上有 1ms 间隔，然后这个 <code>doReput()</code> 会根据 dispatchRequest 状态去调用 <code>DefaultMessageStore.this.doDispatch(dispatchRequest);</code>，这个 <code>doDispatch(dispatchRequest)</code> 方法就是遍历前面的任务列表，分别执行任务的 <code>dispatch(DispatchRequest request)</code> 方法，也就是前面的 <code>CommitLogDispatcherBuildConsumeQueue()</code> 和 <code>CommitLogDispatcherBuildIndex()</code>。</p><p>然后我们来看 <code>CommitLogDispatcherBuildConsumeQueue::dispatch</code>:</p><ul><li><p>CommitLogDispatcherBuildConsumeQueue::dispatch</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// DefaultMessageStore.CommitLogDispatcherBuildConsumeQueue::dispatch</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token class-name">DispatchRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> tranType <span class="token operator">=</span> <span class="token class-name">MessageSysFlag</span><span class="token punctuation">.</span><span class="token function">getTransactionValue</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getSysFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>tranType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">MessageSysFlag</span><span class="token punctuation">.</span><span class="token constant">TRANSACTION_NOT_TYPE</span><span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token class-name">MessageSysFlag</span><span class="token punctuation">.</span><span class="token constant">TRANSACTION_COMMIT_TYPE</span><span class="token operator">:</span> <span class="token comment">// 状态 消息已提交</span>
            <span class="token class-name">DefaultMessageStore</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">putMessagePositionInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">MessageSysFlag</span><span class="token punctuation">.</span><span class="token constant">TRANSACTION_PREPARED_TYPE</span><span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token class-name">MessageSysFlag</span><span class="token punctuation">.</span><span class="token constant">TRANSACTION_ROLLBACK_TYPE</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>DefaultMessageStore::putMessagePositionInfo</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//DefaultMessageStore::putMessagePositionInfo</span>
<span class="token comment">// 前文介绍 ConsumeQueue 时讲过的，根据 Topic 和 QueueID 定位文件</span>
<span class="token comment">// 其实就是1级目录/2级目录/cq文件， findConsumeQueue 这个方法自己去看吧</span>
<span class="token class-name">ConsumeQueue</span> cq <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findConsumeQueue</span><span class="token punctuation">(</span>dispatchRequest<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dispatchRequest<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 写入文件的包装方法</span>
cq<span class="token punctuation">.</span><span class="token function">putMessagePositionInfoWrapper</span><span class="token punctuation">(</span>dispatchRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>ConsumeQueue::putMessagePositionInfoWrapper</p><p>这个其实也没啥可看的。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putMessagePositionInfoWrapper</span><span class="token punctuation">(</span><span class="token class-name">DispatchRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token keyword">int</span> maxRetries <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
  <span class="token comment">// cq 文件可写标记</span>
  <span class="token keyword">boolean</span> canWrite <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getRunningFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isCQWriteable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxRetries <span class="token operator">&amp;&amp;</span> canWrite<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">long</span> tagsCode <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getTagsCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// cqExt 扩展文件处理逻辑 直接跳过</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isExtWriteEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">//...</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// putMessagePositionInfo 方法去写文件</span>
      <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">putMessagePositionInfo</span><span class="token punctuation">(</span>
              request<span class="token punctuation">.</span><span class="token function">getCommitLogOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// msg.phyoffset</span>
              request<span class="token punctuation">.</span><span class="token function">getMsgSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// msg.size</span>
              tagsCode<span class="token punctuation">,</span> <span class="token comment">// msg.tag.hashcode</span>
              request<span class="token punctuation">.</span><span class="token function">getConsumeQueueOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// cur cq logic-offset</span>

      <span class="token comment">// 根据结果更新 checkpoint 文件        </span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// Slave or 分布式 commitLog</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBrokerRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">BrokerRole</span><span class="token punctuation">.</span><span class="token constant">SLAVE</span> <span class="token operator">||</span>
              <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEnableDLegerCommitLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getStoreCheckpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPhysicMsgTimestamp</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getStoreTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getStoreCheckpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setLogicsMsgTimestamp</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getStoreTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token comment">// 注意前面是循环写，只要成功就直接 return</span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// XXX: warn and notify me</span>
          <span class="token comment">// log</span>
          <span class="token keyword">try</span> <span class="token punctuation">{</span>
              <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// XXX: warn and notify me</span>
  log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;[BUG]consume queue can not write, {} {}&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>topic<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>queueId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getRunningFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">makeLogicsQueueError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>ConsumeQueue::putMessagePositionInfo</p><p>这个方法本来也不打算贴的，因为 ConsumeQueue 其实也是顺序写，所以处理逻辑跟 commitLog 一样， 都是 <code>mappedFile::appendMessage</code>。 不打算贴的原因是很容易跟前文逻辑混淆，比如代码中 ConsumeQueue 文件的物理偏移量都叫 xxxLogicOffset，按代码表达意思其实就是 commitLog 文件才叫物理偏移量， ConsumeQueue 就是逻辑文件，毕竟 ConsumeQueue 的数据都是可以从 CommitLog 中推理出来的。</p><p>再比如 PhysicOffset 突然就加上了 msg.size，然后还没有注释解释原因，实际上它突然加个 msg.size 只是为了恢复文件的时候跟 commitlog 文件进行比较，毕竟你要判断 commitlog 中的消息是否损坏，它起始位置是判断不出来的（除非消息整个丢了），只有结尾大小不一样，说明这个消息没写全，是损坏的。</p><p>换句话说，ConsumeQueue.maxPhysicOffset 相当于保存了两部分信息，一是消息的物理偏移量，二是消息的正确大小。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">putMessagePositionInfo</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">long</span> tagsCode<span class="token punctuation">,</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> cqOffset<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// offset：PhysicOffset aka 消息在 commitlog 中的 offset</span>
    <span class="token comment">// maxPhysicOffset： cq 中存储的消息在 commitlog 中的 offset + msg.size</span>
    <span class="token comment">// 最新消息的 phyOffset + msg.size 必然大于CQ中已有消息的 maxPhysicOffset</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">+</span> size <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxPhysicOffset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Maybe try to build consume queue repeatedly maxPhysicOffset={} phyOffset={}&quot;</span><span class="token punctuation">,</span> maxPhysicOffset<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>byteBufferIndex<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// buffer 指针归 0</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>byteBufferIndex<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token constant">CQ_STORE_UNIT_SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20 byte</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>byteBufferIndex<span class="token punctuation">.</span><span class="token function">putLong</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// PhysicOffset</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>byteBufferIndex<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// msg.size</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>byteBufferIndex<span class="token punctuation">.</span><span class="token function">putLong</span><span class="token punctuation">(</span>tagsCode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// msg.tag.hashcode</span>

    <span class="token comment">// 计算消息在 CQ 中的 物理位置</span>
    <span class="token comment">// cqOffset 在这里是逻辑位置，至少是本文说的 消息在这个 cq 队列中的逻辑位置</span>
    <span class="token comment">// 但是吧，算出来的 offset，它代码里叫 LogicOffset，明明相同语境下，commitlog 你叫物理位置</span>
    <span class="token comment">// 到 cq 文件里就变成逻辑位置了，而且这个 offset 是不加 msg.size 的</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> expectLogicOffset <span class="token operator">=</span> cqOffset <span class="token operator">*</span> <span class="token constant">CQ_STORE_UNIT_SIZE</span><span class="token punctuation">;</span>

    <span class="token comment">// 根据预期的 CQ 中的物理偏移量，二分查找 找出对应的 ConsumeQueue 文件，满了则创建信息</span>
    <span class="token comment">// 这儿的逻辑跟 commitlog 文件是一样的，CQ 里很多处理逻辑跟 CommitLog 中都是同一套</span>
    <span class="token class-name">MappedFile</span> mappedFile <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileQueue<span class="token punctuation">.</span><span class="token function">getLastMappedFile</span><span class="token punctuation">(</span>expectLogicOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mappedFile <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// 队列为空，起始可写入位置也为0，但是 cq 逻辑偏移量(cqOffset) 不为 0</span>
        <span class="token comment">// 说明当前要写入 CQ 的消息不是第一条消息，那么先写空结点占位 fillPreBlank</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mappedFile<span class="token punctuation">.</span><span class="token function">isFirstCreateInQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> cqOffset <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> mappedFile<span class="token punctuation">.</span><span class="token function">getWrotePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 结合这里看，这个 LogicOffset 的意思大概是，CQ 文件中的物理偏移量都叫 LogicOffset</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>minLogicOffset <span class="token operator">=</span> expectLogicOffset<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileQueue<span class="token punctuation">.</span><span class="token function">setFlushedWhere</span><span class="token punctuation">(</span>expectLogicOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileQueue<span class="token punctuation">.</span><span class="token function">setCommittedWhere</span><span class="token punctuation">(</span>expectLogicOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 向前面应该有数据的空的CQ结点中写入 空结点：0L + Integer.MAX + 0L</span>
            <span class="token comment">// 一直填充到 本消息的起始位置为止。</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fillPreBlank</span><span class="token punctuation">(</span>mappedFile<span class="token punctuation">,</span> expectLogicOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;fill pre blank space &quot;</span> <span class="token operator">+</span> mappedFile<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> expectLogicOffset <span class="token operator">+</span> <span class="token string">&quot; &quot;</span>
                <span class="token operator">+</span> mappedFile<span class="token punctuation">.</span><span class="token function">getWrotePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>cqOffset <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这段不用看，就是 offset 对不上的话，打印偏差值的地方。</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// maxPhysicOffset 是 消息结尾位置，而不是消息写入位置</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maxPhysicOffset <span class="token operator">=</span> offset <span class="token operator">+</span> size<span class="token punctuation">;</span>
        <span class="token keyword">return</span> mappedFile<span class="token punctuation">.</span><span class="token function">appendMessage</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>byteBufferIndex<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="consumequeueext" tabindex="-1"><a class="header-anchor" href="#consumequeueext"><span>ConsumeQueueExt</span></a></h4><p>ConsumeQueue 扩展文件，ConsumeQueue 只有三个字段，Ext 版本就是比 ConsumeQueue 多了几个字段。 由于多了字段，自然要有单独的逻辑，这部分不展开。</p><h3 id="indexfile-刷盘" tabindex="-1"><a class="header-anchor" href="#indexfile-刷盘"><span>indexFile 刷盘</span></a></h3><p>同 ConsumeQueue 。</p><h3 id="文件恢复" tabindex="-1"><a class="header-anchor" href="#文件恢复"><span>文件恢复</span></a></h3><p>要恢复的文件自然就是 CommitLog、ConsumeQueue、IndexFile 这三种。由于后两者的数据均来自 CommitLog，因此恢复时基本以 ComitLog 为准。 这里只介绍 CommitLog、ConsumeQueue，IndexFile 的恢复流程省略，这篇幅已经太长了。</p><p>文件恢复是 Broker 启动，或者说 <code>DefaultMessageStore</code> 启动时，加载过程中的一步，也就是 <code>DefaultMessageStore::recover(boolean lastExitOK)</code>，无论是正常退出还是异常关闭， <code>recover(lastExitOK)</code> 的第一件事是先恢复 ConsumeQueue 文件，找到最新一条格式正确的消息的记录，并取出该消息的 commitLog-offset 的值，存储到 <code>maxPhyOffsetOfConsumeQueue</code> 中作为下一步的入参。</p><p>详见: <code>DefaultMessageStore::load</code>。</p><ul><li><p>正常退出</p><p>Broker 正常退出时，会先完成刷盘，然后再关闭 Broker，也就是说内存中所有数据都保存在文件中了。</p><p>此时文件恢复会进入 <code>this.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);</code>，从倒数第三个 commitlog 文件开始恢复，不足 3 个文件则从第一个开始恢复。 恢复过程，先 <code>checkMessageAndReturnSize</code>，然后设置 ConsumeQueue。</p></li><li><p>异常退出</p><p>异常关闭则进入 <code>this.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);</code>（注意该方法已标记 Deprecated，代码就不贴了，不建议看，知道大体逻辑就好了。</p><p>这里的逻辑基本上是：利用 CheckPoint 文件中记录的三个时间戳（CommitLog、ConsumeQueue、Index文件最后的刷盘时间戳）中，最小的来进行辅助判定。</p><p>那个方法会从 commitLog 的最后一个文件(<code>int index = mappedFiles.size() - 1;</code>)开始判定，判定逻辑在 <code>isMappedFileMatchedRecover</code>，读出该文件第一条消息的存储时间，如果这个存储时间小于 CheckPoint 文件中的最小刷盘时间（），就可以从这个文件开始恢复，如果大于，则寻找上一个文件（<code>index = index - 1</code>），这里相当于默认了 <code>CheckPoint.getMinTimestampIndex</code> 之前的消息绝对有效。后面流程就跟正常恢复一样了。</p><p>这个 <code>CheckPoint.getMinTimestampIndex</code> 的值如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>
  <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getMinTimestampIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMinTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>indexMsgTimestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getMinTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">long</span> min <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>physicMsgTimestamp<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>logicsMsgTimestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>

      min <span class="token operator">-=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
          min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

      <span class="token keyword">return</span> min<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>recoverTopicQueueTable</p><p>无论是正常退出还是异常关闭，<code>recover</code> 还有最后一步恢复 <code>CommitLog.topicQueueTable</code> 的数据，其实就是初始化这个表里的数据，它里面的数据来自 <code>DefaultMessageStore.consumeQueueTable</code>，而 <code>consumeQueueTable</code> 中的数据则是在 <code>loadConsumeQueue()</code> 时从 ConsumeQueue 文件中读出来的。</p></li></ul><h3 id="transientstorepool-机制" tabindex="-1"><a class="header-anchor" href="#transientstorepool-机制"><span>TransientStorePool 机制</span></a></h3><p>默认情况下，RocketMQ 是先写页缓存（pageCache），消费消息也是从 pageCache 查，高并发时就会在 broker 日志中发现瞬时 broker busy 的异常，大部分情况下就是 pageCache 太忙。</p><p>这个机制的引入就是为了解决这个问题，它采用的方式你可以理解为<strong>空间换时间</strong>，也可以理解为<strong>内存的读写分离</strong>。</p><p>启用该机制后，Broker 收到的消息会先写入堆外内存并立刻返回，然后用异步的方式提交给 pageCache，之后再异步刷盘。这样相当于写消息操作都在堆外内存，而 pageCache 主要面对消息消费，也就是读操作。</p><p>不过缺点是，broker 意外退出时，pageCache 还有可能保留一部分数据，堆外内存的数据就全丢了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>熟悉三种文件的设计思路和文件结构，了解刷盘/恢复的大致流程即可。</p><p>本文跳过了消息消费相关的一部分内容，后续在消息消费章节再进行说明。</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>reference</span></a></h2>`,95),d=n("li",null,[n("p",null,"《RocketMQ技术内幕: RocketMQ架构设计与实现原理》")],-1),k={href:"https://rocketmq.apache.org/zh/docs/4.x/",target:"_blank",rel:"noopener noreferrer"};function r(m,v){const s=e("ExternalLinkIcon");return t(),p("div",null,[u,n("ul",null,[d,n("li",null,[n("p",null,[n("a",k,[o("RocketMQ 文档 4.x 版"),c(s)])])])])])}const h=a(l,[["render",r],["__file","store.html.vue"]]),f=JSON.parse('{"path":"/docs/message-queue/rocketmq/store.html","title":"RocketMQ 源码分析-消息存储和持久化","lang":"zh-CN","frontmatter":{"title":"RocketMQ 源码分析-消息存储和持久化","order":5,"description":"RocketMQ 的消息存储和持久化 本文会先从概念上介绍 RocketMQ 消息存储的设计，为了达成设计目标实现了哪些机制，顺便补充一些背景知识方便读者理解机制的实现。之后会结合源码来详解具体机制的实现。 消息存储模块的设计概要与分析 先笼统的解释 MQ 产品的方案，然后具体到 RocketMQ 常见持久化/存储方案简介 任意应用的存储方案常见的基本...","head":[["meta",{"property":"og:url","content":"https://lament-z.com/docs/message-queue/rocketmq/store.html"}],["meta",{"property":"og:site_name","content":"鲸鱼气球"}],["meta",{"property":"og:title","content":"RocketMQ 源码分析-消息存储和持久化"}],["meta",{"property":"og:description","content":"RocketMQ 的消息存储和持久化 本文会先从概念上介绍 RocketMQ 消息存储的设计，为了达成设计目标实现了哪些机制，顺便补充一些背景知识方便读者理解机制的实现。之后会结合源码来详解具体机制的实现。 消息存储模块的设计概要与分析 先笼统的解释 MQ 产品的方案，然后具体到 RocketMQ 常见持久化/存储方案简介 任意应用的存储方案常见的基本..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-08T10:52:18.000Z"}],["meta",{"property":"article:author","content":"lament-z"}],["meta",{"property":"article:modified_time","content":"2024-03-08T10:52:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 源码分析-消息存储和持久化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-08T10:52:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"lament-z\\",\\"url\\":\\"https://lament-z.com\\"}]}"]]},"headers":[{"level":2,"title":"消息存储模块的设计概要与分析","slug":"消息存储模块的设计概要与分析","link":"#消息存储模块的设计概要与分析","children":[{"level":3,"title":"常见持久化/存储方案简介","slug":"常见持久化-存储方案简介","link":"#常见持久化-存储方案简介","children":[]},{"level":3,"title":"RocketMQ 的持久化设计","slug":"rocketmq-的持久化设计","link":"#rocketmq-的持久化设计","children":[]},{"level":3,"title":"存储模块的目录结构","slug":"存储模块的目录结构","link":"#存储模块的目录结构","children":[]},{"level":3,"title":"CommitLog","slug":"commitlog","link":"#commitlog","children":[]},{"level":3,"title":"ConsumeQueue","slug":"consumequeue","link":"#consumequeue","children":[]},{"level":3,"title":"Index File","slug":"index-file","link":"#index-file","children":[]},{"level":3,"title":"CheckPoint","slug":"checkpoint","link":"#checkpoint","children":[]}]},{"level":2,"title":"核心机制","slug":"核心机制","link":"#核心机制","children":[{"level":3,"title":"CommitLog 刷盘","slug":"commitlog-刷盘","link":"#commitlog-刷盘","children":[]},{"level":3,"title":"ConsumeQueue 刷盘","slug":"consumequeue-刷盘","link":"#consumequeue-刷盘","children":[]},{"level":3,"title":"indexFile 刷盘","slug":"indexfile-刷盘","link":"#indexfile-刷盘","children":[]},{"level":3,"title":"文件恢复","slug":"文件恢复","link":"#文件恢复","children":[]},{"level":3,"title":"TransientStorePool 机制","slug":"transientstorepool-机制","link":"#transientstorepool-机制","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"reference","slug":"reference","link":"#reference","children":[]}],"git":{"createdTime":1708868667000,"updatedTime":1709895138000,"contributors":[{"name":"Lament","email":"lament.wy@gmail.com","commits":2}]},"readingTime":{"minutes":26.55,"words":7966},"filePathRelative":"docs/message-queue/rocketmq/store.md","localizedDate":"2024年2月25日","autoDesc":true,"excerpt":"\\n<p>本文会先从概念上介绍 RocketMQ 消息存储的设计，为了达成设计目标实现了哪些机制，顺便补充一些背景知识方便读者理解机制的实现。之后会结合源码来详解具体机制的实现。</p>\\n<h2>消息存储模块的设计概要与分析</h2>\\n<blockquote>\\n<p>先笼统的解释 MQ 产品的方案，然后具体到 RocketMQ</p>\\n</blockquote>\\n<h3>常见持久化/存储方案简介</h3>\\n<p>任意应用的存储方案常见的基本上就三种：要么你直接使用文件系统进行数据存储，这个在桌面应用里很常见；要么使用各类 KV 存储，比如使用 redis 作为数据库并开启持久化；要么用关系型数据库，比如 MySQL。</p>"}');export{h as comp,f as data};
