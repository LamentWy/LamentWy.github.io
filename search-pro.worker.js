const V=Object.entries,nt=Object.fromEntries,ot="ENTRIES",T="KEYS",R="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),A=Math.min(i-1,a+s);for(let F=f;F<A;++F){const v=g!==t[F],z=o[p+F]+ +v,y=o[p+F+1]+1,w=o[m+F]+1,L=o[m+F+1]=Math.min(z,y,w);L<l&&(l=L)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,it(this._tree,t)}entries(){return new D(this,ot)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},it=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],rt=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},ct=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",P="and",lt="and_not",ht=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,dt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,at={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[P]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[lt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},ft=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},gt=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},mt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,dt),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},pt={k:1.2,b:.7,d:.5},Ft={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(ct),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:pt},_t={combineWith:P,prefix:(e,t,s)=>t===s.length-1},At={batchSize:1e3,batchWait:10},Y={minDirtFactor:.1,minDirtCount:20},yt={...At,...Y},X=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(at[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){mt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const A=g.get(l),F=e._fieldLength.get(l)[h],v=ft(A,m,e._documentCount,F,p,r),z=n*a*f*v,y=d.get(l);if(y){y.score+=z,ht(y.terms,t);const w=H(y.match,s);w?w.push(c):y.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const A=l.length-t.term.length;if(!A)continue;p?.delete(l);const F=a*l.length/(l.length+.3*A);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,A]=p.get(l);if(!A)continue;const F=c*l.length/(l.length+A);B(e,t.term,l,F,f,o,u,d,g)}return g},K=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>K(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(gt(i)).map(a=>Ct(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=K(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class zt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...Ft,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{..._t,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=Y,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const wt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new zt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return Q(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(A=>!A.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const A=m.map(F=>j(f,F)).filter(F=>F!==null);A.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:A},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=rt(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Et(t,e,tt(s)).map(({suggestion:n})=>n),k=nt(V(JSON.parse("{\"/\":{\"documentCount\":56,\"nextId\":56,\"documentIds\":{\"0\":\"1\",\"1\":\"1#future\",\"2\":\"2\",\"3\":\"2#白嫖小马哥\",\"4\":\"2#update-log\",\"5\":\"2#部署\",\"6\":\"2#vuepress\",\"7\":\"2#插件\",\"8\":\"2#主题\",\"9\":\"2#命令\",\"10\":\"2#样式相关\",\"11\":\"2#功能\",\"12\":\"3\",\"13\":\"3#知识库内容\",\"14\":\"4\",\"15\":\"4#基础逻辑\",\"16\":\"4#同步模式\",\"17\":\"4#全同步模式\",\"18\":\"4#半同步模式\",\"19\":\"5\",\"20\":\"5#文档翻译\",\"21\":\"5#memory-consistency-properties\",\"22\":\"5#concurrent-collections\",\"23\":\"5#synchronizers\",\"24\":\"5#timing\",\"25\":\"5#queues\",\"26\":\"5#executor\",\"27\":\"5#具体实现\",\"28\":\"5#reference\",\"29\":\"6\",\"30\":\"6#什么是-rocketmq\",\"31\":\"6#基本架构\",\"32\":\"6#大致流程\",\"33\":\"6#前置要求\",\"34\":\"7\",\"35\":\"7#前置要求\",\"36\":\"7#源码分析\",\"37\":\"7#从发送消息开始\",\"38\":\"7#producer-start\",\"39\":\"7#defaultmqproducer\",\"40\":\"7#defaultmqproducer-start\",\"41\":\"7#defaultmqproducerimpl-start\",\"42\":\"7#producer-send-message-msg\",\"43\":\"7#defaultmqproducer-send-message-msg\",\"44\":\"7#defaultmqproducerimpl-send-message-msg\",\"45\":\"7#defaultmqproducer-batch\",\"46\":\"7#defaultmqproducerimpl\",\"47\":\"7#总结\",\"48\":\"8\",\"49\":\"9\",\"50\":\"10\",\"51\":\"11\",\"52\":\"12\",\"53\":\"13\",\"54\":\"14\",\"55\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,3],\"1\":[1,7],\"2\":[1,7],\"3\":[1,14],\"4\":[2,80],\"5\":[1,13],\"6\":[1,65],\"7\":[1,33],\"8\":[1,5],\"9\":[1,16],\"10\":[1,28],\"11\":[1,19],\"12\":[1,11],\"13\":[1,79],\"14\":[1],\"15\":[1,24],\"16\":[1],\"17\":[1,7],\"18\":[1,8],\"19\":[4,75],\"20\":[1,18],\"21\":[3,20],\"22\":[2,41],\"23\":[1,7],\"24\":[1,11],\"25\":[1,4],\"26\":[1,39],\"27\":[1,50],\"28\":[1,3],\"29\":[2],\"30\":[2,10],\"31\":[1,36],\"32\":[1,97],\"33\":[1,7],\"34\":[3,25],\"35\":[1,6],\"36\":[1,2],\"37\":[1,59],\"38\":[3,7],\"39\":[1,116],\"40\":[3,30],\"41\":[3,229],\"42\":[5,9],\"43\":[5,24],\"44\":[5,258],\"45\":[3,137],\"46\":[1,257],\"47\":[1,13],\"48\":[1,3],\"49\":[1],\"50\":[1],\"51\":[1],\"52\":[1],\"53\":[1],\"54\":[1],\"55\":[2]},\"averageFieldLength\":[1.5714285714285714,42.686614054488786],\"storedFields\":{\"0\":{\"h\":\"博客\",\"t\":[\"这里发布一些杂七杂八，就不分类了。\"]},\"1\":{\"h\":\"Future\",\"t\":[\"考虑将 docs/blog 分开发布，blog 单独发布到子域名下，通过导航跳转。\"]},\"2\":{\"h\":\"本站调试记录\",\"t\":[\"包括 vuepress 以及主题 vuepress-theme-hope 学习和调试的记录。\"]},\"3\":{\"h\":\"白嫖小马哥\",\"t\":[\"logo & favicon 一个 svg，一个 ico。\",\"主页的背景\",\"svg 格式背景图，一张图需要两种风格对应白/黑模式，a1-light/a1-dark。 先嫖个10对吧。\"]},\"4\":{\"h\":\"update log\",\"t\":[\"关缓存！！！\",\"前后重新发布了 n 次也没找到线上显示错误的原因，思前想后才记起怕不是 CL 的缓存没关...\",\"现在不用手动清缓存了，可以直接开启开发者模式禁用缓存。\",\"build 失败\",\"本地运行没问题，执行 build 就报一个 SyntaxError: The requested module 'vue-router' does not provide an export named 'createMemoryHistory'的错误。\",\"由于完全不懂 node，一堆折腾之后，最后通过手动添加依赖解决了。\",\"pnpm add -D vue-router。\",\"github action\",\"权限错误检查两个位置，一个是仓库本身关于 action 的权限，另一个检查你生成的 PAT 权限是不是不够。\",\"警告\",\"Node.js 16 actions are deprecated. Please update the following actions to use Node.js 20: pnpm/action-setup@v2, actions/setup-node@v3. For more information see: https://github.blog/changelog/2023-09-22-github-actions-transitioning-from-node-16-to-node-20/. \",\"看见这个就去升级一下对应 action 的版本，不知道具体版本可以直接 github 搜索。\",\"比如 pnpm/action-setup@v2 就直接搜 pnpm/action-setup，其他细节参考警告中给的链接。\"]},\"5\":{\"h\":\"部署\",\"t\":[\"官方文档里就有，还挺全的，白写了，看这里。\",\"源码库 + 部署库的方式自动部署的几个需要注意的地方。\",\"PAT 权限要够，PAT 要添加到源码库的 Secrets 中。\"]},\"6\":{\"h\":\"vuepress\",\"t\":[\"目录有约定，但并不强制\",\"0开发经验上手略有门槛\",\"有开发经验的体验尚可，有前端经验很好，有 nodejs/vue 经验的话你可以干很多事情。\",\"导航的 link 与 readme.md 文件绑定/readme.md 等同于 /，导航 link: '/xDir/ 意味着 /xDir/ 目录下必须有 readme.md文件，否则你点击导航会 404.\",\"依赖问题导致无法 build | build 失败\",\"根据我解决问题过程中搜索到的内容来看，依赖问题已经多次导致用户的 vuepress 项目无法正常 build。 对于对 node 依赖管理完全不了解的用户其实这是很难自行解决。\",\"先添加这个：\",\"yarn add cross-env --dev \",\"然后编辑 package.json 中的脚本部分:\",\" #package.json: \\\"scripts\\\": { \\\"dev\\\": \\\"cross-env NODE_OPTIONS=--openssl-legacy-provider vuepress dev src\\\", \\\"build\\\": \\\"cross-env NODE_OPTIONS=--openssl-legacy-provider vuepress build src\\\" } \",\"或者直接换 pnpm，反正不懂 node，用 yarn 还是用 pnpm 都没啥区别，但是 VuePress 和 VuePress-theme-hope 都是用 pnpm 进行管理的。\"]},\"7\":{\"h\":\"插件\",\"t\":[\"找插件/主题推荐使用vuepress-tools;\",\"使用方式通用流程：1. 安装插件 2.在.vuepress/config.js中添加插件并配置。\",\"@vuepress/开头的都是官方维护的插件，同时使用前注意插件支持哪个 VuePress 的版本（0.x 1.x 2）。\",\"@vuepress/plugin-back-to-top回到最上。\",\"官方没写说明也没写配置，扫了一眼代码，似乎是300行以上触发。\",\"拖了个以前写的 rocketMQ 分析源码的笔记测试了一下，右下角会自动出现一个向上的箭头。\",\"@vuepress/plugin-medium-zoom图片缩放\",\"点点看\",\"whale balloon\"]},\"8\":{\"h\":\"主题\",\"t\":[\"Hope 主题自带创建项目的脚手架，创建出的项目还自带文档，你可以在另外一个端口额外启动一个当说明书看。\"]},\"9\":{\"h\":\"命令\",\"t\":[\"创建\",\"pnpm create vuepress-theme-hope my-docs \",\"使用\",\"// 启动开发服务器 pnpm docs:dev // 构建项目并输出 pnpm docs:build // 清除缓存并启动开发服务器 pnpm docs:clean-dev \"]},\"10\":{\"h\":\"样式相关\",\"t\":[\"基本围绕着 src/.vuepress/styles 目录下的三个文件进行自定义。\",\"主题颜色覆盖src/.vuepress/styles/palette.scss文件中进行修改。\",\"其中 $theme-color: #82a6b1; 主题颜色影响各种高亮位置。 明暗切换如下:\",\"$bg-color: ( light: #ffeaec, dark: #343f3e, ); \",\"其他更多可以参考该主题的说明文档-样式配置部分，从颜色调整到布局设置啥的很全。\",\"隐藏打印按钮\",\"src/.vuepress/theme.ts中添加 print:false,\"]},\"11\":{\"h\":\"功能\",\"t\":[\"自动创建readme.md\",\"目录下没有readme.md时，会自动生成一个目录页面，该页面标题就是目录本身，外带自动驼峰。\",\"比如 mq/rocketmq/下没有手动创建readme.md时，它自动生成一个标题为 Rocketmq的目录页面。\\n如果是 rocket-mq/，则生成 RocketMq 作为标题。\"]},\"12\":{\"h\":\"指南\",\"t\":[\"近几年技术文章写的越来越多，博客性质的内容越来越少，于是打算放弃 Jekyll，投奔 VuePress。\",\"最近在整理积攒下的笔记和草稿，打算趁着切换 VuePress 的机会，逐步整理出一个自己的线上知识库。\"]},\"13\":{\"h\":\"知识库内容\",\"t\":[\"语言 以 Java 为主，其他语言等 Java 整理完再说。\",\"Java 基础部分只更新重要的基础知识点，JUC，框架部分则只更新 Spring 和 SpringBoot 中自认为比较核心的内容。 基础：注解 泛型 异常 反射 SPI ，集合更一部分，Java 的版本迭代线。\",\"JUC 就主要是 AQS + 线程池 + 工具类 + 并发集合类，顺便加一篇前置内容，把 Synchronized 这些简单介绍下。\",\"SpringCloud 系列放入微服务部分更新。\",\"JVM 部分：JVM 模型，GC，调试工具。\",\"数据库\",\"数据库就粗略的分为 SQL 和 noSQL 两类，前期主要更新 MySQL 和 Redis。\",\"中间件 这部分还没想好，就比如 Redis，你既可以把它看成数据库也可以用作缓存。 目前消息队列是单独更新。\",\"IO IO 的内容也单独更新，包括介绍 IO 类型、IO 的演进，然后是 netty 这个框架，顺便加入一些操作系统的知识点，比如内存。 网络的内容也考虑放这里。\",\"微服务\",\"服务注册/发现，网关，负载均衡，监控。\",\"devOps 一些简单的 devOps 实践。从开发工具到 CICD。\",\"方法论\",\"算法 还没想好怎么更。\",\"未分类\\n一些零碎内容。\"]},\"14\":{\"h\":\"MySQL主从复制\"},\"15\":{\"h\":\"基础逻辑\",\"t\":[\"所有的主从逻辑基本上都是把数据从主服务器同步到从服务器。\",\"MySQL 也一样， 主库 上数据变化会写入二进制文件，binlog，中，然后通过IO把 binlog 的内容写入从库的中继日志中，然后从库从中继日志中读取并执行其中的 SQL语句 完成同步。\",\"主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。\",\"binlog 线程\",\"负责将主库上的数据更改写入 binlog 中。\",\"I/O 线程\",\"负责从主服务器上读取 binlog，并写入从库的中继日志中。\",\"SQL 线程\",\"负责读取中继日志并重放其中的 SQL 语句。\"]},\"16\":{\"h\":\"同步模式\"},\"17\":{\"h\":\"全同步模式\",\"t\":[\"主库在写入 binlog 之后直接开始强制同步到从库，一直要等到从库完成数据同步才会返回给客户端，性能较差，非常少见。\"]},\"18\":{\"h\":\"半同步模式\",\"t\":[\"半同步跟全同步的区别是，在IO那一步中继日志写入完成就给主库发个确认消息，主库 只要收到任意一个从库（假设一主多从）返回的确认消息就认为本次写操作成功，返回给客户端。\"]},\"19\":{\"h\":\"java.util.concurrent 包简介\",\"t\":[\"平时说 JUC ，实际上默认为以下三个包的统称： java.util.concurrent java.util.concurrent.atomic java.util.concurrent.locks\",\"大体可以分为以下几个部分：\",\"locks 包含 AQS, LockSupport ，以及基于 AQS 的锁实现：ReentrantLock,ReentrantReadWriteLock 等。\",\"原子类 atomic 一堆原子类组成的包，可以看作是工具包，主要用来支持对变量进行非阻塞的线程安全编程。\",\"同步辅助类\",\"CountDownLatch（赛车），CyclicBarrier（厨房），Phaser（前面二者的加强版），Semaphore（信号量），Exchanger（这个是线程之间交换变量值的）\",\"线程执行和管理 Future ：代表异步计算的返回结果。\",\"Executor, ExecutorService ：线程任务的执行，执行各种已提交的 Runnable 任务. （Note: 线程的设计把执行机制和执行内容分开，各种 Runnable,Callable 任务就是执行内容，而执行机制，也就是具体如何执行 task 交给 Executor）。\",\"ThreadPoolExecutor： 线程池版Executor，它的基本逻辑是从线程池里获取线程，然后执行。\",\"Executers： 工具类，他是 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和工具方法的合集。\",\"并发集合 ArrayBlockingQueue，ConcurrentHashMap，ConcurrentLinkedDeque，ConcurrentLinkedQueue，ConcurrentSkipListMap，ConcurrentSkipListSet\",\"CopyOnWriteArrayList CopyOnWriteArraySet\",\"LinkedBlockingDeque LinkedBlockingQueue LinkedTransferQueue\",\"PriorityBlockingQueue 等等\"]},\"20\":{\"h\":\"文档翻译\",\"t\":[\"java.util.concurrent 包，简称JUC，是 Java 为并发编程提供的标准化可扩展的框架。\",\"主要组件包括以下部分：Executor、Queues、Timing、Synchronizers、concurrent Collections、Memory Consistency Properties。\"]},\"21\":{\"h\":\"Memory Consistency Properties\",\"t\":[\"内存一致性属性，文档中这部分实际上就是介绍了一下 juc 包中如何实践 happen-before 原则和一些例子。 比如 线程必须事先将元素放入并发集合类中这个动作 happen-before于 线程从并发集合类中访问 or 删除这个元素。 详见文档，如果还是对 happen-before 不理解，请重新阅读之前关于 happen-before 以及 偏序关系的介绍。\"]},\"22\":{\"h\":\"concurrent Collections\",\"t\":[\"并发集合类，就是用于并发环境下的集合类，比如 ConcurrentHashMap 可以看成是同步版本的HashMap，ConcurrentSkipListMap 同步版本的 TreeMap等等。\",\"包中的很多类都带有 concurrent 前缀，它的含义不仅仅是线程安全，还可以“并发”访问。\",\"比如我们可以通过Collections.synchronizedMap(new HashMap())来保证 hashMap 线程安全，但它不是 concurrent 的，因为这里 hashMap 只是通过排它锁，以阻塞同步的方式来保证了线程安全，本质上同一时间只有一个线程访问它并没有并发concurrent。 而并发集合类，比如ConcurrentHashMap则是在特定情况下可以允许任意数量线程并发读取 or 可控数量线程并发写入，同时还保证线程安全。\",\"所以阅读这部分源码or文档时需要注意 synchronized 和 concurrent 的区别，Collections.synchronizedMap(new HashMap())是同步的（synchronized），ConcurrentHashMap 是并发的（concurrent）。\"]},\"23\":{\"h\":\"Synchronizers\",\"t\":[\"主要是五个常见场景的同步器：Semaphore、CountDownLatch、CyclicBarrier、Phaser、Exchanger。\"]},\"24\":{\"h\":\"Timing\",\"t\":[\"主要就是 TimeUnit 类，提供了基于不同时间粒度的操作方法，比如 sleep wait join 啥的。同时附带了一堆时间转换的方法以及时间单位的定义。\"]},\"25\":{\"h\":\"Queues\",\"t\":[\"这部分提供了阻塞/非阻塞的各种线程安全队列。 详情看文档。\"]},\"26\":{\"h\":\"Executor\",\"t\":[\"Executor 是个非常简单的标准化接口，只有一个方法 void execute(Runnable command);，它可以用来定义线程池、异步IO、轻量级任务框架这类型的线程类子系统。\",\"一个特定/具体的 Executor 实现可以是正在创建 Thread，或者是一个正在执行中的 Executor ，或者是 一个线程调用 execute()方法（异步 or 顺序执行）。\",\"可以通过 JUC 包内的例子来理解上面的定义。\",\"以异步任务执行框架为例，ExecutorService (interface ExecutorService extends Executor)在 Executor 基础上进行扩展，通过提供线程状态方法、任务的提交关闭调用等方法，定义了一个异步任务执行框架。\",\"更进一步 ScheduledExecutorService 接口，它通过继承 ExecutorService 接口进一步扩展出了延迟任务和周期任务的执行。\"]},\"27\":{\"h\":\"具体实现\",\"t\":[\"Classes ThreadPoolExecutor and ScheduledThreadPoolExecutor provide tunable, flexible thread pools. The Executors class provides factory methods for the most common kinds and configurations of Executors, as well as a few utility methods for using them. Other utilities based on Executors include the concrete class FutureTask providing a common extensible implementation of Futures, and ExecutorCompletionService, that assists in coordinating the processing of groups of asynchronous tasks.\"]},\"28\":{\"h\":\"reference\",\"t\":[\"oracle java8 doc\"]},\"29\":{\"h\":\"RocketMQ 源码分析\"},\"30\":{\"h\":\"什么是 RocketMQ\",\"t\":[\"RocketMQ 是一个基于主题的发布与订阅模式的消息队列中间价。其设计核心追求高性能、高吞吐量、高可用。 MQ 的核心功能就是消息的接受、发送、存储消息。\"]},\"31\":{\"h\":\"基本架构\",\"t\":[\"其基本架构由客户端（包括消息的生产者和消费者），NameSrv，Broker 组成。\",\"NameSrv 像是“注册中心/服务发现”，但实际上只是简单的路由信息的管理模块，其高可用通过部署多个 NameSrv 来保证，各个 NameSrv 之间不进行通信，允许分钟级的数据不一致。\",\"Broker 则是定期上报各种路由信息给 NameSrv，并且复制接收、推送/拉取消息以及消息持久化。比如收到消息后先写入缓冲区，之后以同步/异步的方式刷盘写入 commit.log，并且异步转发给 ConsumeQueue 或者 index 文件方便以 topic 或者索引的方式检索消息等等。\",\"客户端从 NameSrv 上同步路由信息，并在本地进行缓存，然后根据路由信息找到对应的 Broker 进行消息的发布和订阅。\"]},\"32\":{\"h\":\"大致流程\",\"t\":[\"Producer 向 Broker 发送消息：\",\"从使用者的角度去看，Producer 是向 Topic 发布消息；从数据流动角度看，是从 Producer 流动到 Broker。\",\"先根据 topic 检查本地路由表（Producer 每 30s 会从 NameServer 拉一次），本地没有就带着 topic 去 NameServer 查询，查到了就按具体情况选好 Broker 发送消息；如果没查到（假设没有开启自动创建主题机制）抛出路由信息错误。最后 Producer 是否接收返回信息以及用什么方式处理返回信息取决于采取的是哪种发送方式。\",\"自动创建主题机制就是如果启用了该机制， Broker 会自动创建一个 TOPIC（名字挺奇怪的叫 \\\"TBW102\\\"，难道是淘宝网102？）以及对应的路由信息，所有错误/不存在的 topic 的路由信息都存在这里，TBW102 的路由信息也会自动上报到 NameServer。\",\"换句话说，当你写错 topic 的时候，Producer 执行 topic 路由的过程就变成了使用 \\\"TBW102\\\" 这个 topic 进行路由的过程。\",\"Broker 存储消息\",\"Broker 收到消息后，把消息写入 commit.log 文件，同时还有一个线程不断从 commit.log 中读取消息数据转发给消费队列。\",\"Consumer 消费消息\",\"Consumer 与 Broker 之间传递消息有两种方式:pull & push。其他的什么消费组，各种模式等等细节后续章节展开。\",\"RocketMQ 中，Consumer 消费消息是基于消费组 ConsumerGroup 开展的，一个消费组可以包含多个消费者，消费组可以订阅多个 Topic。\",\"消费组 ConsumerGroup 由 Consumer 组成，在不同的消费模式，消费组的行为并不一致。\",\"为了满足不同使用场景，RocketMQ 提供了两种消费模式：集群模式、广播模式。\",\"集群模式就是把消费组内的所有 Consumer 视为一个集群，同一个 Topic 下的同一条消息只能被其中一个 Consumer 消费，换句话说就是一条消息只能被集群（也就是 ConsumerGroup）消费一次。\",\"广播模式则是把消费组内的 Consumer 视为不同个体，一条消息可以被所有 Consumer 消费。\",\"Consumer 与 Broker 之间传递消息有两种方式: pull & push。\",\"拉模式： Consumer 主动向 Broker 发送拉取消息的请求。\",\"推模式： Broker 主动向 Consumer 推送消息，实际上这个推模式也是在拉模式的基础上做的实现，后续中展开细说。\"]},\"33\":{\"h\":\"前置要求\",\"t\":[\"阅读官方文档，完成 RocketMQ 的本地部署，并尝试发送和消费消息。下一节将从发送消息入手进行源码分析。\\n\"]},\"34\":{\"h\":\"RocketMQ 源码分析-发送消息\",\"t\":[\"这里开始详细聊聊 RocketMQ 发送消息的各种细节。\",\"前面在简介里面说了，从使用者的角度，Producer 看起来就是直接往 Topic 里面塞消息。而实际上呢，要先去 Namesrv 找到 Topic 的路由信息，然后才能确定 Topic 是由哪个 Broker 管理。\",\"发送消息支持三种方式，同步、异步、单向，区别很简单不再赘述，下文以同步为例进行分析。\"]},\"35\":{\"h\":\"前置要求\",\"t\":[\"这里就假设读者已经顺利完成了 quick start 中的内容，收发消息已经全部成功。\"]},\"36\":{\"h\":\"源码分析\",\"t\":[\"整个过程以描述+代码注释的方式进行。\"]},\"37\":{\"h\":\"从发送消息开始\",\"t\":[\"下面贴了一段简单的发送消息的代码，逻辑很简单，先创建并启动 producer， 然后发送消息。\",\"// 创建 Producer DefaultMQProducer producer = new DefaultMQProducer(\\\"ProducerGroupName\\\"); producer.start(); // 启动 - 这是个 netty client for (int i = 0; i < 128; i++) try { { // 构造消息 Message msg = new Message(\\\"TopicTest\\\", \\\"TagA\\\", \\\"OrderID188\\\", \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); // 发送消息，这里是以同步的方式拿到返回结果。 // 异步则是通过 callback // 单向则不关心结果 SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } } catch (Exception e) { e.printStackTrace(); } producer.shutdown(); // 关闭 \",\"确实非常简单对吧，接下来进入 producer.start(); 方法。\"]},\"38\":{\"h\":\"producer.start()\",\"t\":[\"producer 是 DefaultMQProducer 的实例，于是我们来看 DefaultMQProducer 是啥。\"]},\"39\":{\"h\":\"DefaultMQProducer\",\"t\":[\"分析一个类就跟我们自己写一个类的流程差不多，先看他的属性和构造方法，然后再去看他的功能，也就是提供了哪些方法。\",\"属性\",\"源码中这部分是有注释的，可以先自己过一遍源码。\",\" protected final transient DefaultMQProducerImpl defaultMQProducerImpl; // 重试的响应码 private final Set<Integer> retryResponseCodes = new CopyOnWriteArraySet<Integer>(Arrays.asList( ResponseCode.TOPIC_NOT_EXIST, ResponseCode.SERVICE_NOT_AVAILABLE, ResponseCode.SYSTEM_ERROR, ResponseCode.NO_PERMISSION, ResponseCode.NO_BUYER_ID, ResponseCode.NOT_IN_CURRENT_UNIT )); // 生产者组，这个概念后面细说 private String producerGroup; // 这就是自动创建主题机制的那个 Topic private String createTopicKey = TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC; // 前面 Namesrv 里提过，一个 Broker 默认情况下会为每个 topic 创建 4个 readQueue 和 4个 writeQueue。 private volatile int defaultTopicQueueNums = 4; private int sendMsgTimeout = 3000; // 这个是压缩消息的阈值，Message.body 的大小超过 4k 就进行压缩 private int compressMsgBodyOverHowmuch = 1024 * 4; // 发送消息失败会重试两次（总共最多发3次） 后面细说 private int retryTimesWhenSendFailed = 2; // 这是发送异步消息失败也是重试两次 // 源码注释里写了，这里也先提一下，异步消息失败的重试机制可能会造成消息重复发送。 private int retryTimesWhenSendAsyncFailed = 2; // 这个是消息发送失败时，是否切换另外的 broker private boolean retryAnotherBrokerWhenNotStoreOK = false; // 消息大小的上限 aka 4M private int maxMessageSize = 1024 * 1024 * 4; // 这个先无视 private TraceDispatcher traceDispatcher = null; \",\"构造方法\",\"数了一下...有10个构造方法，就不全贴出来了，只看这一个就行。\",\"public DefaultMQProducer(final String namespace, final String producerGroup, RPCHook rpcHook) { this.namespace = namespace; this.producerGroup = producerGroup; defaultMQProducerImpl = new DefaultMQProducerImpl(this, rpcHook); } \",\"可以看出来 DefaultMQProducer 其实就是对 DefaultMQProducerImpl 做了一层包装，他的其他方法就不列出来了，可以自己观察一下，这里我们直接去看 DefaultMQProducer::start()。\"]},\"40\":{\"h\":\"DefaultMQProducer::start()\",\"t\":[\"// DefaultMQProducer::start() public void start() throws MQClientException { this.setProducerGroup(withNamespace(this.producerGroup)); // 实际启动的是 DefaultMQProducerImpl this.defaultMQProducerImpl.start(); if (null != traceDispatcher) { try { traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel()); } catch (MQClientException e) { log.warn(\\\"trace dispatcher start failed \\\", e); } } } \",\"果然是对 DefaultMQProducerImpl::start() 的包装。\"]},\"41\":{\"h\":\"DefaultMQProducerImpl::start()\",\"t\":[\"public void start() throws MQClientException { this.start(true); } \",\"public void start(final boolean startFactory) throws MQClientException { // 起手就是个 switch switch (this.serviceState) { // serviceState 属性默认是 CREATE_JUST // 而无论是 DefaultMQProducerImpl 或者 DefaultMQProducer 的构造方法中都没有修改该属性的操作，所以我们的 producer.start() 肯定会进入 CREATE_JUST 分支。 case CREATE_JUST: // 进来之后直接先标记为 启动失败 的状态。 this.serviceState = ServiceState.START_FAILED; /* --- 校验开始 --- */ // 然后开始检查配置，实际就是检查 producerGroup 是否存在，是不是默认的 \\\"DEFAULT_PRODUCER\\\" ，不符合要求就抛个异常提醒用户修改。 // 比如 new DefaultMQProducer();时没有自定义 producerGroup 时，rocketmq 会默认你的 producerGroup 为 “DEFAULT_PRODUCER”， 之后代码运行到这里就抛异常了 this.checkConfig(); // 这段判定的作用跟上面的 this.checkConfig(); 其实差不多，也是提醒你要自定义 producerGroup。 // 只要 ProducerGroup 不等于 \\\"CLIENT_INNER_PRODUCER\\\" // 这个默认值是走 MQClientInstance 初始化 producer 用的。 if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) { // 这里要做的事情就是 如果 InstanceName 为 \\\"DEFAULT\\\" 就改成 Pid#TimeStamp 的形式。 // 目的是为了区分不同的 producer 实例 this.defaultMQProducer.changeInstanceNameToPID(); } /* --- 校验结束 --- */ /** 创建 MQ客户端的实例，这里简单说一下 MQClientInstance 是个啥，本质上就是 netty 客户端 + RocketMQ 自身的需求实现。 注意这里说的客户端/client 的概念是不区分 Consumer 和 Producer ，这两种角色都看作客户端。 MQClientManager ，他里面维护了一个 clientID 和 MQClientInstance 一一对应的 kv 结构，这里为了满足并发的需要用的是 ConcurrentHashMap。 */ /* 然后我们来看代码， MQClientManager.getInstance() 返回的是 MQClientManager 的 getOrCreateMQClientInstance() 返回的是 MQClientInstance 。 也就是前面说的 netty 客户端。 getOrCreateMQClientInstance 方法的逻辑是 key(clientId) 对应的 value(MQClientInstance) 存在则直接返回，不存在则创建后返回。 */ // 创建 instance // 无视掉 mQClientFactory 这个变量名，就是个 instance. this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook); /* MQClientInstance 创建好了，但是 Instance 的角色还不明确，前面说了，它可以是生产者也可以是消费者，这里 registerProducer 就是给 MQClientInstance 明确身份 registerProducer() 方法就是把刚创建的这个 MQClientInstance 注册到其内部维护的 producerTable 中 producerTable 也是 ConcurrentHashMap，他的 key 就是创建 Producer 时我们自定义的 ProducerGroup 一个 group 只对应一个 instance, 从这里我们就可以看出 ProducerGroup 这个 group 概念是基于集群的. 之后消费环节的 ConsumerGroup 同理 */ // 把 instance 注册到 producerTable，明确 instance 角色 boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this); if (!registerOK) { // ProducerGroup 和 MQClientInstance 一一对应，重复就会抛下面的异常 this.serviceState = ServiceState.CREATE_JUST; throw new MQClientException(\\\"The producer group[\\\" + this.defaultMQProducer.getProducerGroup() + \\\"] has been created before, specify another name please.\\\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL), null); } // 把 producer 的信息存入本地的 Topic 路由信息表中，并且初始化该 topic 的路由信息 this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo()); if (startFactory) { mQClientFactory.start(); // 最终可以看出，producer.start() 其实就是启动 netty 客户端。 } log.info(\\\"the producer [{}] start OK. sendMessageWithVIPChannel={}\\\", this.defaultMQProducer.getProducerGroup(), this.defaultMQProducer.isSendMessageWithVIPChannel()); // 将 ServiceState 修改为 运行中 this.serviceState = ServiceState.RUNNING; break; case RUNNING: case START_FAILED: case SHUTDOWN_ALREADY: throw new MQClientException(\\\"The producer service state not OK, maybe started once, \\\" + this.serviceState + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK), null); default: break; } // producer 发送首次心跳请求。 this.mQClientFactory.sendHeartbeatToAllBrokerWithLock(); // 启动定时任务，这个定时任务是扫描并移除 requestFutureTable 中的过期请求 // 初始启动延迟3秒，之后一秒执行一次 this.startScheduledTask(); } \",\"简单总结一下，创建 producer 并执行 producer.start() 的过程，实际上就是创建了一个自定义的 netty 客户端，标记为 Producer 角色，并且初始化其对应的 groupTable 和本地路由信息表，然后启动该客户端。客户端启动后发出首次心跳，并开启定时任务这个流程。\"]},\"42\":{\"h\":\"producer.send(Message msg)\",\"t\":[\"搞清楚了什么是 producer 和 producer.start() 都做了什么之后，接下来我们来看 producer.send()，也就是发送消息的流程。\"]},\"43\":{\"h\":\"DefaultMQProducer::send(Message msg)\",\"t\":[\" public SendResult send( Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 校验 msg Validators.checkMessage(msg, this); // 完善 Topic 信息 msg.setTopic(withNamespace(msg.getTopic())); return this.defaultMQProducerImpl.send(msg); } \",\"依然是包装。\"]},\"44\":{\"h\":\"DefaultMQProducerImpl::send(Message msg)\",\"t\":[\" public SendResult send( Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { return send(msg, this.defaultMQProducer.getSendMsgTimeout()); } \",\" public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 可以看到我们直接 producer.send(msg) 时，默认为同步的方式。 // CommunicationMode.SYNC return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout); } \",\"主要看 sendDefaultImpl() 方法：\",\" private SendResult sendDefaultImpl( Message msg, final CommunicationMode communicationMode, // 同步、异步、单向由该参数决定 final SendCallback sendCallback, final long timeout ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 校验 // 检查 ServiceState 是不是 RUNNING this.makeSureStateOK(); // 校验 msg 的合法性，是不是为空啊，是不是超过4m最大小限制等等。 // 跟 defaultMQProducer::send 里面那行校验是一样的是。 Validators.checkMessage(msg, this.defaultMQProducer); final long invokeID = random.nextLong(); // 用来算超时的各种时间戳变量 long beginTimestampFirst = System.currentTimeMillis(); long beginTimestampPrev = beginTimestampFirst; long endTimestamp = beginTimestampFirst; // tryToFindTopicPublishInfo 方法就是 Intro 中提到的 producer 发消息时的整个路由流程 // 前面看 producer.start() 时，结尾部分不是创建了一个空的路由信息么 new TopicPublishInfo() // 这个空的 topicPublishInfo 也在这里完成真正的初始化。 // 后面看 DefaultMQProducerImpl 时具体展开。 TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); // 本地路由表不为空 才继续执行 if (topicPublishInfo != null && topicPublishInfo.ok()) { boolean callTimeout = false; MessageQueue mq = null; Exception exception = null; SendResult sendResult = null; // timesTotal就是一条消息的发送总次数，同步模式下 最多3次，1是正常发送那一次，剩下的两次是默认的重试次数； // 非同步模式为1次，非同步模式就是单向和异步，单向自然就是一次，异步其实是可以重试的，也就是不止一次。 int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; int times = 0; /* 下面是发送流程 */ // brokersSent 发送次数 String[] brokersSent = new String[timesTotal]; for (; times < timesTotal; times++) // mq 里保存了 topic, brokerName, queueId 三项属性。 String lastBrokerName = null == mq ? null : mq.getBrokerName(); /* Broker 会为 Topic 创建多个 Queue，默认为 4个 readQueue 和 4个 writeQueue selectOneMessageQueue()这个方法这里不过多展开了，可以自己看一下。 */ // 根据路由信息找到用哪个 Queue，放在什么位置。 MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); if (mqSelected != null) { mq = mqSelected; brokersSent[times] = mq.getBrokerName(); try { beginTimestampPrev = System.currentTimeMillis(); if (times > 0) { //Reset topic with namespace during resend. msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic())); } long costTime = beginTimestampPrev - beginTimestampFirst; if (timeout < costTime) { callTimeout = true; break; } // 这里还是先不展开说明，概括一下就是 ENCODE 好数据包，然后执行 netty 的 writeAndFlush // sendKernelImpl 再下一层的代码不明白的可以去看一眼 Netty，过一遍 netty 的 quick start 再回来看毕竟好懂。 // 发送消息并拿到返回结果。 sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime); endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false); // 不同模式下返回结果的处理 switch (communicationMode) { case ASYNC: // 异步获取结果是利用 callback return null; case ONEWAY: // 单向发送不需要返回结果 return null; case SYNC: // 这里是我们要看的同步 if (sendResult.getSendStatus() != SendStatus.SEND_OK) { // 重试逻辑，这个变量名 =_= if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) { continue; } } return sendResult; default: break; } // 后面都是异常的处理啥的 } catch (RemotingException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true); log.warn(String.format(\\\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); exception = e; continue; } catch (MQClientException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true); log.warn(String.format(\\\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); exception = e; continue; } catch (MQBrokerException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true); log.warn(String.format(\\\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); exception = e; if (this.defaultMQProducer.getRetryResponseCodes().contains(e.getResponseCode())) { continue; } else { if (sendResult != null) { return sendResult; } throw e; } } catch (InterruptedException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false); log.warn(String.format(\\\"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); log.warn(\\\"sendKernelImpl exception\\\", e); log.warn(msg.toString()); throw e; } } else { break; } } if (sendResult != null) { return sendResult; } String info = String.format(\\\"Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s\\\", times, System.currentTimeMillis() - beginTimestampFirst, msg.getTopic(), Arrays.toString(brokersSent)); info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED); MQClientException mqClientException = new MQClientException(info, exception); if (callTimeout) { throw new RemotingTooMuchRequestException(\\\"sendDefaultImpl call timeout\\\"); } if (exception instanceof MQBrokerException) { mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode()); } else if (exception instanceof RemotingConnectException) { mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION); } else if (exception instanceof RemotingTimeoutException) { mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT); } else if (exception instanceof MQClientException) { mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION); } throw mqClientException; } validateNameServerSetting(); throw new MQClientException(\\\"No route info of this topic: \\\" + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO), null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION); } \",\"到此 producer.send() 的源码分析告一段落。\",\"前面说过，发送消息支持三种模式，同步、异步、单向。 从前面的代码中我们可以发现，无论那种，最终具体实现都是 defaultMQProducerImpl::sendDefaultImpl() 里完成的。同步和异步的区别主要是入参的不同以及异步需要 callback 获取返回结果。而单向跟同步一个逻辑，只不过返回值被无视了。\",\"文章最后稍微再补充一些关于 defaultMQProducerImpl 的内容。\",\"发送消息这里还有一个可以看一下，批量发送消息，也就是 DefaultMQProducer::batch()方法.\"]},\"45\":{\"h\":\"DefaultMQProducer::batch()`\",\"t\":[\"批量其实就是给单次发送的处理流程外面加了层循环。\",\"private MessageBatch batch(Collection<Message> msgs) throws MQClientException { // MessageBatch 内部结构就是 List<Message> messages; MessageBatch msgBatch; try { // 这里 generateFromList 其实主要是对消息集合进行过滤 // 不满足批量发送条件会直接抛异常 注意跟后面的 Validators.checkMessage 进行区分 msgBatch = MessageBatch.generateFromList(msgs); for (Message message : msgBatch) { // 校验消息合法性 非批量发送也有这一步 Validators.checkMessage(message, this); // 在 Message.properties 里添加一组 kv 参数 // UNIQ_KEY：具体的key值，就通过 ip + host + 类加载的 hashcode 啥的有兴趣自己去看 MessageClientIDSetter.setUniqID(message); // 设置 topic，非批量发送也有这一步 message.setTopic(withNamespace(message.getTopic())); } // 这里 msgBatch.encode() 就是对整个 messageList 进行 encode。 // 具体细节下面展开说 msgBatch.setBody(msgBatch.encode()); } catch (Exception e) { throw new MQClientException(\\\"Failed to initiate the MessageBatch\\\", e); } msgBatch.setTopic(withNamespace(msgBatch.getTopic())); return msgBatch; } \",\"通过代码可以看出batch()方法的逻辑就是把所有 message 加好对应的标记，之后批量 encode，然后存放到msgBatch.setBody等待发送。\",\" // msgBatch.encode() 就是调用 MessageDecoder.encodeMessages() public static byte[] encodeMessages(List<Message> messages) { //TODO refactor, accumulate in one buffer, avoid copies // 那个 TODO 是源码里的，无视掉就好了 // 创建一个 buffer list 用来存 encode 之后的 message。 List<byte[]> encodedMessages = new ArrayList<byte[]>(messages.size()); // 目前还不知道所有 message 加起来一共占用多大内存，所以初始化为0. int allSize = 0; // 这个循环，首先对 msg 逐条 encode。 // 然后把 encode 完的 msg 存到 buffer list里 // 之后累加计算所有 msg 最终需要多大的 buffer / 也就是内存。 for (Message message : messages) { byte[] tmp = encodeMessage(message); encodedMessages.add(tmp); allSize += tmp.length; } // 按照计算出的 size 分配内存 byte[] allBytes = new byte[allSize]; int pos = 0; /* 通过 System.arraycopy 来将前面 buff list， 也就是 encodedMessages，中的数据复制到 allBytes 中， 这个 allBytes 就是之后 msgBatch.setBody()的参数。 */ for (byte[] bytes : encodedMessages) { System.arraycopy(bytes, 0, allBytes, pos, bytes.length); pos += bytes.length; } return allBytes; } \"]},\"46\":{\"h\":\"DefaultMQProducerImpl\",\"t\":[\"接下来我们来看看 DefaultMQProducerImpl 类提供的各种具体实现，不过还是老样子，先看属性和构造方法。\",\"属性\",\" // 随机数 private final Random random = new Random(); // 外层的壳子 private final DefaultMQProducer defaultMQProducer; // 之前 intro 里面提过，Producer 本地是有缓存 topic 的路由信息的，就是存在这里。 //本地路由信息表。key: Topic, Value: TopicPublishInfo private final ConcurrentMap<String/* topic */, TopicPublishInfo> topicPublishInfoTable = new ConcurrentHashMap<String, TopicPublishInfo>(); // 存 hook 的 list private final ArrayList<SendMessageHook> sendMessageHookList = new ArrayList<SendMessageHook>(); private final ArrayList<EndTransactionHook> endTransactionHookList = new ArrayList<EndTransactionHook>(); // hook ，支持两个阶段，request 之前 和 request 之后 private final RPCHook rpcHook; // 异步发送时用的 workQueue 和 Executor private final BlockingQueue<Runnable> asyncSenderThreadPoolQueue; private final ExecutorService defaultAsyncSenderExecutor; // 定时任务的 Executor private final ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(r -> new Thread(r, \\\"RequestHouseKeepingService\\\")); // 这俩也是一套 workQueue + Executor。 protected BlockingQueue<Runnable> checkRequestQueue; protected ExecutorService checkExecutor; // 状态字段 代表 instance 刚刚创建 private ServiceState serviceState = ServiceState.CREATE_JUST; // instance private MQClientInstance mQClientFactory; private ArrayList<CheckForbiddenHook> checkForbiddenHookList = new ArrayList<CheckForbiddenHook>(); // 压缩级别 private int zipCompressLevel = Integer.parseInt(System.getProperty(MixAll.MESSAGE_COMPRESS_LEVEL, \\\"5\\\")); // 失败策略 private MQFaultStrategy mqFaultStrategy = new MQFaultStrategy(); private ExecutorService asyncSenderExecutor; \",\"构造方法\",\" public DefaultMQProducerImpl(final DefaultMQProducer defaultMQProducer, RPCHook rpcHook) { this.defaultMQProducer = defaultMQProducer; this.rpcHook = rpcHook; // 下面就是创建 workQueue 和 ThreadPoolExecutor this.asyncSenderThreadPoolQueue = new LinkedBlockingQueue<Runnable>(50000); this.defaultAsyncSenderExecutor = new ThreadPoolExecutor( Runtime.getRuntime().availableProcessors(), Runtime.getRuntime().availableProcessors(), 1000 * 60, TimeUnit.MILLISECONDS, this.asyncSenderThreadPoolQueue, new ThreadFactory() { private AtomicInteger threadIndex = new AtomicInteger(0); @Override public Thread newThread(Runnable r) { return new Thread(r, \\\"AsyncSenderExecutor_\\\" + this.threadIndex.incrementAndGet()); } }); } \",\"tryToFindTopicPublishInfo 方法\",\" private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) { // 从本地路由信息表里，根据 topic 取出对应的本地路由信息 TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic); if (null == topicPublishInfo || !topicPublishInfo.ok()) { // 如果 topic 的路由信息不存在 // 保护代码 this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo()); // 从 NameServer 上拉数据，更新本地路由信息表以及一系列相关信息。 // 这个方法是线程安全的。 这个展开也超长，有兴趣可以自己看一下 this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic); // 更新完本地路由信息表后重新取出 topic 的路由信息 topicPublishInfo = this.topicPublishInfoTable.get(topic); } // 路由信息存在，则直接返回。 if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) { return topicPublishInfo; } else { // 还不存在，再次去 broker 更新 this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer); topicPublishInfo = this.topicPublishInfoTable.get(topic); return topicPublishInfo; } } \",\"sendKernelImpl\",\"这里就是前面说的 producer.send() 方法\",\"// 这个可就太长了，只贴 switch 这段 switch (communicationMode) { case ASYNC: // 异步 Message tmpMessage = msg; boolean messageCloned = false; if (msgBodyCompressed) { //If msg body was compressed, msgbody should be reset using prevBody. //Clone new message using commpressed message body and recover origin massage. //Fix bug:https://github.com/apache/rocketmq-externals/issues/66 tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; msg.setBody(prevBody); } if (topicWithNamespace) { if (!messageCloned) { tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; } msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace())); } // 超时判断 long costTimeAsync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeAsync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), tmpMessage, requestHeader, timeout - costTimeAsync, communicationMode, sendCallback, topicPublishInfo, this.mQClientFactory, this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), context, this); break; case ONEWAY: case SYNC: long costTimeSync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeSync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } // 同步发送消息。 sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), msg, requestHeader, timeout - costTimeSync, communicationMode, context, this); break; default: assert false; break; } \",\"有兴趣的话可以从 this.mQClientFactory.getMQClientAPIImpl() 方法继续往下看， 再下面一层就是 netty 层了，如何封装 request/response，header/body，api 怎么写什么的。 最终你应该能找到对 NettyRemotingAbstract::invokeSyncImpl() 方法的调用，这个方法 里就能看到熟悉的 channel.writeAndFlush(request)。\"]},\"47\":{\"h\":\"总结\",\"t\":[\"本文以跟随 producer.send() 为主线，通过对源码进行跟踪来了解 producer 发送消息背后的整体逻辑和流程。\",\"PS. RocketMQ 的源码是真的很难读，作为练习重构技巧的项目其实挺合适的，阅读和分析真是好痛苦，后面的篇幅会进一步省略一些与主线逻辑关系不大的代码片段。\"]},\"48\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"49\":{\"h\":\"Mysql\"},\"50\":{\"h\":\"Db\"},\"51\":{\"h\":\"Docs\"},\"52\":{\"h\":\"Juc\"},\"53\":{\"h\":\"Java\"},\"54\":{\"h\":\"Rocketmq\"},\"55\":{\"h\":\"Message Queue\"}},\"dirtCount\":0,\"index\":[[\"阅读和分析真是好痛苦\",{\"1\":{\"47\":1}}],[\"阅读官方文档\",{\"1\":{\"33\":1}}],[\"作为练习重构技巧的项目其实挺合适的\",{\"1\":{\"47\":1}}],[\"作为标题\",{\"1\":{\"11\":1}}],[\"总结\",{\"0\":{\"47\":1}}],[\"总共最多发3次\",{\"1\":{\"39\":1}}],[\"怎么写什么的\",{\"1\":{\"46\":1}}],[\"如何封装\",{\"1\":{\"46\":1}}],[\"如果\",{\"1\":{\"41\":1,\"46\":1}}],[\"如果没查到\",{\"1\":{\"32\":1}}],[\"如果还是对\",{\"1\":{\"21\":1}}],[\"如果是\",{\"1\":{\"11\":1}}],[\"层了\",{\"1\":{\"46\":1}}],[\"超时判断\",{\"1\":{\"46\":1}}],[\"66\",{\"1\":{\"46\":1}}],[\"60\",{\"1\":{\"46\":1}}],[\"更新\",{\"1\":{\"46\":1}}],[\"更新完本地路由信息表后重新取出\",{\"1\":{\"46\":1}}],[\"更新本地路由信息表以及一系列相关信息\",{\"1\":{\"46\":1}}],[\"更进一步\",{\"1\":{\"26\":1}}],[\"保护代码\",{\"1\":{\"46\":1}}],[\"取出对应的本地路由信息\",{\"1\":{\"46\":1}}],[\"50000\",{\"1\":{\"46\":1}}],[\"5\",{\"1\":{\"46\":1}}],[\"zipcompresslevel\",{\"1\":{\"46\":1}}],[\"zoom图片缩放\",{\"1\":{\"7\":1}}],[\"压缩级别\",{\"1\":{\"46\":1}}],[\"刚刚创建\",{\"1\":{\"46\":1}}],[\"代表\",{\"1\":{\"46\":1}}],[\"代表异步计算的返回结果\",{\"1\":{\"19\":1}}],[\"状态字段\",{\"1\":{\"46\":1}}],[\"定时任务的\",{\"1\":{\"46\":1}}],[\"定义了一个异步任务执行框架\",{\"1\":{\"26\":1}}],[\"支持两个阶段\",{\"1\":{\"46\":1}}],[\"外层的壳子\",{\"1\":{\"46\":1}}],[\"外带自动驼峰\",{\"1\":{\"11\":1}}],[\"随机数\",{\"1\":{\"46\":1}}],[\"来将前面\",{\"1\":{\"45\":1}}],[\"来保证\",{\"1\":{\"22\":1,\"31\":1}}],[\"按照计算出的\",{\"1\":{\"45\":1}}],[\"逐条\",{\"1\":{\"45\":1}}],[\"逐步整理出一个自己的线上知识库\",{\"1\":{\"12\":1}}],[\"首先对\",{\"1\":{\"45\":1}}],[\"加起来一共占用多大内存\",{\"1\":{\"45\":1}}],[\"加好对应的标记\",{\"1\":{\"45\":1}}],[\"那个\",{\"1\":{\"45\":1}}],[\"设置\",{\"1\":{\"45\":1}}],[\"参数\",{\"1\":{\"45\":1}}],[\"内部结构就是\",{\"1\":{\"45\":1}}],[\"内存一致性属性\",{\"1\":{\"21\":1}}],[\"批量其实就是给单次发送的处理流程外面加了层循环\",{\"1\":{\"45\":1}}],[\"批量发送消息\",{\"1\":{\"44\":1}}],[\"`\",{\"0\":{\"45\":1}}],[\"获取返回结果\",{\"1\":{\"44\":1}}],[\"无论那种\",{\"1\":{\"44\":1}}],[\"无视掉就好了\",{\"1\":{\"45\":1}}],[\"无视掉\",{\"1\":{\"41\":1}}],[\"到此\",{\"1\":{\"44\":1}}],[\"再下面一层就是\",{\"1\":{\"46\":1}}],[\"再下一层的代码不明白的可以去看一眼\",{\"1\":{\"44\":1}}],[\"再次去\",{\"1\":{\"46\":1}}],[\"再回来看毕竟好懂\",{\"1\":{\"44\":1}}],[\"过一遍\",{\"1\":{\"44\":1}}],[\"好数据包\",{\"1\":{\"44\":1}}],[\"概括一下就是\",{\"1\":{\"44\":1}}],[\"概念是基于集群的\",{\"1\":{\"41\":1}}],[\">\",{\"1\":{\"44\":1,\"45\":2,\"46\":1}}],[\"放在什么位置\",{\"1\":{\"44\":1}}],[\"根据\",{\"1\":{\"46\":1}}],[\"根据路由信息找到用哪个\",{\"1\":{\"44\":1}}],[\"根据我解决问题过程中搜索到的内容来看\",{\"1\":{\"6\":1}}],[\"三项属性\",{\"1\":{\"44\":1}}],[\"剩下的两次是默认的重试次数\",{\"1\":{\"44\":1}}],[\"才继续执行\",{\"1\":{\"44\":1}}],[\"结尾部分不是创建了一个空的路由信息么\",{\"1\":{\"44\":1}}],[\"结构\",{\"1\":{\"41\":1}}],[\"跟\",{\"1\":{\"44\":1}}],[\"检查\",{\"1\":{\"44\":1}}],[\"检查本地路由表\",{\"1\":{\"32\":1}}],[\"默认为\",{\"1\":{\"44\":1}}],[\"默认为同步的方式\",{\"1\":{\"44\":1}}],[\"默认情况下会为每个\",{\"1\":{\"39\":1}}],[\"依然是包装\",{\"1\":{\"43\":1}}],[\"依赖管理完全不了解的用户其实这是很难自行解决\",{\"1\":{\"6\":1}}],[\"依赖问题已经多次导致用户的\",{\"1\":{\"6\":1}}],[\"依赖问题导致无法\",{\"1\":{\"6\":1}}],[\"信息\",{\"1\":{\"43\":1}}],[\"信号量\",{\"1\":{\"19\":1}}],[\"完的\",{\"1\":{\"45\":1}}],[\"完善\",{\"1\":{\"43\":1}}],[\"完成\",{\"1\":{\"33\":1}}],[\"完成同步\",{\"1\":{\"15\":1}}],[\"搞清楚了什么是\",{\"1\":{\"42\":1}}],[\"标记为\",{\"1\":{\"41\":1}}],[\"简单总结一下\",{\"1\":{\"41\":1}}],[\"简称juc\",{\"1\":{\"20\":1}}],[\"初始启动延迟3秒\",{\"1\":{\"41\":1}}],[\"初始化\",{\"1\":{\"41\":1}}],[\"运行中\",{\"1\":{\"41\":1}}],[\"修改为\",{\"1\":{\"41\":1}}],[\"将\",{\"1\":{\"41\":1}}],[\"路由信息存在\",{\"1\":{\"46\":1}}],[\"路由信息表中\",{\"1\":{\"41\":1}}],[\"路由的过程就变成了使用\",{\"1\":{\"32\":1}}],[\"重试逻辑\",{\"1\":{\"44\":1}}],[\"重试的响应码\",{\"1\":{\"39\":1}}],[\"重复就会抛下面的异常\",{\"1\":{\"41\":1}}],[\"角色\",{\"1\":{\"41\":2}}],[\"明确\",{\"1\":{\"41\":1}}],[\"明确身份\",{\"1\":{\"41\":1}}],[\"明暗切换如下\",{\"1\":{\"10\":1}}],[\"存\",{\"1\":{\"46\":1}}],[\"存到\",{\"1\":{\"45\":1}}],[\"存在则直接返回\",{\"1\":{\"41\":1}}],[\"存储消息\",{\"1\":{\"30\":1,\"32\":1}}],[\"对应的\",{\"1\":{\"41\":1}}],[\"对于对\",{\"1\":{\"6\":1}}],[\"自身的需求实现\",{\"1\":{\"41\":1}}],[\"自动创建主题机制就是如果启用了该机制\",{\"1\":{\"32\":1}}],[\"自动创建readme\",{\"1\":{\"11\":1}}],[\"客户端启动后发出首次心跳\",{\"1\":{\"41\":1}}],[\"客户端\",{\"1\":{\"41\":4}}],[\"客户端从\",{\"1\":{\"31\":1}}],[\"校验消息合法性\",{\"1\":{\"45\":1}}],[\"校验\",{\"1\":{\"43\":1,\"44\":2}}],[\"校验结束\",{\"1\":{\"41\":1}}],[\"校验开始\",{\"1\":{\"41\":1}}],[\"时具体展开\",{\"1\":{\"44\":1}}],[\"时我们自定义的\",{\"1\":{\"41\":1}}],[\"时\",{\"1\":{\"41\":1,\"44\":2}}],[\"时没有自定义\",{\"1\":{\"41\":1}}],[\"进来之后直接先标记为\",{\"1\":{\"41\":1}}],[\"进行\",{\"1\":{\"45\":1}}],[\"进行区分\",{\"1\":{\"45\":1}}],[\"进行路由的过程\",{\"1\":{\"32\":1}}],[\"进行消息的发布和订阅\",{\"1\":{\"31\":1}}],[\"进行管理的\",{\"1\":{\"6\":1}}],[\"肯定会进入\",{\"1\":{\"41\":1}}],[\"起手就是个\",{\"1\":{\"41\":1}}],[\"果然是对\",{\"1\":{\"40\":1}}],[\"他的\",{\"1\":{\"41\":1}}],[\"他的其他方法就不列出来了\",{\"1\":{\"39\":1}}],[\"他里面维护了一个\",{\"1\":{\"41\":1}}],[\"他是\",{\"1\":{\"19\":1}}],[\"做了一层包装\",{\"1\":{\"39\":1}}],[\"数了一下\",{\"1\":{\"39\":1}}],[\"数据库就粗略的分为\",{\"1\":{\"13\":1}}],[\"数据库\",{\"1\":{\"13\":1}}],[\"消息大小的上限\",{\"1\":{\"39\":1}}],[\"消费一次\",{\"1\":{\"32\":1}}],[\"消费\",{\"1\":{\"32\":2}}],[\"消费组的行为并不一致\",{\"1\":{\"32\":1}}],[\"消费组\",{\"1\":{\"32\":1}}],[\"消费组可以订阅多个\",{\"1\":{\"32\":1}}],[\"消费消息是基于消费组\",{\"1\":{\"32\":1}}],[\"消费消息\",{\"1\":{\"32\":1}}],[\"后面的篇幅会进一步省略一些与主线逻辑关系不大的代码片段\",{\"1\":{\"47\":1}}],[\"后面都是异常的处理啥的\",{\"1\":{\"44\":1}}],[\"后面看\",{\"1\":{\"44\":1}}],[\"后面细说\",{\"1\":{\"39\":1}}],[\"后续中展开细说\",{\"1\":{\"32\":1}}],[\"4m\",{\"1\":{\"39\":1}}],[\"4k\",{\"1\":{\"39\":1}}],[\"4\",{\"1\":{\"39\":3}}],[\"4个\",{\"1\":{\"39\":2,\"44\":2}}],[\"404\",{\"1\":{\"6\":1,\"48\":1}}],[\"里就能看到熟悉的\",{\"1\":{\"46\":1}}],[\"里添加一组\",{\"1\":{\"45\":1}}],[\"里完成的\",{\"1\":{\"44\":1}}],[\"里保存了\",{\"1\":{\"44\":1}}],[\"里面提过\",{\"1\":{\"46\":1}}],[\"里面那行校验是一样的是\",{\"1\":{\"44\":1}}],[\"里面塞消息\",{\"1\":{\"34\":1}}],[\"里提过\",{\"1\":{\"39\":1}}],[\"kv\",{\"1\":{\"41\":1,\"45\":1}}],[\"key\",{\"1\":{\"39\":1,\"41\":2,\"45\":1,\"46\":1}}],[\"kinds\",{\"1\":{\"27\":1}}],[\"生产者组\",{\"1\":{\"39\":1}}],[\"属性默认是\",{\"1\":{\"41\":1}}],[\"属性\",{\"1\":{\"39\":1,\"46\":1}}],[\"于是我们来看\",{\"1\":{\"38\":1}}],[\"于是打算放弃\",{\"1\":{\"12\":1}}],[\"接下来我们来看看\",{\"1\":{\"46\":1}}],[\"接下来我们来看\",{\"1\":{\"42\":1}}],[\"接下来进入\",{\"1\":{\"37\":1}}],[\"接口进一步扩展出了延迟任务和周期任务的执行\",{\"1\":{\"26\":1}}],[\"接口\",{\"1\":{\"26\":1}}],[\"确实非常简单对吧\",{\"1\":{\"37\":1}}],[\"关闭\",{\"1\":{\"37\":1}}],[\"关缓存\",{\"1\":{\"4\":1}}],[\"构造方法\",{\"1\":{\"39\":1,\"46\":1}}],[\"构造消息\",{\"1\":{\"37\":1}}],[\"构建项目并输出\",{\"1\":{\"9\":1}}],[\"<\",{\"1\":{\"37\":1,\"44\":2,\"46\":2}}],[\"启动定时任务\",{\"1\":{\"41\":1}}],[\"启动失败\",{\"1\":{\"41\":1}}],[\"启动\",{\"1\":{\"37\":1}}],[\"启动开发服务器\",{\"1\":{\"9\":1}}],[\"==\",{\"1\":{\"44\":2,\"46\":1}}],[\"=\",{\"1\":{\"37\":4,\"39\":13,\"40\":1,\"41\":5,\"44\":37,\"45\":6,\"46\":27}}],[\"逻辑很简单\",{\"1\":{\"37\":1}}],[\"整个过程以描述+代码注释的方式进行\",{\"1\":{\"36\":1}}],[\"整理完再说\",{\"1\":{\"13\":1}}],[\"收发消息已经全部成功\",{\"1\":{\"35\":1}}],[\"收到消息后\",{\"1\":{\"32\":1}}],[\"queue\",{\"0\":{\"55\":1},\"1\":{\"44\":2}}],[\"queueid\",{\"1\":{\"44\":1}}],[\"queues\",{\"0\":{\"25\":1},\"1\":{\"20\":1}}],[\"quick\",{\"1\":{\"35\":1,\"44\":1}}],[\"区别很简单不再赘述\",{\"1\":{\"34\":1}}],[\"单向发送不需要返回结果\",{\"1\":{\"44\":1}}],[\"单向自然就是一次\",{\"1\":{\"44\":1}}],[\"单向由该参数决定\",{\"1\":{\"44\":1}}],[\"单向则不关心结果\",{\"1\":{\"37\":1}}],[\"单向\",{\"1\":{\"34\":1,\"44\":1}}],[\"单独发布到子域名下\",{\"1\":{\"1\":1}}],[\"管理\",{\"1\":{\"34\":1}}],[\"找到\",{\"1\":{\"34\":1}}],[\"找插件\",{\"1\":{\"7\":1}}],[\"要先去\",{\"1\":{\"34\":1}}],[\"要添加到源码库的\",{\"1\":{\"5\":1}}],[\"推模式\",{\"1\":{\"32\":1}}],[\"推送消息\",{\"1\":{\"32\":1}}],[\"推送\",{\"1\":{\"31\":1}}],[\"视为不同个体\",{\"1\":{\"32\":1}}],[\"视为一个集群\",{\"1\":{\"32\":1}}],[\"下面就是创建\",{\"1\":{\"46\":1}}],[\"下面是发送流程\",{\"1\":{\"44\":1}}],[\"下面贴了一段简单的发送消息的代码\",{\"1\":{\"37\":1}}],[\"下文以同步为例进行分析\",{\"1\":{\"34\":1}}],[\"下一节将从发送消息入手进行源码分析\",{\"1\":{\"33\":1}}],[\"下的同一条消息只能被其中一个\",{\"1\":{\"32\":1}}],[\"下没有手动创建readme\",{\"1\":{\"11\":1}}],[\"广播模式则是把消费组内的\",{\"1\":{\"32\":1}}],[\"广播模式\",{\"1\":{\"32\":1}}],[\"集群模式就是把消费组内的所有\",{\"1\":{\"32\":1}}],[\"集群模式\",{\"1\":{\"32\":1}}],[\"集合更一部分\",{\"1\":{\"13\":1}}],[\"提供了两种消费模式\",{\"1\":{\"32\":1}}],[\"提供了基于不同时间粒度的操作方法\",{\"1\":{\"24\":1}}],[\"由\",{\"1\":{\"32\":1}}],[\"由于完全不懂\",{\"1\":{\"4\":1}}],[\"开展的\",{\"1\":{\"32\":1}}],[\"开头的都是官方维护的插件\",{\"1\":{\"7\":1}}],[\"当你写错\",{\"1\":{\"32\":1}}],[\"换句话说就是一条消息只能被集群\",{\"1\":{\"32\":1}}],[\"换句话说\",{\"1\":{\"32\":1}}],[\"难道是淘宝网102\",{\"1\":{\"32\":1}}],[\"名字挺奇怪的叫\",{\"1\":{\"32\":1}}],[\"抛出路由信息错误\",{\"1\":{\"32\":1}}],[\"假设没有开启自动创建主题机制\",{\"1\":{\"32\":1}}],[\"假设一主多从\",{\"1\":{\"18\":1}}],[\"查到了就按具体情况选好\",{\"1\":{\"32\":1}}],[\"查询\",{\"1\":{\"32\":1}}],[\"去\",{\"1\":{\"32\":1}}],[\"拉模式\",{\"1\":{\"32\":1}}],[\"拉一次\",{\"1\":{\"32\":1}}],[\"拉取消息以及消息持久化\",{\"1\":{\"31\":1}}],[\"会为\",{\"1\":{\"44\":1}}],[\"会默认你的\",{\"1\":{\"41\":1}}],[\"会自动创建一个\",{\"1\":{\"32\":1}}],[\"会自动生成一个目录页面\",{\"1\":{\"11\":1}}],[\"会从\",{\"1\":{\"32\":1}}],[\"3000\",{\"1\":{\"39\":1}}],[\"30s\",{\"1\":{\"32\":1}}],[\"343f3e\",{\"1\":{\"10\":1}}],[\"每\",{\"1\":{\"32\":1}}],[\"流动到\",{\"1\":{\"32\":1}}],[\"向\",{\"1\":{\"32\":1}}],[\"大致流程\",{\"0\":{\"32\":1}}],[\"大体可以分为以下几个部分\",{\"1\":{\"19\":1}}],[\"上拉数据\",{\"1\":{\"46\":1}}],[\"上同步路由信息\",{\"1\":{\"31\":1}}],[\"上数据变化会写入二进制文件\",{\"1\":{\"15\":1}}],[\"则直接返回\",{\"1\":{\"46\":1}}],[\"则是定期上报各种路由信息给\",{\"1\":{\"31\":1}}],[\"则生成\",{\"1\":{\"11\":1}}],[\"允许分钟级的数据不一致\",{\"1\":{\"31\":1}}],[\"之前\",{\"1\":{\"46\":2}}],[\"之间传递消息有两种方式\",{\"1\":{\"32\":2}}],[\"之间不进行通信\",{\"1\":{\"31\":1}}],[\"之后\",{\"1\":{\"46\":1}}],[\"之后累加计算所有\",{\"1\":{\"45\":1}}],[\"之后的\",{\"1\":{\"45\":1}}],[\"之后批量\",{\"1\":{\"45\":1}}],[\"之后一秒执行一次\",{\"1\":{\"41\":1}}],[\"之后消费环节的\",{\"1\":{\"41\":1}}],[\"之后代码运行到这里就抛异常了\",{\"1\":{\"41\":1}}],[\"之后以同步\",{\"1\":{\"31\":1}}],[\"之后直接开始强制同步到从库\",{\"1\":{\"17\":1}}],[\"各个\",{\"1\":{\"31\":1}}],[\"各种模式等等细节后续章节展开\",{\"1\":{\"32\":1}}],[\"各种\",{\"1\":{\"19\":1}}],[\"服务发现\",{\"1\":{\"31\":1}}],[\"服务注册\",{\"1\":{\"13\":1}}],[\"注意跟后面的\",{\"1\":{\"45\":1}}],[\"注意这里说的客户端\",{\"1\":{\"41\":1}}],[\"注册到\",{\"1\":{\"41\":1}}],[\"注册到其内部维护的\",{\"1\":{\"41\":1}}],[\"注册中心\",{\"1\":{\"31\":1}}],[\"注解\",{\"1\":{\"13\":1}}],[\"像是\",{\"1\":{\"31\":1}}],[\"组成\",{\"1\":{\"31\":1,\"32\":1}}],[\"发消息时的整个路由流程\",{\"1\":{\"44\":1}}],[\"发布消息\",{\"1\":{\"32\":1}}],[\"发送次数\",{\"1\":{\"44\":1}}],[\"发送首次心跳请求\",{\"1\":{\"41\":1}}],[\"发送拉取消息的请求\",{\"1\":{\"32\":1}}],[\"发送消息背后的整体逻辑和流程\",{\"1\":{\"47\":1}}],[\"发送消息这里还有一个可以看一下\",{\"1\":{\"44\":1}}],[\"发送消息支持三种模式\",{\"1\":{\"44\":1}}],[\"发送消息支持三种方式\",{\"1\":{\"34\":1}}],[\"发送消息并拿到返回结果\",{\"1\":{\"44\":1}}],[\"发送消息失败会重试两次\",{\"1\":{\"39\":1}}],[\"发送消息的各种细节\",{\"1\":{\"34\":1}}],[\"发送消息\",{\"0\":{\"34\":1},\"1\":{\"32\":2,\"37\":1}}],[\"发送\",{\"1\":{\"30\":1}}],[\"发现\",{\"1\":{\"13\":1}}],[\"高可用\",{\"1\":{\"30\":1}}],[\"高吞吐量\",{\"1\":{\"30\":1}}],[\"什么是\",{\"0\":{\"30\":1}}],[\"源码注释里写了\",{\"1\":{\"39\":1}}],[\"源码中这部分是有注释的\",{\"1\":{\"39\":1}}],[\"源码分析\",{\"0\":{\"29\":1,\"34\":1,\"36\":1}}],[\"源码库\",{\"1\":{\"5\":1}}],[\"具体细节下面展开说\",{\"1\":{\"45\":1}}],[\"具体实现\",{\"0\":{\"27\":1}}],[\"具体的key值\",{\"1\":{\"45\":1}}],[\"具体的\",{\"1\":{\"26\":1}}],[\"通过对源码进行跟踪来了解\",{\"1\":{\"47\":1}}],[\"通过\",{\"1\":{\"45\":1}}],[\"通过代码可以看出batch\",{\"1\":{\"45\":1}}],[\"通过提供线程状态方法\",{\"1\":{\"26\":1}}],[\"通过导航跳转\",{\"1\":{\"1\":1}}],[\"顺序执行\",{\"1\":{\"26\":1}}],[\"顺便加入一些操作系统的知识点\",{\"1\":{\"13\":1}}],[\"顺便加一篇前置内容\",{\"1\":{\"13\":1}}],[\"方法的调用\",{\"1\":{\"46\":1}}],[\"方法的逻辑就是把所有\",{\"1\":{\"45\":1}}],[\"方法的逻辑是\",{\"1\":{\"41\":1}}],[\"方法继续往下看\",{\"1\":{\"46\":1}}],[\"方法就是\",{\"1\":{\"44\":1}}],[\"方法就是把刚创建的这个\",{\"1\":{\"41\":1}}],[\"方法\",{\"1\":{\"26\":1,\"37\":1,\"44\":2,\"46\":2}}],[\"方法论\",{\"1\":{\"13\":1}}],[\"或者索引的方式检索消息等等\",{\"1\":{\"31\":1}}],[\"或者\",{\"1\":{\"31\":1,\"41\":1}}],[\"或者是\",{\"1\":{\"26\":1}}],[\"或者是一个正在执行中的\",{\"1\":{\"26\":1}}],[\"或者直接换\",{\"1\":{\"6\":1}}],[\"轻量级任务框架这类型的线程类子系统\",{\"1\":{\"26\":1}}],[\"异步发送时用的\",{\"1\":{\"46\":1}}],[\"异步获取结果是利用\",{\"1\":{\"44\":1}}],[\"异步其实是可以重试的\",{\"1\":{\"44\":1}}],[\"异步消息失败的重试机制可能会造成消息重复发送\",{\"1\":{\"39\":1}}],[\"异步则是通过\",{\"1\":{\"37\":1}}],[\"异步的方式刷盘写入\",{\"1\":{\"31\":1}}],[\"异步\",{\"1\":{\"26\":1,\"34\":1,\"44\":2,\"46\":1}}],[\"异步io\",{\"1\":{\"26\":1}}],[\"异常\",{\"1\":{\"13\":1}}],[\"详情看文档\",{\"1\":{\"25\":1}}],[\"详见文档\",{\"1\":{\"21\":1}}],[\"非批量发送也有这一步\",{\"1\":{\"45\":2}}],[\"非同步模式就是单向和异步\",{\"1\":{\"44\":1}}],[\"非同步模式为1次\",{\"1\":{\"44\":1}}],[\"非阻塞的各种线程安全队列\",{\"1\":{\"25\":1}}],[\"非常少见\",{\"1\":{\"17\":1}}],[\"啥的有兴趣自己去看\",{\"1\":{\"45\":1}}],[\"啥的\",{\"1\":{\"24\":1}}],[\"workqueue\",{\"1\":{\"46\":3}}],[\"world\",{\"1\":{\"37\":1}}],[\"writeandflush\",{\"1\":{\"44\":1,\"46\":1}}],[\"writequeue\",{\"1\":{\"39\":1,\"44\":1}}],[\"withoutnamespace\",{\"1\":{\"46\":1}}],[\"with\",{\"1\":{\"44\":1}}],[\"withnamespace\",{\"1\":{\"40\":1,\"43\":1,\"44\":1,\"45\":2}}],[\"was\",{\"1\":{\"46\":1}}],[\"warn\",{\"1\":{\"40\":1,\"44\":10}}],[\"wait\",{\"1\":{\"24\":1}}],[\"well\",{\"1\":{\"27\":1}}],[\"whale\",{\"1\":{\"7\":1}}],[\"所以初始化为0\",{\"1\":{\"45\":1}}],[\"所以我们的\",{\"1\":{\"41\":1}}],[\"所以阅读这部分源码or文档时需要注意\",{\"1\":{\"22\":1}}],[\"所有错误\",{\"1\":{\"32\":1}}],[\"所有的主从逻辑基本上都是把数据从主服务器同步到从服务器\",{\"1\":{\"15\":1}}],[\"可控数量线程并发写入\",{\"1\":{\"22\":1}}],[\"可以自己看一下\",{\"1\":{\"44\":1}}],[\"可以自己观察一下\",{\"1\":{\"39\":1}}],[\"可以先自己过一遍源码\",{\"1\":{\"39\":1}}],[\"可以通过\",{\"1\":{\"26\":1}}],[\"可以看到我们直接\",{\"1\":{\"44\":1}}],[\"可以看出来\",{\"1\":{\"39\":1}}],[\"可以看成是同步版本的hashmap\",{\"1\":{\"22\":1}}],[\"可以看作是工具包\",{\"1\":{\"19\":1}}],[\"可以直接开启开发者模式禁用缓存\",{\"1\":{\"4\":1}}],[\"而单向跟同步一个逻辑\",{\"1\":{\"44\":1}}],[\"而无论是\",{\"1\":{\"41\":1}}],[\"而实际上呢\",{\"1\":{\"34\":1}}],[\"而并发集合类\",{\"1\":{\"22\":1}}],[\"而执行机制\",{\"1\":{\"19\":1}}],[\"只贴\",{\"1\":{\"46\":1}}],[\"只不过返回值被无视了\",{\"1\":{\"44\":1}}],[\"只对应一个\",{\"1\":{\"41\":1}}],[\"只要\",{\"1\":{\"41\":1}}],[\"只要收到任意一个从库\",{\"1\":{\"18\":1}}],[\"只看这一个就行\",{\"1\":{\"39\":1}}],[\"只有一个方法\",{\"1\":{\"26\":1}}],[\"只是通过排它锁\",{\"1\":{\"22\":1}}],[\"因为这里\",{\"1\":{\"22\":1}}],[\"访问\",{\"1\":{\"22\":1}}],[\"偏序关系的介绍\",{\"1\":{\"21\":1}}],[\"请重新阅读之前关于\",{\"1\":{\"21\":1}}],[\"不过还是老样子\",{\"1\":{\"46\":1}}],[\"不满足批量发送条件会直接抛异常\",{\"1\":{\"45\":1}}],[\"不同模式下返回结果的处理\",{\"1\":{\"44\":1}}],[\"不存在则创建后返回\",{\"1\":{\"41\":1}}],[\"不存在的\",{\"1\":{\"32\":1}}],[\"不等于\",{\"1\":{\"41\":1}}],[\"不符合要求就抛个异常提醒用户修改\",{\"1\":{\"41\":1}}],[\"不理解\",{\"1\":{\"21\":1}}],[\"不知道具体版本可以直接\",{\"1\":{\"4\":1}}],[\"删除这个元素\",{\"1\":{\"21\":1}}],[\"原则和一些例子\",{\"1\":{\"21\":1}}],[\"原子类\",{\"1\":{\"19\":1}}],[\"为\",{\"1\":{\"41\":2}}],[\"为了满足不同使用场景\",{\"1\":{\"32\":1}}],[\"为并发编程提供的标准化可扩展的框架\",{\"1\":{\"20\":1}}],[\"为主线\",{\"1\":{\"47\":1}}],[\"为主\",{\"1\":{\"13\":1}}],[\"是源码里的\",{\"1\":{\"45\":1}}],[\"是不是超过4m最大小限制等等\",{\"1\":{\"44\":1}}],[\"是不是为空啊\",{\"1\":{\"44\":1}}],[\"是不是\",{\"1\":{\"44\":1}}],[\"是不是默认的\",{\"1\":{\"41\":1}}],[\"是个啥\",{\"1\":{\"41\":1}}],[\"是个非常简单的标准化接口\",{\"1\":{\"26\":1}}],[\"是否存在\",{\"1\":{\"41\":1}}],[\"是否切换另外的\",{\"1\":{\"39\":1}}],[\"是否接收返回信息以及用什么方式处理返回信息取决于采取的是哪种发送方式\",{\"1\":{\"32\":1}}],[\"是啥\",{\"1\":{\"38\":1}}],[\"是由哪个\",{\"1\":{\"34\":1}}],[\"是从\",{\"1\":{\"32\":1}}],[\"是向\",{\"1\":{\"32\":1}}],[\"是一个基于主题的发布与订阅模式的消息队列中间价\",{\"1\":{\"30\":1}}],[\"是并发的\",{\"1\":{\"22\":1}}],[\"是同步的\",{\"1\":{\"22\":1}}],[\"是\",{\"1\":{\"20\":1,\"38\":1}}],[\"文章最后稍微再补充一些关于\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"32\":1}}],[\"文件方便以\",{\"1\":{\"31\":1}}],[\"文件绑定\",{\"1\":{\"6\":1}}],[\"文档中这部分实际上就是介绍了一下\",{\"1\":{\"21\":1}}],[\"文档翻译\",{\"0\":{\"20\":1}}],[\"类提供的各种具体实现\",{\"1\":{\"46\":1}}],[\"类加载的\",{\"1\":{\"45\":1}}],[\"类\",{\"1\":{\"24\":1}}],[\"类的工厂和工具方法的合集\",{\"1\":{\"19\":1}}],[\"类型\",{\"1\":{\"13\":1}}],[\"它可以是生产者也可以是消费者\",{\"1\":{\"41\":1}}],[\"它可以用来定义线程池\",{\"1\":{\"26\":1}}],[\"它通过继承\",{\"1\":{\"26\":1}}],[\"它的含义不仅仅是线程安全\",{\"1\":{\"22\":1}}],[\"它的基本逻辑是从线程池里获取线程\",{\"1\":{\"19\":1}}],[\"它自动生成一个标题为\",{\"1\":{\"11\":1}}],[\"交给\",{\"1\":{\"19\":1}}],[\"也在这里完成真正的初始化\",{\"1\":{\"44\":1}}],[\"也是\",{\"1\":{\"41\":1}}],[\"也是提醒你要自定义\",{\"1\":{\"41\":1}}],[\"也就是内存\",{\"1\":{\"45\":1}}],[\"也就是不止一次\",{\"1\":{\"44\":1}}],[\"也就是发送消息的流程\",{\"1\":{\"42\":1}}],[\"也就是前面说的\",{\"1\":{\"41\":1}}],[\"也就是提供了哪些方法\",{\"1\":{\"39\":1}}],[\"也就是\",{\"1\":{\"32\":1,\"44\":1,\"45\":1}}],[\"也就是具体如何执行\",{\"1\":{\"19\":1}}],[\"也一样\",{\"1\":{\"15\":1}}],[\"任务的提交关闭调用等方法\",{\"1\":{\"26\":1}}],[\"任务就是执行内容\",{\"1\":{\"19\":1}}],[\"任务\",{\"1\":{\"19\":1}}],[\"厨房\",{\"1\":{\"19\":1}}],[\"赛车\",{\"1\":{\"19\":1}}],[\"等等\",{\"1\":{\"19\":1}}],[\"等\",{\"1\":{\"19\":1}}],[\"等同于\",{\"1\":{\"6\":1}}],[\"实例\",{\"1\":{\"41\":1}}],[\"实际就是检查\",{\"1\":{\"41\":1}}],[\"实际启动的是\",{\"1\":{\"40\":1}}],[\"实际上就是创建了一个自定义的\",{\"1\":{\"41\":1}}],[\"实际上这个推模式也是在拉模式的基础上做的实现\",{\"1\":{\"32\":1}}],[\"实际上默认为以下三个包的统称\",{\"1\":{\"19\":1}}],[\"实现可以是正在创建\",{\"1\":{\"26\":1}}],[\"实践\",{\"1\":{\"13\":1}}],[\"平时说\",{\"1\":{\"19\":1}}],[\"包内的例子来理解上面的定义\",{\"1\":{\"26\":1}}],[\"包中的很多类都带有\",{\"1\":{\"22\":1}}],[\"包中如何实践\",{\"1\":{\"21\":1}}],[\"包\",{\"1\":{\"20\":1}}],[\"包含\",{\"1\":{\"19\":1}}],[\"包简介\",{\"0\":{\"19\":1}}],[\"包括消息的生产者和消费者\",{\"1\":{\"31\":1}}],[\"包括介绍\",{\"1\":{\"13\":1}}],[\"包括\",{\"1\":{\"2\":1}}],[\"返回的是\",{\"1\":{\"41\":2}}],[\"返回的确认消息就认为本次写操作成功\",{\"1\":{\"18\":1}}],[\"返回给客户端\",{\"1\":{\"18\":1}}],[\"半同步跟全同步的区别是\",{\"1\":{\"18\":1}}],[\"半同步模式\",{\"0\":{\"18\":1}}],[\"性能较差\",{\"1\":{\"17\":1}}],[\"全同步模式\",{\"0\":{\"17\":1}}],[\"同理\",{\"1\":{\"41\":1}}],[\"同一个\",{\"1\":{\"32\":1}}],[\"同时还有一个线程不断从\",{\"1\":{\"32\":1}}],[\"同时还保证线程安全\",{\"1\":{\"22\":1}}],[\"同时附带了一堆时间转换的方法以及时间单位的定义\",{\"1\":{\"24\":1}}],[\"同时使用前注意插件支持哪个\",{\"1\":{\"7\":1}}],[\"同步发送消息\",{\"1\":{\"46\":1}}],[\"同步和异步的区别主要是入参的不同以及异步需要\",{\"1\":{\"44\":1}}],[\"同步\",{\"1\":{\"34\":1,\"44\":2}}],[\"同步版本的\",{\"1\":{\"22\":1}}],[\"同步辅助类\",{\"1\":{\"19\":1}}],[\"同步模式下\",{\"1\":{\"44\":1}}],[\"同步模式\",{\"0\":{\"16\":1}}],[\"语句\",{\"1\":{\"15\":1}}],[\"语言\",{\"1\":{\"13\":1}}],[\"并开启定时任务这个流程\",{\"1\":{\"41\":1}}],[\"并执行\",{\"1\":{\"41\":1}}],[\"并尝试发送和消费消息\",{\"1\":{\"33\":1}}],[\"并在本地进行缓存\",{\"1\":{\"31\":1}}],[\"并且初始化其对应的\",{\"1\":{\"41\":1}}],[\"并且初始化该\",{\"1\":{\"41\":1}}],[\"并且异步转发给\",{\"1\":{\"31\":1}}],[\"并且复制接收\",{\"1\":{\"31\":1}}],[\"并发\",{\"1\":{\"22\":1}}],[\"并发集合\",{\"1\":{\"19\":1}}],[\"并发集合类\",{\"1\":{\"13\":1,\"22\":1}}],[\"并写入从库的中继日志中\",{\"1\":{\"15\":1}}],[\"负责读取中继日志并重放其中的\",{\"1\":{\"15\":1}}],[\"负责从主服务器上读取\",{\"1\":{\"15\":1}}],[\"负责将主库上的数据更改写入\",{\"1\":{\"15\":1}}],[\"负载均衡\",{\"1\":{\"13\":1}}],[\"override\",{\"1\":{\"46\":1}}],[\"ok\",{\"1\":{\"41\":3,\"44\":2,\"46\":2}}],[\"out\",{\"1\":{\"37\":1}}],[\"one\",{\"1\":{\"45\":1}}],[\"oneway\",{\"1\":{\"44\":1,\"46\":1}}],[\"once\",{\"1\":{\"41\":1,\"44\":3}}],[\"on\",{\"1\":{\"27\":1}}],[\"other\",{\"1\":{\"27\":1}}],[\"of\",{\"1\":{\"27\":4,\"44\":1}}],[\"origin\",{\"1\":{\"46\":1}}],[\"orderid188\",{\"1\":{\"37\":1}}],[\"oracle\",{\"1\":{\"28\":1}}],[\"or\",{\"1\":{\"21\":1,\"22\":1,\"26\":1}}],[\"o\",{\"1\":{\"15\":2}}],[\"openssl\",{\"1\":{\"6\":2}}],[\"options=\",{\"1\":{\"6\":2}}],[\"线程安全\",{\"1\":{\"22\":1}}],[\"线程从并发集合类中访问\",{\"1\":{\"21\":1}}],[\"线程必须事先将元素放入并发集合类中这个动作\",{\"1\":{\"21\":1}}],[\"线程的设计把执行机制和执行内容分开\",{\"1\":{\"19\":1}}],[\"线程任务的执行\",{\"1\":{\"19\":1}}],[\"线程执行和管理\",{\"1\":{\"19\":1}}],[\"线程和\",{\"1\":{\"15\":1}}],[\"线程\",{\"1\":{\"15\":5}}],[\"线程池版executor\",{\"1\":{\"19\":1}}],[\"线程池\",{\"1\":{\"13\":1}}],[\"未分类\",{\"1\":{\"13\":1}}],[\"算法\",{\"1\":{\"13\":1}}],[\"从\",{\"1\":{\"46\":1}}],[\"从本地路由信息表里\",{\"1\":{\"46\":1}}],[\"从前面的代码中我们可以发现\",{\"1\":{\"44\":1}}],[\"从这里我们就可以看出\",{\"1\":{\"41\":1}}],[\"从发送消息开始\",{\"0\":{\"37\":1}}],[\"从使用者的角度\",{\"1\":{\"34\":1}}],[\"从使用者的角度去看\",{\"1\":{\"32\":1}}],[\"从数据流动角度看\",{\"1\":{\"32\":1}}],[\"从开发工具到\",{\"1\":{\"13\":1}}],[\"从颜色调整到布局设置啥的很全\",{\"1\":{\"10\":1}}],[\"监控\",{\"1\":{\"13\":1}}],[\"网关\",{\"1\":{\"13\":1}}],[\"网络的内容也考虑放这里\",{\"1\":{\"13\":1}}],[\"微服务\",{\"1\":{\"13\":1}}],[\"然后把\",{\"1\":{\"45\":1}}],[\"然后存放到msgbatch\",{\"1\":{\"45\":1}}],[\"然后启动该客户端\",{\"1\":{\"41\":1}}],[\"然后我们来看代码\",{\"1\":{\"41\":1}}],[\"然后开始检查配置\",{\"1\":{\"41\":1}}],[\"然后再去看他的功能\",{\"1\":{\"39\":1}}],[\"然后发送消息\",{\"1\":{\"37\":1}}],[\"然后才能确定\",{\"1\":{\"34\":1}}],[\"然后根据路由信息找到对应的\",{\"1\":{\"31\":1}}],[\"然后执行\",{\"1\":{\"19\":1,\"44\":1}}],[\"然后从库从中继日志中读取并执行其中的\",{\"1\":{\"15\":1}}],[\"然后通过io把\",{\"1\":{\"15\":1}}],[\"然后是\",{\"1\":{\"13\":1}}],[\"然后编辑\",{\"1\":{\"6\":1}}],[\"目前还不知道所有\",{\"1\":{\"45\":1}}],[\"目前消息队列是单独更新\",{\"1\":{\"13\":1}}],[\"目的是为了区分不同的\",{\"1\":{\"41\":1}}],[\"目录下没有readme\",{\"1\":{\"11\":1}}],[\"目录下的三个文件进行自定义\",{\"1\":{\"10\":1}}],[\"目录下必须有\",{\"1\":{\"6\":1}}],[\"目录有约定\",{\"1\":{\"6\":1}}],[\"你既可以把它看成数据库也可以用作缓存\",{\"1\":{\"13\":1}}],[\"你可以在另外一个端口额外启动一个当说明书看\",{\"1\":{\"8\":1}}],[\"前面说过\",{\"1\":{\"44\":1}}],[\"前面说了\",{\"1\":{\"41\":1}}],[\"前面看\",{\"1\":{\"44\":1}}],[\"前面\",{\"1\":{\"39\":1}}],[\"前面在简介里面说了\",{\"1\":{\"34\":1}}],[\"前面二者的加强版\",{\"1\":{\"19\":1}}],[\"前置要求\",{\"0\":{\"33\":1,\"35\":1}}],[\"前缀\",{\"1\":{\"22\":1}}],[\"前期主要更新\",{\"1\":{\"13\":1}}],[\"前后重新发布了\",{\"1\":{\"4\":1}}],[\"两类\",{\"1\":{\"13\":1}}],[\"调试工具\",{\"1\":{\"13\":1}}],[\"generatefromlist\",{\"1\":{\"45\":2}}],[\"getmqclientapiimpl\",{\"1\":{\"46\":3}}],[\"getnamespace\",{\"1\":{\"46\":1}}],[\"getnamesrvaddr\",{\"1\":{\"40\":1}}],[\"get\",{\"1\":{\"46\":3}}],[\"getruntime\",{\"1\":{\"46\":2}}],[\"getresponsecode\",{\"1\":{\"44\":2}}],[\"getretrytimeswhensendasyncfailed\",{\"1\":{\"46\":1}}],[\"getretrytimeswhensendfailed\",{\"1\":{\"44\":1}}],[\"getretryresponsecodes\",{\"1\":{\"44\":1}}],[\"getproperty\",{\"1\":{\"46\":1}}],[\"getproducergroup\",{\"1\":{\"41\":4}}],[\"getsendstatus\",{\"1\":{\"44\":1}}],[\"getsendmsgtimeout\",{\"1\":{\"44\":1}}],[\"getbrokername\",{\"1\":{\"44\":7,\"46\":2}}],[\"getbytes\",{\"1\":{\"37\":1}}],[\"gettopic\",{\"1\":{\"43\":1,\"44\":4,\"45\":2,\"46\":1}}],[\"getcreatetopickey\",{\"1\":{\"41\":1}}],[\"getorcreatemqclientinstance\",{\"1\":{\"41\":3}}],[\"getinstance\",{\"1\":{\"41\":2}}],[\"getaccesschannel\",{\"1\":{\"40\":1}}],[\"grouptable\",{\"1\":{\"41\":1}}],[\"group\",{\"1\":{\"41\":5}}],[\"groups\",{\"1\":{\"27\":1}}],[\"gc\",{\"1\":{\"13\":1}}],[\"github\",{\"1\":{\"4\":4,\"46\":1}}],[\"模型\",{\"1\":{\"13\":1}}],[\"部分\",{\"1\":{\"13\":1}}],[\"部署库的方式自动部署的几个需要注意的地方\",{\"1\":{\"5\":1}}],[\"部署\",{\"0\":{\"5\":1}}],[\"系列放入微服务部分更新\",{\"1\":{\"13\":1}}],[\"这段\",{\"1\":{\"46\":1}}],[\"这段判定的作用跟上面的\",{\"1\":{\"41\":1}}],[\"这俩也是一套\",{\"1\":{\"46\":1}}],[\"这两种角色都看作客户端\",{\"1\":{\"41\":1}}],[\"这是发送异步消息失败也是重试两次\",{\"1\":{\"39\":1}}],[\"这是个\",{\"1\":{\"37\":1}}],[\"这就是自动创建主题机制的那个\",{\"1\":{\"39\":1}}],[\"这里就是前面说的\",{\"1\":{\"46\":1}}],[\"这里就假设读者已经顺利完成了\",{\"1\":{\"35\":1}}],[\"这里是我们要看的同步\",{\"1\":{\"44\":1}}],[\"这里是以同步的方式拿到返回结果\",{\"1\":{\"37\":1}}],[\"这里还是先不展开说明\",{\"1\":{\"44\":1}}],[\"这里\",{\"1\":{\"41\":1,\"45\":2}}],[\"这里为了满足并发的需要用的是\",{\"1\":{\"41\":1}}],[\"这里简单说一下\",{\"1\":{\"41\":1}}],[\"这里要做的事情就是\",{\"1\":{\"41\":1}}],[\"这里我们直接去看\",{\"1\":{\"39\":1}}],[\"这里也先提一下\",{\"1\":{\"39\":1}}],[\"这里开始详细聊聊\",{\"1\":{\"34\":1}}],[\"这里发布一些杂七杂八\",{\"1\":{\"0\":1}}],[\"这部分提供了阻塞\",{\"1\":{\"25\":1}}],[\"这部分还没想好\",{\"1\":{\"13\":1}}],[\"这个可就太长了\",{\"1\":{\"46\":1}}],[\"这个展开也超长\",{\"1\":{\"46\":1}}],[\"这个方法\",{\"1\":{\"46\":1}}],[\"这个方法是线程安全的\",{\"1\":{\"46\":1}}],[\"这个方法这里不过多展开了\",{\"1\":{\"44\":1}}],[\"这个循环\",{\"1\":{\"45\":1}}],[\"这个空的\",{\"1\":{\"44\":1}}],[\"这个定时任务是扫描并移除\",{\"1\":{\"41\":1}}],[\"这个变量名\",{\"1\":{\"41\":1,\"44\":1}}],[\"这个默认值是走\",{\"1\":{\"41\":1}}],[\"这个先无视\",{\"1\":{\"39\":1}}],[\"这个是消息发送失败时\",{\"1\":{\"39\":1}}],[\"这个是压缩消息的阈值\",{\"1\":{\"39\":1}}],[\"这个是线程之间交换变量值的\",{\"1\":{\"19\":1}}],[\"这个概念后面细说\",{\"1\":{\"39\":1}}],[\"这个\",{\"1\":{\"32\":1,\"41\":1,\"45\":1}}],[\"这个框架\",{\"1\":{\"13\":1}}],[\"这些简单介绍下\",{\"1\":{\"13\":1}}],[\"把消息写入\",{\"1\":{\"32\":1}}],[\"把\",{\"1\":{\"13\":1,\"41\":2}}],[\"工具类\",{\"1\":{\"13\":1,\"19\":1}}],[\"反射\",{\"1\":{\"13\":1}}],[\"反正不懂\",{\"1\":{\"6\":1}}],[\"泛型\",{\"1\":{\"13\":1}}],[\"框架部分则只更新\",{\"1\":{\"13\":1}}],[\"基本架构\",{\"0\":{\"31\":1}}],[\"基本围绕着\",{\"1\":{\"10\":1}}],[\"基础上进行扩展\",{\"1\":{\"26\":1}}],[\"基础逻辑\",{\"0\":{\"15\":1}}],[\"基础\",{\"1\":{\"13\":1}}],[\"基础部分只更新重要的基础知识点\",{\"1\":{\"13\":1}}],[\"以异步任务执行框架为例\",{\"1\":{\"26\":1}}],[\"以阻塞同步的方式来保证了线程安全\",{\"1\":{\"22\":1}}],[\"以及对应的路由信息\",{\"1\":{\"32\":1}}],[\"以及\",{\"1\":{\"21\":1}}],[\"以及基于\",{\"1\":{\"19\":1}}],[\"以及主题\",{\"1\":{\"2\":1}}],[\"以\",{\"1\":{\"13\":1}}],[\"知识库内容\",{\"0\":{\"13\":1}}],[\"打算趁着切换\",{\"1\":{\"12\":1}}],[\"最终你应该能找到对\",{\"1\":{\"46\":1}}],[\"最终需要多大的\",{\"1\":{\"45\":1}}],[\"最终具体实现都是\",{\"1\":{\"44\":1}}],[\"最终可以看出\",{\"1\":{\"41\":1}}],[\"最多3次\",{\"1\":{\"44\":1}}],[\"最后\",{\"1\":{\"32\":1}}],[\"最后通过手动添加依赖解决了\",{\"1\":{\"4\":1}}],[\"最近在整理积攒下的笔记和草稿\",{\"1\":{\"12\":1}}],[\"投奔\",{\"1\":{\"12\":1}}],[\"just\",{\"1\":{\"41\":4,\"46\":1}}],[\"juc\",{\"0\":{\"52\":1},\"1\":{\"13\":2,\"19\":1,\"21\":1,\"26\":1}}],[\"join\",{\"1\":{\"24\":1}}],[\"jvm\",{\"1\":{\"13\":2}}],[\"java8\",{\"1\":{\"28\":1}}],[\"java\",{\"0\":{\"19\":1,\"53\":1},\"1\":{\"13\":4,\"19\":3,\"20\":2}}],[\"jekyll\",{\"1\":{\"12\":1}}],[\"js中添加插件并配置\",{\"1\":{\"7\":1}}],[\"json\",{\"1\":{\"6\":2}}],[\"js\",{\"1\":{\"4\":2}}],[\"近几年技术文章写的越来越多\",{\"1\":{\"12\":1}}],[\"指南\",{\"0\":{\"12\":1}}],[\"该页面标题就是目录本身\",{\"1\":{\"11\":1}}],[\"功能\",{\"0\":{\"11\":1}}],[\"隐藏打印按钮\",{\"1\":{\"10\":1}}],[\"样式配置部分\",{\"1\":{\"10\":1}}],[\"样式相关\",{\"0\":{\"10\":1}}],[\"$bg\",{\"1\":{\"10\":1}}],[\"$theme\",{\"1\":{\"10\":1}}],[\"82a6b1\",{\"1\":{\"10\":1}}],[\"其实主要是对消息集合进行过滤\",{\"1\":{\"45\":1}}],[\"其实就是启动\",{\"1\":{\"41\":1}}],[\"其实就是对\",{\"1\":{\"39\":1}}],[\"其实差不多\",{\"1\":{\"41\":1}}],[\"其高可用通过部署多个\",{\"1\":{\"31\":1}}],[\"其基本架构由客户端\",{\"1\":{\"31\":1}}],[\"其设计核心追求高性能\",{\"1\":{\"30\":1}}],[\"其他的什么消费组\",{\"1\":{\"32\":1}}],[\"其他语言等\",{\"1\":{\"13\":1}}],[\"其他更多可以参考该主题的说明文档\",{\"1\":{\"10\":1}}],[\"其他细节参考警告中给的链接\",{\"1\":{\"4\":1}}],[\"其中\",{\"1\":{\"10\":1}}],[\"清除缓存并启动开发服务器\",{\"1\":{\"9\":1}}],[\"使用\",{\"1\":{\"9\":1}}],[\"使用方式通用流程\",{\"1\":{\"7\":1}}],[\"创建一个\",{\"1\":{\"45\":1}}],[\"创建多个\",{\"1\":{\"44\":1}}],[\"创建好了\",{\"1\":{\"41\":1}}],[\"创建\",{\"1\":{\"9\":1,\"37\":1,\"39\":1,\"41\":3}}],[\"创建出的项目还自带文档\",{\"1\":{\"8\":1}}],[\"命令\",{\"0\":{\"9\":1}}],[\"点点看\",{\"1\":{\"7\":1}}],[\"右下角会自动出现一个向上的箭头\",{\"1\":{\"7\":1}}],[\"分配内存\",{\"1\":{\"45\":1}}],[\"分支\",{\"1\":{\"41\":1}}],[\"分析一个类就跟我们自己写一个类的流程差不多\",{\"1\":{\"39\":1}}],[\"分析源码的笔记测试了一下\",{\"1\":{\"7\":1}}],[\"分开发布\",{\"1\":{\"1\":1}}],[\"拖了个以前写的\",{\"1\":{\"7\":1}}],[\"似乎是300行以上触发\",{\"1\":{\"7\":1}}],[\"扫了一眼代码\",{\"1\":{\"7\":1}}],[\"官方没写说明也没写配置\",{\"1\":{\"7\":1}}],[\"官方文档里就有\",{\"1\":{\"5\":1}}],[\"x\",{\"1\":{\"7\":2}}],[\"xdir\",{\"1\":{\"6\":2}}],[\"在不同的消费模式\",{\"1\":{\"32\":1}}],[\"在io那一步中继日志写入完成就给主库发个确认消息\",{\"1\":{\"18\":1}}],[\"在\",{\"1\":{\"7\":1,\"26\":1,\"45\":1}}],[\"安装插件\",{\"1\":{\"7\":1}}],[\"1000\",{\"1\":{\"46\":1}}],[\"1024\",{\"1\":{\"39\":3}}],[\"1是正常发送那一次\",{\"1\":{\"44\":1}}],[\"128\",{\"1\":{\"37\":1}}],[\"1\",{\"1\":{\"7\":2,\"44\":2}}],[\"16\",{\"1\":{\"4\":2}}],[\"主动向\",{\"1\":{\"32\":2}}],[\"主要看\",{\"1\":{\"44\":1}}],[\"主要就是\",{\"1\":{\"24\":1}}],[\"主要是五个常见场景的同步器\",{\"1\":{\"23\":1}}],[\"主要组件包括以下部分\",{\"1\":{\"20\":1}}],[\"主要用来支持对变量进行非阻塞的线程安全编程\",{\"1\":{\"19\":1}}],[\"主要涉及三个线程\",{\"1\":{\"15\":1}}],[\"主库在写入\",{\"1\":{\"17\":1}}],[\"主库\",{\"1\":{\"15\":1,\"18\":1}}],[\"主题颜色影响各种高亮位置\",{\"1\":{\"10\":1}}],[\"主题颜色覆盖src\",{\"1\":{\"10\":1}}],[\"主题自带创建项目的脚手架\",{\"1\":{\"8\":1}}],[\"主题\",{\"0\":{\"8\":1}}],[\"主题推荐使用vuepress\",{\"1\":{\"7\":1}}],[\"主页的背景\",{\"1\":{\"3\":1}}],[\"插件\",{\"0\":{\"7\":1}}],[\"都做了什么之后\",{\"1\":{\"42\":1}}],[\"都是用\",{\"1\":{\"6\":1}}],[\"都没啥区别\",{\"1\":{\"6\":1}}],[\"和本地路由信息表\",{\"1\":{\"41\":1}}],[\"和\",{\"1\":{\"6\":1,\"13\":3,\"19\":1,\"22\":1,\"39\":1,\"41\":3,\"42\":1,\"44\":1,\"46\":3}}],[\"但实际上只是简单的路由信息的管理模块\",{\"1\":{\"31\":1}}],[\"但它不是\",{\"1\":{\"22\":1}}],[\"但是\",{\"1\":{\"6\":1,\"41\":1}}],[\"但并不强制\",{\"1\":{\"6\":1}}],[\"还不存在\",{\"1\":{\"46\":1}}],[\"还可以\",{\"1\":{\"22\":1}}],[\"还没想好怎么更\",{\"1\":{\"13\":1}}],[\"还是用\",{\"1\":{\"6\":1}}],[\"还挺全的\",{\"1\":{\"5\":1}}],[\"用来存\",{\"1\":{\"45\":1}}],[\"用来算超时的各种时间戳变量\",{\"1\":{\"44\":1}}],[\"用的\",{\"1\":{\"41\":1}}],[\"用\",{\"1\":{\"6\":1}}],[\"else\",{\"1\":{\"44\":5,\"46\":1}}],[\"endtransactionhooklist\",{\"1\":{\"46\":1}}],[\"endtimestamp\",{\"1\":{\"44\":15}}],[\"encodemessage\",{\"1\":{\"45\":1}}],[\"encodemessages\",{\"1\":{\"45\":2}}],[\"encodedmessages\",{\"1\":{\"45\":4}}],[\"encode\",{\"1\":{\"44\":1,\"45\":8}}],[\"env\",{\"1\":{\"6\":3}}],[\"equals\",{\"1\":{\"41\":1}}],[\"error\",{\"1\":{\"39\":1}}],[\"e\",{\"1\":{\"37\":2,\"40\":2,\"44\":15,\"45\":2}}],[\"externals\",{\"1\":{\"46\":1}}],[\"extensible\",{\"1\":{\"27\":1}}],[\"extends\",{\"1\":{\"26\":1}}],[\"exist\",{\"1\":{\"39\":1,\"44\":1}}],[\"exception\",{\"1\":{\"37\":1,\"44\":20,\"45\":1}}],[\"exchanger\",{\"1\":{\"19\":1,\"23\":1}}],[\"execute\",{\"1\":{\"26\":2}}],[\"executers\",{\"1\":{\"19\":1}}],[\"executorcompletionservice\",{\"1\":{\"27\":1}}],[\"executors\",{\"1\":{\"27\":3,\"46\":1}}],[\"executorservice\",{\"1\":{\"19\":2,\"26\":3,\"46\":3}}],[\"executor\",{\"0\":{\"26\":1},\"1\":{\"19\":3,\"20\":1,\"26\":5,\"46\":3}}],[\"export\",{\"1\":{\"4\":1}}],[\"yarn\",{\"1\":{\"6\":2}}],[\"先看属性和构造方法\",{\"1\":{\"46\":1}}],[\"先看他的属性和构造方法\",{\"1\":{\"39\":1}}],[\"先创建并启动\",{\"1\":{\"37\":1}}],[\"先根据\",{\"1\":{\"32\":1}}],[\"先添加这个\",{\"1\":{\"6\":1}}],[\"先嫖个10对吧\",{\"1\":{\"3\":1}}],[\"项目无法正常\",{\"1\":{\"6\":1}}],[\"||\",{\"1\":{\"46\":2}}],[\"|\",{\"1\":{\"6\":1}}],[\"否则你点击导航会\",{\"1\":{\"6\":1}}],[\"意味着\",{\"1\":{\"6\":1}}],[\"导航\",{\"1\":{\"6\":1}}],[\"导航的\",{\"1\":{\"6\":1}}],[\"milliseconds\",{\"1\":{\"46\":1}}],[\"mixall\",{\"1\":{\"41\":1,\"46\":1}}],[\"ms\",{\"1\":{\"44\":1}}],[\"msgbody\",{\"1\":{\"46\":1}}],[\"msgbodycompressed\",{\"1\":{\"46\":1}}],[\"msgbatch\",{\"1\":{\"45\":11}}],[\"msgs\",{\"1\":{\"45\":2}}],[\"msg\",{\"0\":{\"42\":1,\"43\":1,\"44\":1},\"1\":{\"37\":2,\"43\":6,\"44\":20,\"45\":3,\"46\":8}}],[\"massage\",{\"1\":{\"46\":1}}],[\"makesurestateok\",{\"1\":{\"44\":1}}],[\"maybe\",{\"1\":{\"41\":1}}],[\"maxmessagesize\",{\"1\":{\"39\":1}}],[\"messageaccessor\",{\"1\":{\"46\":2}}],[\"messagecloned\",{\"1\":{\"46\":4}}],[\"messageclientidsetter\",{\"1\":{\"45\":1}}],[\"messagedecoder\",{\"1\":{\"45\":1}}],[\"messagelist\",{\"1\":{\"45\":1}}],[\"messages\",{\"1\":{\"45\":4}}],[\"messagebatch\",{\"1\":{\"45\":5}}],[\"messagequeue\",{\"1\":{\"44\":2}}],[\"message\",{\"0\":{\"42\":1,\"43\":1,\"44\":1,\"55\":1},\"1\":{\"37\":2,\"39\":1,\"43\":1,\"44\":3,\"45\":13,\"46\":4}}],[\"methods\",{\"1\":{\"27\":2}}],[\"memory\",{\"0\":{\"21\":1},\"1\":{\"20\":1}}],[\"medium\",{\"1\":{\"7\":1}}],[\"mqfaultstrategy\",{\"1\":{\"46\":3}}],[\"mqselected\",{\"1\":{\"44\":3}}],[\"mqbrokerexception\",{\"1\":{\"43\":1,\"44\":6}}],[\"mq客户端的实例\",{\"1\":{\"41\":1}}],[\"mqclientfactory\",{\"1\":{\"41\":5,\"46\":7}}],[\"mqclientmanager\",{\"1\":{\"41\":4}}],[\"mqclientinstance\",{\"1\":{\"41\":9,\"46\":1}}],[\"mqclientexception\",{\"1\":{\"40\":2,\"41\":4,\"43\":1,\"44\":14,\"45\":2}}],[\"mq\",{\"1\":{\"11\":2,\"30\":1,\"44\":16,\"46\":2}}],[\"mysql主从复制\",{\"0\":{\"14\":1}}],[\"mysql\",{\"0\":{\"49\":1},\"1\":{\"13\":1,\"15\":1}}],[\"my\",{\"1\":{\"9\":1}}],[\"md时\",{\"1\":{\"11\":2}}],[\"md文件\",{\"1\":{\"6\":1}}],[\"md\",{\"1\":{\"6\":2,\"11\":1}}],[\"most\",{\"1\":{\"27\":1}}],[\"more\",{\"1\":{\"4\":1}}],[\"module\",{\"1\":{\"4\":1}}],[\"与\",{\"1\":{\"6\":1,\"32\":2}}],[\"经验的话你可以干很多事情\",{\"1\":{\"6\":1}}],[\"有兴趣的话可以从\",{\"1\":{\"46\":1}}],[\"有兴趣可以自己看一下\",{\"1\":{\"46\":1}}],[\"有10个构造方法\",{\"1\":{\"39\":1}}],[\"有\",{\"1\":{\"6\":1}}],[\"有前端经验很好\",{\"1\":{\"6\":1}}],[\"有开发经验的体验尚可\",{\"1\":{\"6\":1}}],[\"0\",{\"1\":{\"7\":1,\"37\":1,\"44\":2,\"45\":3,\"46\":1}}],[\"0开发经验上手略有门槛\",{\"1\":{\"6\":1}}],[\"09\",{\"1\":{\"4\":1}}],[\"中提到的\",{\"1\":{\"44\":1}}],[\"中的数据复制到\",{\"1\":{\"45\":1}}],[\"中的过期请求\",{\"1\":{\"41\":1}}],[\"中的内容\",{\"1\":{\"35\":1}}],[\"中的脚本部分\",{\"1\":{\"6\":1}}],[\"中读取消息数据转发给消费队列\",{\"1\":{\"32\":1}}],[\"中间件\",{\"1\":{\"13\":1}}],[\"中自认为比较核心的内容\",{\"1\":{\"13\":1}}],[\"中\",{\"1\":{\"5\":1,\"15\":2,\"32\":1,\"41\":1,\"45\":1}}],[\"+=\",{\"1\":{\"44\":1,\"45\":2}}],[\"+\",{\"1\":{\"5\":1,\"13\":3,\"41\":6,\"44\":3,\"45\":2,\"46\":2}}],[\"看起来就是直接往\",{\"1\":{\"34\":1}}],[\"看这里\",{\"1\":{\"5\":1}}],[\"看见这个就去升级一下对应\",{\"1\":{\"4\":1}}],[\"白写了\",{\"1\":{\"5\":1}}],[\"白嫖小马哥\",{\"0\":{\"3\":1}}],[\"比如收到消息后先写入缓冲区\",{\"1\":{\"31\":1}}],[\"比如concurrenthashmap则是在特定情况下可以允许任意数量线程并发读取\",{\"1\":{\"22\":1}}],[\"比如我们可以通过collections\",{\"1\":{\"22\":1}}],[\"比如内存\",{\"1\":{\"13\":1}}],[\"比如\",{\"1\":{\"4\":1,\"11\":1,\"21\":1,\"22\":1,\"24\":1,\"41\":1}}],[\"搜索\",{\"1\":{\"4\":1}}],[\"2\",{\"1\":{\"7\":2,\"39\":2}}],[\"22\",{\"1\":{\"4\":1}}],[\"2023\",{\"1\":{\"4\":1}}],[\"20\",{\"1\":{\"4\":2}}],[\"header\",{\"1\":{\"46\":1}}],[\"hello\",{\"1\":{\"37\":1}}],[\"hook\",{\"1\":{\"46\":2}}],[\"host\",{\"1\":{\"45\":1}}],[\"hope\",{\"1\":{\"2\":1,\"6\":1,\"8\":1,\"9\":1}}],[\"hashcode\",{\"1\":{\"45\":1}}],[\"hashmap\",{\"1\":{\"22\":4}}],[\"has\",{\"1\":{\"41\":1}}],[\"happen\",{\"1\":{\"21\":4}}],[\"https\",{\"1\":{\"4\":1,\"46\":1}}],[\"ip\",{\"1\":{\"45\":1}}],[\"issues\",{\"1\":{\"46\":1}}],[\"issendmessagewithvipchannel\",{\"1\":{\"41\":1}}],[\"ishavetopicrouterinfo\",{\"1\":{\"46\":1}}],[\"isretryanotherbrokerwhennotstoreok\",{\"1\":{\"44\":1}}],[\"if\",{\"1\":{\"40\":1,\"41\":3,\"44\":14,\"46\":8}}],[\"id\",{\"1\":{\"39\":1}}],[\"i++\",{\"1\":{\"37\":1}}],[\"implementation\",{\"1\":{\"27\":1}}],[\"invokesyncimpl\",{\"1\":{\"46\":1}}],[\"invokeid\",{\"1\":{\"44\":9}}],[\"incrementandget\",{\"1\":{\"46\":1}}],[\"include\",{\"1\":{\"27\":1}}],[\"initiate\",{\"1\":{\"45\":1}}],[\"info\",{\"1\":{\"41\":1,\"44\":5}}],[\"information\",{\"1\":{\"4\":1}}],[\"instanceof\",{\"1\":{\"44\":4}}],[\"instance\",{\"1\":{\"41\":6,\"46\":2}}],[\"instancename\",{\"1\":{\"41\":1}}],[\"inner\",{\"1\":{\"41\":2}}],[\"integer\",{\"1\":{\"46\":1}}],[\"interruptedexception\",{\"1\":{\"43\":1,\"44\":4}}],[\"interface\",{\"1\":{\"26\":1}}],[\"intro\",{\"1\":{\"44\":1,\"46\":1}}],[\"int\",{\"1\":{\"37\":1,\"39\":6,\"44\":2,\"45\":2,\"46\":1}}],[\"index\",{\"1\":{\"31\":1}}],[\"in\",{\"1\":{\"27\":1,\"39\":1,\"45\":1}}],[\"i\",{\"1\":{\"15\":2,\"37\":2}}],[\"io\",{\"1\":{\"13\":4}}],[\"ico\",{\"1\":{\"3\":1}}],[\"validatenameserversetting\",{\"1\":{\"44\":1}}],[\"validators\",{\"1\":{\"43\":1,\"44\":1,\"45\":2}}],[\"value\",{\"1\":{\"41\":1,\"46\":1}}],[\"volatile\",{\"1\":{\"39\":1}}],[\"void\",{\"1\":{\"26\":1,\"40\":1,\"41\":2}}],[\"v3\",{\"1\":{\"4\":1}}],[\"v2\",{\"1\":{\"4\":2}}],[\"vue\",{\"1\":{\"4\":2,\"6\":1}}],[\"vuepress\",{\"0\":{\"6\":1},\"1\":{\"2\":2,\"6\":5,\"7\":5,\"9\":1,\"10\":3,\"12\":2}}],[\"uniq\",{\"1\":{\"45\":1}}],[\"unit\",{\"1\":{\"39\":1}}],[\"url\",{\"1\":{\"41\":1}}],[\"using\",{\"1\":{\"27\":1,\"46\":2}}],[\"use\",{\"1\":{\"4\":1}}],[\"utilities\",{\"1\":{\"27\":1}}],[\"utility\",{\"1\":{\"27\":1}}],[\"util\",{\"0\":{\"19\":1},\"1\":{\"19\":3,\"20\":1}}],[\"updatetopicrouteinfofromnameserver\",{\"1\":{\"46\":2}}],[\"updatefaultitem\",{\"1\":{\"44\":5}}],[\"update\",{\"0\":{\"4\":1},\"1\":{\"4\":1}}],[\"tmpmessage\",{\"1\":{\"46\":4}}],[\"tmp\",{\"1\":{\"45\":3}}],[\"taga\",{\"1\":{\"37\":1}}],[\"tasks\",{\"1\":{\"27\":1}}],[\"task\",{\"1\":{\"19\":1}}],[\"tbw102\",{\"1\":{\"32\":3}}],[\"tunable\",{\"1\":{\"27\":1}}],[\"times++\",{\"1\":{\"44\":1}}],[\"times\",{\"1\":{\"44\":6}}],[\"timestotal\",{\"1\":{\"44\":3}}],[\"timestotal就是一条消息的发送总次数\",{\"1\":{\"44\":1}}],[\"timestamp\",{\"1\":{\"41\":1}}],[\"timeout\",{\"1\":{\"44\":7,\"46\":6}}],[\"timeunit\",{\"1\":{\"24\":1,\"46\":1}}],[\"timing\",{\"0\":{\"24\":1},\"1\":{\"20\":1}}],[\"true\",{\"1\":{\"41\":1,\"44\":4,\"46\":3}}],[\"trace\",{\"1\":{\"40\":1}}],[\"tracedispatcher\",{\"1\":{\"39\":2,\"40\":2}}],[\"transient\",{\"1\":{\"39\":1}}],[\"transitioning\",{\"1\":{\"4\":1}}],[\"trytofindtopicpublishinfo\",{\"1\":{\"44\":2,\"46\":2}}],[\"try\",{\"1\":{\"37\":1,\"40\":1,\"44\":1,\"45\":1}}],[\"treemap等等\",{\"1\":{\"22\":1}}],[\"throw\",{\"1\":{\"41\":2,\"44\":6,\"45\":1,\"46\":2}}],[\"throws\",{\"1\":{\"40\":1,\"41\":2,\"43\":1,\"44\":3,\"45\":1}}],[\"threadindex\",{\"1\":{\"46\":2}}],[\"thread\",{\"1\":{\"26\":1,\"27\":1,\"46\":3}}],[\"threadfactory\",{\"1\":{\"19\":1,\"46\":1}}],[\"threadpoolexecutor\",{\"1\":{\"19\":1,\"27\":1,\"46\":2}}],[\"this\",{\"1\":{\"39\":3,\"40\":5,\"41\":21,\"43\":2,\"44\":17,\"45\":1,\"46\":21}}],[\"that\",{\"1\":{\"27\":1}}],[\"them\",{\"1\":{\"27\":1}}],[\"theme\",{\"1\":{\"2\":1,\"6\":1,\"9\":1,\"10\":1}}],[\"the\",{\"1\":{\"4\":2,\"27\":4,\"41\":3,\"45\":1}}],[\"ts中添加\",{\"1\":{\"10\":1}}],[\"todo\",{\"1\":{\"45\":2}}],[\"tostring\",{\"1\":{\"44\":6}}],[\"topicwithnamespace\",{\"1\":{\"46\":1}}],[\"topicpublishinfo>\",{\"1\":{\"46\":2}}],[\"topicpublishinfo\",{\"1\":{\"41\":1,\"44\":8,\"46\":14}}],[\"topicpublishinfotable\",{\"1\":{\"41\":1,\"46\":5}}],[\"topicvalidator\",{\"1\":{\"39\":1}}],[\"topictest\",{\"1\":{\"37\":1}}],[\"topic\",{\"1\":{\"31\":1,\"32\":10,\"34\":3,\"39\":5,\"41\":2,\"43\":1,\"44\":7,\"45\":1,\"46\":13}}],[\"top回到最上\",{\"1\":{\"7\":1}}],[\"tools\",{\"1\":{\"7\":1}}],[\"to\",{\"1\":{\"4\":2,\"7\":1,\"45\":1}}],[\"警告\",{\"1\":{\"4\":1}}],[\"权限要够\",{\"1\":{\"5\":1}}],[\"权限是不是不够\",{\"1\":{\"4\":1}}],[\"权限错误检查两个位置\",{\"1\":{\"4\":1}}],[\"另一个检查你生成的\",{\"1\":{\"4\":1}}],[\"ps\",{\"1\":{\"47\":1}}],[\"pos\",{\"1\":{\"45\":3}}],[\"pools\",{\"1\":{\"27\":1}}],[\"pid\",{\"1\":{\"41\":1}}],[\"permission\",{\"1\":{\"39\":1}}],[\"putifabsent\",{\"1\":{\"46\":1}}],[\"put\",{\"1\":{\"41\":1}}],[\"public\",{\"1\":{\"39\":1,\"40\":1,\"41\":2,\"43\":1,\"44\":2,\"45\":1,\"46\":2}}],[\"push\",{\"1\":{\"32\":2}}],[\"pull\",{\"1\":{\"32\":2}}],[\"phaser\",{\"1\":{\"19\":1,\"23\":1}}],[\"prevbody\",{\"1\":{\"46\":2}}],[\"protected\",{\"1\":{\"39\":1,\"46\":2}}],[\"producertable\",{\"1\":{\"41\":3}}],[\"producergroup\",{\"1\":{\"39\":4,\"40\":1,\"41\":8}}],[\"producergroupname\",{\"1\":{\"37\":1}}],[\"producer\",{\"0\":{\"38\":1,\"42\":1},\"1\":{\"32\":6,\"34\":1,\"37\":7,\"38\":1,\"41\":18,\"42\":3,\"44\":4,\"46\":2,\"47\":2}}],[\"processing\",{\"1\":{\"27\":1}}],[\"providing\",{\"1\":{\"27\":1}}],[\"provides\",{\"1\":{\"27\":1}}],[\"provider\",{\"1\":{\"6\":2}}],[\"provide\",{\"1\":{\"4\":1,\"27\":1}}],[\"properties\",{\"0\":{\"21\":1},\"1\":{\"20\":1,\"45\":1}}],[\"private\",{\"1\":{\"39\":11,\"44\":1,\"45\":1,\"46\":17}}],[\"priorityblockingqueue\",{\"1\":{\"19\":1}}],[\"printstacktrace\",{\"1\":{\"37\":1}}],[\"printf\",{\"1\":{\"37\":1}}],[\"print\",{\"1\":{\"10\":1}}],[\"plugin\",{\"1\":{\"7\":2}}],[\"please\",{\"1\":{\"4\":1,\"41\":1}}],[\"parseint\",{\"1\":{\"46\":1}}],[\"palette\",{\"1\":{\"10\":1}}],[\"package\",{\"1\":{\"6\":2}}],[\"pat\",{\"1\":{\"4\":1,\"5\":2}}],[\"pnpm\",{\"1\":{\"4\":4,\"6\":3,\"9\":4}}],[\"的源码是真的很难读\",{\"1\":{\"47\":1}}],[\"的源码分析告一段落\",{\"1\":{\"44\":1}}],[\"的参数\",{\"1\":{\"45\":1}}],[\"的合法性\",{\"1\":{\"44\":1}}],[\"的过程\",{\"1\":{\"41\":1}}],[\"的信息存入本地的\",{\"1\":{\"41\":1}}],[\"的角色还不明确\",{\"1\":{\"41\":1}}],[\"的概念是不区分\",{\"1\":{\"41\":1}}],[\"的形式\",{\"1\":{\"41\":1}}],[\"的状态\",{\"1\":{\"41\":1}}],[\"的构造方法中都没有修改该属性的操作\",{\"1\":{\"41\":1}}],[\"的包装\",{\"1\":{\"40\":1}}],[\"的大小超过\",{\"1\":{\"39\":1}}],[\"的实例\",{\"1\":{\"38\":1}}],[\"的本地部署\",{\"1\":{\"33\":1}}],[\"的时候\",{\"1\":{\"32\":1}}],[\"的路由信息不存在\",{\"1\":{\"46\":1}}],[\"的路由信息的\",{\"1\":{\"46\":1}}],[\"的路由信息\",{\"1\":{\"34\":1,\"41\":1,\"46\":1}}],[\"的路由信息也会自动上报到\",{\"1\":{\"32\":1}}],[\"的路由信息都存在这里\",{\"1\":{\"32\":1}}],[\"的核心功能就是消息的接受\",{\"1\":{\"30\":1}}],[\"的区别\",{\"1\":{\"22\":1}}],[\"的\",{\"1\":{\"22\":1,\"41\":1,\"44\":2,\"46\":1}}],[\"的锁实现\",{\"1\":{\"19\":1}}],[\"的内容\",{\"1\":{\"44\":1}}],[\"的内容写入从库的中继日志中\",{\"1\":{\"15\":1}}],[\"的内容也单独更新\",{\"1\":{\"13\":1}}],[\"的演进\",{\"1\":{\"13\":1}}],[\"的机会\",{\"1\":{\"12\":1}}],[\"的版本迭代线\",{\"1\":{\"13\":1}}],[\"的版本\",{\"1\":{\"4\":1,\"7\":1}}],[\"的权限\",{\"1\":{\"4\":1}}],[\"的错误\",{\"1\":{\"4\":1}}],[\"的缓存没关\",{\"1\":{\"4\":1}}],[\"checkforbiddenhooklist\",{\"1\":{\"46\":1}}],[\"checkexecutor\",{\"1\":{\"46\":1}}],[\"checkrequestqueue\",{\"1\":{\"46\":1}}],[\"checkmessage\",{\"1\":{\"43\":1,\"44\":1,\"45\":2}}],[\"checkconfig\",{\"1\":{\"41\":2}}],[\"channel\",{\"1\":{\"46\":1}}],[\"changeinstancenametopid\",{\"1\":{\"41\":1}}],[\"changelog\",{\"1\":{\"4\":1}}],[\"charset\",{\"1\":{\"37\":1}}],[\"currenttimemillis\",{\"1\":{\"44\":8,\"46\":2}}],[\"current\",{\"1\":{\"39\":1}}],[\"case\",{\"1\":{\"41\":4,\"44\":3,\"46\":3}}],[\"catch\",{\"1\":{\"37\":1,\"40\":1,\"44\":4,\"45\":1}}],[\"call\",{\"1\":{\"44\":1,\"46\":2}}],[\"calltimeout\",{\"1\":{\"44\":3}}],[\"callback\",{\"1\":{\"37\":1,\"44\":2}}],[\"callable\",{\"1\":{\"19\":2}}],[\"cyclicbarrier\",{\"1\":{\"19\":1,\"23\":1}}],[\"cicd\",{\"1\":{\"13\":1}}],[\"copies\",{\"1\":{\"45\":1}}],[\"copyonwritearrayset<integer>\",{\"1\":{\"39\":1}}],[\"copyonwritearrayset\",{\"1\":{\"19\":1}}],[\"copyonwritearraylist\",{\"1\":{\"19\":1}}],[\"cost\",{\"1\":{\"44\":1}}],[\"costtimesync\",{\"1\":{\"46\":3}}],[\"costtimeasync\",{\"1\":{\"46\":3}}],[\"costtime\",{\"1\":{\"44\":3}}],[\"com\",{\"1\":{\"46\":1}}],[\"compressed\",{\"1\":{\"46\":1}}],[\"compress\",{\"1\":{\"46\":1}}],[\"compressmsgbodyoverhowmuch\",{\"1\":{\"39\":1}}],[\"commpressed\",{\"1\":{\"46\":1}}],[\"communicationmode\",{\"1\":{\"44\":8,\"46\":3}}],[\"commit\",{\"1\":{\"31\":1,\"32\":2}}],[\"common\",{\"1\":{\"27\":2}}],[\"command\",{\"1\":{\"26\":1}}],[\"coordinating\",{\"1\":{\"27\":1}}],[\"collection<message>\",{\"1\":{\"45\":1}}],[\"collections\",{\"0\":{\"22\":1},\"1\":{\"20\":1,\"22\":1}}],[\"color\",{\"1\":{\"10\":2}}],[\"countdownlatch\",{\"1\":{\"19\":1,\"23\":1}}],[\"connect\",{\"1\":{\"44\":1}}],[\"context\",{\"1\":{\"46\":2}}],[\"contains\",{\"1\":{\"44\":1}}],[\"continue\",{\"1\":{\"44\":4}}],[\"consumergroup\",{\"1\":{\"32\":3,\"41\":1}}],[\"consumer\",{\"1\":{\"32\":11,\"41\":1}}],[\"consumequeue\",{\"1\":{\"31\":1}}],[\"consistency\",{\"0\":{\"21\":1},\"1\":{\"20\":1}}],[\"concrete\",{\"1\":{\"27\":1}}],[\"concurrentmap<string\",{\"1\":{\"46\":1}}],[\"concurrentskiplistset\",{\"1\":{\"19\":1}}],[\"concurrentskiplistmap\",{\"1\":{\"19\":1,\"22\":1}}],[\"concurrentlinkedqueue\",{\"1\":{\"19\":1}}],[\"concurrentlinkeddeque\",{\"1\":{\"19\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"46\":1}}],[\"concurrenthashmap\",{\"1\":{\"19\":1,\"22\":2,\"41\":2}}],[\"concurrent\",{\"0\":{\"19\":1,\"22\":1},\"1\":{\"19\":3,\"20\":2,\"22\":4}}],[\"configurations\",{\"1\":{\"27\":1}}],[\"config\",{\"1\":{\"7\":1}}],[\"created\",{\"1\":{\"41\":1}}],[\"createtopickey\",{\"1\":{\"39\":1}}],[\"create\",{\"1\":{\"9\":1,\"39\":1,\"41\":4,\"46\":1}}],[\"creatememoryhistory\",{\"1\":{\"4\":1}}],[\"cross\",{\"1\":{\"6\":3}}],[\"clonemessage\",{\"1\":{\"46\":2}}],[\"clone\",{\"1\":{\"46\":1}}],[\"clienterrorcode\",{\"1\":{\"44\":4}}],[\"clientid\",{\"1\":{\"41\":2}}],[\"client\",{\"1\":{\"37\":1,\"41\":4}}],[\"class\",{\"1\":{\"27\":2}}],[\"classes\",{\"1\":{\"27\":1}}],[\"clean\",{\"1\":{\"9\":1}}],[\"cl\",{\"1\":{\"4\":1}}],[\"api\",{\"1\":{\"46\":1}}],[\"apache\",{\"1\":{\"46\":1}}],[\"allbytes\",{\"1\":{\"45\":5}}],[\"allsize\",{\"1\":{\"45\":3}}],[\"already\",{\"1\":{\"41\":1}}],[\"avoid\",{\"1\":{\"45\":1}}],[\"availableprocessors\",{\"1\":{\"46\":2}}],[\"available\",{\"1\":{\"39\":1}}],[\"accumulate\",{\"1\":{\"45\":1}}],[\"access\",{\"1\":{\"44\":1}}],[\"actions\",{\"1\":{\"4\":4}}],[\"action\",{\"1\":{\"4\":6}}],[\"at\",{\"1\":{\"44\":3}}],[\"atomicinteger\",{\"1\":{\"46\":2}}],[\"atomic\",{\"1\":{\"19\":2}}],[\"aka\",{\"1\":{\"39\":1}}],[\"auto\",{\"1\":{\"39\":1}}],[\"a\",{\"1\":{\"27\":2}}],[\"assert\",{\"1\":{\"46\":1}}],[\"assists\",{\"1\":{\"27\":1}}],[\"asyncsenderexecutor\",{\"1\":{\"46\":2}}],[\"asyncsenderthreadpoolqueue\",{\"1\":{\"46\":3}}],[\"async\",{\"1\":{\"44\":1,\"46\":1}}],[\"asynchronous\",{\"1\":{\"27\":1}}],[\"aslist\",{\"1\":{\"39\":1}}],[\"as\",{\"1\":{\"27\":2}}],[\"arraylist<checkforbiddenhook>\",{\"1\":{\"46\":2}}],[\"arraylist<endtransactionhook>\",{\"1\":{\"46\":2}}],[\"arraylist<sendmessagehook>\",{\"1\":{\"46\":2}}],[\"arraylist<byte\",{\"1\":{\"45\":1}}],[\"arraycopy\",{\"1\":{\"45\":2}}],[\"arrays\",{\"1\":{\"39\":1,\"44\":1}}],[\"arrayblockingqueue\",{\"1\":{\"19\":1}}],[\"are\",{\"1\":{\"4\":1}}],[\"aqs\",{\"1\":{\"13\":1,\"19\":2}}],[\"add\",{\"1\":{\"4\":1,\"6\":1,\"45\":1}}],[\"another\",{\"1\":{\"41\":1}}],[\"and\",{\"1\":{\"27\":3,\"46\":1}}],[\"an\",{\"1\":{\"4\":1}}],[\"a1\",{\"1\":{\"3\":2}}],[\"runtime\",{\"1\":{\"46\":2}}],[\"running\",{\"1\":{\"41\":2,\"44\":1}}],[\"runnable\",{\"1\":{\"19\":2,\"26\":1,\"46\":1}}],[\"r\",{\"1\":{\"46\":4}}],[\"rt\",{\"1\":{\"44\":4}}],[\"random\",{\"1\":{\"44\":1,\"46\":3}}],[\"rpchook\",{\"1\":{\"39\":3,\"41\":1,\"46\":6}}],[\"route\",{\"1\":{\"44\":2}}],[\"router\",{\"1\":{\"4\":2}}],[\"rocket\",{\"1\":{\"11\":1}}],[\"rocketmq的目录页面\",{\"1\":{\"11\":1}}],[\"rocketmq\",{\"0\":{\"29\":1,\"30\":1,\"34\":1,\"54\":1},\"1\":{\"7\":1,\"11\":2,\"30\":1,\"32\":2,\"33\":1,\"34\":1,\"41\":2,\"46\":1,\"47\":1}}],[\"recover\",{\"1\":{\"46\":1}}],[\"refactor\",{\"1\":{\"45\":1}}],[\"reference\",{\"0\":{\"28\":1}}],[\"response\",{\"1\":{\"46\":1}}],[\"responsecode\",{\"1\":{\"39\":6}}],[\"resend\",{\"1\":{\"44\":4}}],[\"reset\",{\"1\":{\"44\":1,\"46\":1}}],[\"return\",{\"1\":{\"43\":1,\"44\":7,\"45\":2,\"46\":3}}],[\"retryanotherbrokerwhennotstoreok\",{\"1\":{\"39\":1}}],[\"retrytimeswhensendasyncfailed\",{\"1\":{\"39\":1}}],[\"retrytimeswhensendfailed\",{\"1\":{\"39\":1}}],[\"retryresponsecodes\",{\"1\":{\"39\":1}}],[\"remotingtimeoutexception\",{\"1\":{\"44\":1}}],[\"remotingtoomuchrequestexception\",{\"1\":{\"44\":1,\"46\":2}}],[\"remotingconnectexception\",{\"1\":{\"44\":1}}],[\"remotingexception\",{\"1\":{\"43\":1,\"44\":4}}],[\"remotinghelper\",{\"1\":{\"37\":1}}],[\"requestheader\",{\"1\":{\"46\":2}}],[\"requesthousekeepingservice\",{\"1\":{\"46\":1}}],[\"request\",{\"1\":{\"46\":4}}],[\"requestfuturetable\",{\"1\":{\"41\":1}}],[\"requested\",{\"1\":{\"4\":1}}],[\"registerok\",{\"1\":{\"41\":2}}],[\"registerproducer\",{\"1\":{\"41\":3}}],[\"readqueue\",{\"1\":{\"39\":1,\"44\":1}}],[\"readme\",{\"1\":{\"6\":3}}],[\"reentrantreadwritelock\",{\"1\":{\"19\":1}}],[\"reentrantlock\",{\"1\":{\"19\":1}}],[\"redis\",{\"1\":{\"13\":2}}],[\"should\",{\"1\":{\"46\":1}}],[\"shutdown\",{\"1\":{\"37\":1,\"41\":1}}],[\"size\",{\"1\":{\"45\":2}}],[\"sms\",{\"1\":{\"44\":4}}],[\"suggesttodo\",{\"1\":{\"41\":2,\"44\":2}}],[\"switch\",{\"1\":{\"41\":2,\"44\":1,\"46\":2}}],[\"s\",{\"1\":{\"37\":1,\"44\":10}}],[\"system\",{\"1\":{\"37\":1,\"39\":1,\"44\":8,\"45\":2,\"46\":3}}],[\"sync\",{\"1\":{\"44\":4,\"46\":1}}],[\"synchronizers\",{\"0\":{\"23\":1},\"1\":{\"20\":1}}],[\"synchronizedmap\",{\"1\":{\"22\":2}}],[\"synchronized\",{\"1\":{\"13\":1,\"22\":2}}],[\"syntaxerror\",{\"1\":{\"4\":1}}],[\"still\",{\"1\":{\"44\":1}}],[\"static\",{\"1\":{\"45\":1}}],[\"state\",{\"1\":{\"41\":1}}],[\"startscheduledtask\",{\"1\":{\"41\":1}}],[\"started\",{\"1\":{\"41\":1}}],[\"startfactory\",{\"1\":{\"41\":2}}],[\"start\",{\"0\":{\"38\":1,\"40\":1,\"41\":1},\"1\":{\"35\":1,\"37\":2,\"39\":1,\"40\":6,\"41\":10,\"42\":1,\"44\":2}}],[\"string\",{\"1\":{\"39\":4,\"44\":9,\"46\":1}}],[\"styles\",{\"1\":{\"10\":2}}],[\"sleep\",{\"1\":{\"24\":1}}],[\"sql语句\",{\"1\":{\"15\":1}}],[\"sql\",{\"1\":{\"13\":1,\"15\":3}}],[\"specify\",{\"1\":{\"41\":1}}],[\"spi\",{\"1\":{\"13\":1}}],[\"springcloud\",{\"1\":{\"13\":1}}],[\"springboot\",{\"1\":{\"13\":1}}],[\"spring\",{\"1\":{\"13\":1}}],[\"scheduledthreadpoolexecutor\",{\"1\":{\"27\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"19\":1,\"26\":1,\"46\":2}}],[\"scss文件中进行修改\",{\"1\":{\"10\":1}}],[\"scripts\",{\"1\":{\"6\":1}}],[\"src\",{\"1\":{\"6\":2,\"10\":2}}],[\"selectonemessagequeue\",{\"1\":{\"44\":2}}],[\"servicestate\",{\"1\":{\"41\":10,\"44\":1,\"46\":3}}],[\"service\",{\"1\":{\"39\":1,\"41\":2}}],[\"setbody等待发送\",{\"1\":{\"45\":1}}],[\"setbody\",{\"1\":{\"45\":2,\"46\":1}}],[\"setuniqid\",{\"1\":{\"45\":1}}],[\"setup\",{\"1\":{\"4\":4}}],[\"setresponsecode\",{\"1\":{\"44\":5}}],[\"settopic\",{\"1\":{\"43\":1,\"44\":1,\"45\":2,\"46\":1}}],[\"setproducergroup\",{\"1\":{\"40\":1}}],[\"set<integer>\",{\"1\":{\"39\":1}}],[\"sendstatus\",{\"1\":{\"44\":1}}],[\"sendkernelimpl\",{\"1\":{\"44\":7,\"46\":3}}],[\"sendcallback\",{\"1\":{\"44\":3,\"46\":1}}],[\"senddefaultimpl\",{\"1\":{\"44\":5}}],[\"sendheartbeattoallbrokerwithlock\",{\"1\":{\"41\":1}}],[\"sendmessage\",{\"1\":{\"46\":2}}],[\"sendmessagehooklist\",{\"1\":{\"46\":1}}],[\"sendmessagewithvipchannel=\",{\"1\":{\"41\":1}}],[\"sendmsgtimeout\",{\"1\":{\"39\":1}}],[\"send\",{\"0\":{\"42\":1,\"43\":1,\"44\":1},\"1\":{\"37\":1,\"42\":1,\"43\":2,\"44\":9,\"46\":1,\"47\":1}}],[\"sendresult\",{\"1\":{\"37\":3,\"43\":1,\"44\":12,\"46\":2}}],[\"semaphore\",{\"1\":{\"19\":1,\"23\":1}}],[\"secrets\",{\"1\":{\"5\":1}}],[\"see\",{\"1\":{\"4\":1}}],[\"svg\",{\"1\":{\"3\":2}}],[\"就通过\",{\"1\":{\"45\":1}}],[\"就是存在这里\",{\"1\":{\"46\":1}}],[\"就是之后\",{\"1\":{\"45\":1}}],[\"就是调用\",{\"1\":{\"45\":1}}],[\"就是对整个\",{\"1\":{\"45\":1}}],[\"就是创建\",{\"1\":{\"41\":1}}],[\"就是给\",{\"1\":{\"41\":1}}],[\"就是个\",{\"1\":{\"41\":1}}],[\"就是用于并发环境下的集合类\",{\"1\":{\"22\":1}}],[\"就改成\",{\"1\":{\"41\":1}}],[\"就不全贴出来了\",{\"1\":{\"39\":1}}],[\"就不分类了\",{\"1\":{\"0\":1}}],[\"就进行压缩\",{\"1\":{\"39\":1}}],[\"就比如\",{\"1\":{\"13\":1}}],[\"就主要是\",{\"1\":{\"13\":1}}],[\"就直接搜\",{\"1\":{\"4\":1}}],[\"就报一个\",{\"1\":{\"4\":1}}],[\"执行各种已提交的\",{\"1\":{\"19\":1}}],[\"执行\",{\"1\":{\"4\":1,\"32\":1}}],[\"本文以跟随\",{\"1\":{\"47\":1}}],[\"本质上就是\",{\"1\":{\"41\":1}}],[\"本质上同一时间只有一个线程访问它并没有并发concurrent\",{\"1\":{\"22\":1}}],[\"本地路由信息表\",{\"1\":{\"46\":1}}],[\"本地路由表不为空\",{\"1\":{\"44\":1}}],[\"本地是有缓存\",{\"1\":{\"46\":1}}],[\"本地没有就带着\",{\"1\":{\"32\":1}}],[\"本地运行没问题\",{\"1\":{\"4\":1}}],[\"本站调试记录\",{\"0\":{\"2\":1}}],[\"失败策略\",{\"1\":{\"46\":1}}],[\"失败\",{\"1\":{\"4\":1,\"6\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"46\":2}}],[\"blog\",{\"1\":{\"1\":2,\"4\":1}}],[\"bytes\",{\"1\":{\"45\":4}}],[\"byte\",{\"1\":{\"45\":5}}],[\"break\",{\"1\":{\"41\":2,\"44\":3,\"46\":3}}],[\"brokeraddr\",{\"1\":{\"46\":2}}],[\"brokername\",{\"1\":{\"44\":1}}],[\"brokerssent\",{\"1\":{\"44\":5}}],[\"broker\",{\"1\":{\"31\":3,\"32\":10,\"34\":1,\"39\":2,\"44\":8,\"46\":1}}],[\"beginstarttime\",{\"1\":{\"46\":2}}],[\"begintimestampprev\",{\"1\":{\"44\":12}}],[\"begintimestampfirst\",{\"1\":{\"44\":5}}],[\"be\",{\"1\":{\"46\":1}}],[\"been\",{\"1\":{\"41\":1}}],[\"before于\",{\"1\":{\"21\":1}}],[\"before\",{\"1\":{\"21\":3,\"41\":1}}],[\"boolean\",{\"1\":{\"39\":1,\"41\":2,\"44\":1,\"46\":1}}],[\"body\",{\"1\":{\"39\":1,\"46\":3}}],[\"bug\",{\"1\":{\"46\":1}}],[\"buff\",{\"1\":{\"45\":1}}],[\"buffer\",{\"1\":{\"45\":4}}],[\"buyer\",{\"1\":{\"39\":1}}],[\"build\",{\"1\":{\"4\":2,\"6\":5,\"9\":1}}],[\"binlog\",{\"1\":{\"15\":6,\"17\":1}}],[\"batch\",{\"0\":{\"45\":1},\"1\":{\"44\":1,\"45\":1}}],[\"based\",{\"1\":{\"27\":1}}],[\"balloon\",{\"1\":{\"7\":1}}],[\"back\",{\"1\":{\"7\":1}}],[\"现在不用手动清缓存了\",{\"1\":{\"4\":1}}],[\"思前想后才记起怕不是\",{\"1\":{\"4\":1}}],[\"次也没找到线上显示错误的原因\",{\"1\":{\"4\":1}}],[\"null\",{\"1\":{\"39\":1,\"40\":1,\"41\":2,\"44\":13,\"46\":1}}],[\"name\",{\"1\":{\"41\":2}}],[\"namespaceutil\",{\"1\":{\"46\":1}}],[\"namespace\",{\"1\":{\"39\":3,\"44\":1}}],[\"nameserver\",{\"1\":{\"32\":3,\"46\":1}}],[\"namesrv\",{\"1\":{\"31\":6,\"34\":1,\"39\":1}}],[\"named\",{\"1\":{\"4\":1}}],[\"nextlong\",{\"1\":{\"44\":1}}],[\"newthread\",{\"1\":{\"46\":1}}],[\"newsinglethreadscheduledexecutor\",{\"1\":{\"46\":1}}],[\"new\",{\"1\":{\"22\":2,\"37\":2,\"39\":2,\"41\":4,\"44\":5,\"45\":3,\"46\":16}}],[\"nettyremotingabstract\",{\"1\":{\"46\":1}}],[\"netty\",{\"1\":{\"13\":1,\"37\":1,\"41\":4,\"44\":3,\"46\":1}}],[\"no\",{\"1\":{\"39\":2,\"44\":2}}],[\"nosql\",{\"1\":{\"13\":1}}],[\"nodejs\",{\"1\":{\"6\":1}}],[\"node\",{\"1\":{\"4\":6,\"6\":4}}],[\"note\",{\"1\":{\"19\":1}}],[\"not\",{\"1\":{\"4\":1,\"39\":3,\"41\":2,\"44\":2,\"48\":1}}],[\"n\",{\"1\":{\"4\":1,\"37\":1}}],[\"db\",{\"0\":{\"50\":1}}],[\"during\",{\"1\":{\"44\":1}}],[\"duplicate\",{\"1\":{\"41\":1}}],[\"dispatcher\",{\"1\":{\"40\":1}}],[\"defaultasyncsenderexecutor\",{\"1\":{\"46\":2}}],[\"defaulttopicqueuenums\",{\"1\":{\"39\":1}}],[\"default\",{\"1\":{\"37\":1,\"41\":4,\"44\":1,\"46\":1}}],[\"defaultmqproducerimpl\",{\"0\":{\"41\":1,\"44\":1,\"46\":1},\"1\":{\"39\":5,\"40\":3,\"41\":1,\"43\":1,\"44\":3,\"46\":2}}],[\"defaultmqproducer\",{\"0\":{\"39\":1,\"40\":1,\"43\":1,\"45\":1},\"1\":{\"37\":2,\"38\":2,\"39\":3,\"40\":1,\"41\":10,\"44\":8,\"46\":9}}],[\"devops\",{\"1\":{\"13\":2}}],[\"dev\",{\"1\":{\"6\":3,\"9\":2}}],[\"deprecated\",{\"1\":{\"4\":1}}],[\"d\",{\"1\":{\"4\":1,\"44\":2}}],[\"doc\",{\"1\":{\"28\":1}}],[\"docs\",{\"0\":{\"51\":1},\"1\":{\"1\":1,\"9\":4}}],[\"does\",{\"1\":{\"4\":1}}],[\"dark\",{\"1\":{\"3\":1,\"10\":1}}],[\"level\",{\"1\":{\"46\":1}}],[\"length\",{\"1\":{\"45\":3}}],[\"legacy\",{\"1\":{\"6\":2}}],[\"lastbrokername\",{\"1\":{\"44\":2}}],[\"long\",{\"1\":{\"44\":7,\"46\":2}}],[\"locksupport\",{\"1\":{\"19\":1}}],[\"locks\",{\"1\":{\"19\":2}}],[\"log\",{\"0\":{\"4\":1},\"1\":{\"31\":1,\"32\":2,\"40\":1,\"41\":1,\"44\":10}}],[\"logo\",{\"1\":{\"3\":1}}],[\"list里\",{\"1\":{\"45\":1}}],[\"list<byte\",{\"1\":{\"45\":1}}],[\"list<message>\",{\"1\":{\"45\":2}}],[\"list\",{\"1\":{\"45\":2,\"46\":1}}],[\"linkedtransferqueue\",{\"1\":{\"19\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"46\":1}}],[\"linkedblockingqueue\",{\"1\":{\"19\":1}}],[\"linkedblockingdeque\",{\"1\":{\"19\":1}}],[\"link\",{\"1\":{\"6\":2}}],[\"light\",{\"1\":{\"3\":1,\"10\":1}}],[\"黑模式\",{\"1\":{\"3\":1}}],[\"一一对应\",{\"1\":{\"41\":1}}],[\"一一对应的\",{\"1\":{\"41\":1}}],[\"一条消息可以被所有\",{\"1\":{\"32\":1}}],[\"一堆原子类组成的包\",{\"1\":{\"19\":1}}],[\"一堆折腾之后\",{\"1\":{\"4\":1}}],[\"一直要等到从库完成数据同步才会返回给客户端\",{\"1\":{\"17\":1}}],[\"一些零碎内容\",{\"1\":{\"13\":1}}],[\"一些简单的\",{\"1\":{\"13\":1}}],[\"一张图需要两种风格对应白\",{\"1\":{\"3\":1}}],[\"一个消费组可以包含多个消费者\",{\"1\":{\"32\":1}}],[\"一个线程调用\",{\"1\":{\"26\":1}}],[\"一个特定\",{\"1\":{\"26\":1}}],[\"一个是仓库本身关于\",{\"1\":{\"4\":1}}],[\"一个\",{\"1\":{\"3\":2,\"39\":1,\"41\":1}}],[\"格式背景图\",{\"1\":{\"3\":1}}],[\"fix\",{\"1\":{\"46\":1}}],[\"final\",{\"1\":{\"39\":4,\"41\":1,\"44\":4,\"46\":11}}],[\"few\",{\"1\":{\"27\":1}}],[\"flexible\",{\"1\":{\"27\":1}}],[\"faqurl\",{\"1\":{\"41\":4,\"44\":4}}],[\"failed\",{\"1\":{\"40\":1,\"41\":2,\"44\":2,\"45\":1}}],[\"factory\",{\"1\":{\"27\":1}}],[\"false\",{\"1\":{\"10\":1,\"39\":1,\"44\":3,\"46\":2}}],[\"favicon\",{\"1\":{\"3\":1}}],[\"ffeaec\",{\"1\":{\"10\":1}}],[\"from\",{\"1\":{\"4\":1}}],[\"found\",{\"1\":{\"44\":1,\"48\":1}}],[\"format\",{\"1\":{\"44\":5}}],[\"for\",{\"1\":{\"4\":1,\"27\":2,\"37\":1,\"44\":1,\"45\":3}}],[\"following\",{\"1\":{\"4\":1}}],[\"futures\",{\"1\":{\"27\":1}}],[\"futuretask\",{\"1\":{\"27\":1}}],[\"future\",{\"0\":{\"1\":1},\"1\":{\"19\":1}}],[\"学习和调试的记录\",{\"1\":{\"2\":1}}],[\"考虑将\",{\"1\":{\"1\":1}}],[\"博客性质的内容越来越少\",{\"1\":{\"12\":1}}],[\"博客\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,wt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,k[s],n)):e==="search"?self.postMessage(et(t,k[s],n)):self.postMessage({suggestions:st(t,k[s],n),results:et(t,k[s],n)})};
//# sourceMappingURL=index.js.map
