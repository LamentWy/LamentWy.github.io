const L=Object.entries,st=Object.fromEntries,nt="ENTRIES",T="KEYS",R="VALUES",_="";class k{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const D=g!==t[F],w=o[p+F]+ +D,A=o[p+F+1]+1,z=o[m+F]+1,V=o[m+F+1]=Math.min(w,A,z);V<l&&(l=V)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new k(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new k(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new k(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",N="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},X=Symbol("*"),At=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=dt[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){gt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],D=at(y,m,e._documentCount,F,p,r),w=n*a*f*D,A=d.get(l);if(A){A.score+=w,lt(A.terms,t);const z=H(A.match,s);z?z.push(c):A.match[s]=[c]}else d.set(l,{score:w,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);B(e,t.term,l,F,f,o,u,d,g)}return g},Q=(e,t,s={})=>{if(t===X)return At(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Q(e,g,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===X&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class wt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new wt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>j(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),L(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},et=(e,t,s={})=>Et(t,e,{fuzzy:.2,...s}).map(({suggestion:n})=>n),v=st(L(JSON.parse("{\"/\":{\"documentCount\":125,\"nextId\":125,\"documentIds\":{\"0\":\"1\",\"1\":\"1#future\",\"2\":\"2\",\"3\":\"2#todo-list\",\"4\":\"2#debug-log\",\"5\":\"2#部署\",\"6\":\"2#vuepress-简介\",\"7\":\"2#插件\",\"8\":\"2#主题\",\"9\":\"2#命令\",\"10\":\"2#样式相关\",\"11\":\"2#功能\",\"12\":\"3\",\"13\":\"3#知识库内容\",\"14\":\"4\",\"15\":\"5\",\"16\":\"6\",\"17\":\"7\",\"18\":\"8\",\"19\":\"8#基础逻辑\",\"20\":\"8#同步模式\",\"21\":\"8#全同步模式\",\"22\":\"8#半同步模式\",\"23\":\"9\",\"24\":\"9#文档翻译\",\"25\":\"9#memory-consistency-properties\",\"26\":\"9#concurrent-collections\",\"27\":\"9#synchronizers\",\"28\":\"9#timing\",\"29\":\"9#queues\",\"30\":\"9#executor\",\"31\":\"9#具体实现\",\"32\":\"9#reference\",\"33\":\"10\",\"34\":\"11\",\"35\":\"12\",\"36\":\"12#broker-概述\",\"37\":\"12#broker-的-pom-xml\",\"38\":\"12#启动类\",\"39\":\"12#启动流程\",\"40\":\"12#注册到-namesrv-list\",\"41\":\"12#核心功能-接收消息\",\"42\":\"12#sendmessageprocessor\",\"43\":\"12#总结\",\"44\":\"13\",\"45\":\"13#基础概念\",\"46\":\"13#消费模式\",\"47\":\"13#消费者-consumer\",\"48\":\"13#消费组-consumergroup\",\"49\":\"13#messagemode-消息模式\",\"50\":\"13#集群模式-负载均衡\",\"51\":\"13#消费位点-consuming-point\",\"52\":\"13#订阅关系-订阅关系一致\",\"53\":\"13#源码分析\",\"54\":\"13#消费端的实现类\",\"55\":\"13#consumer-启动流程\",\"56\":\"13#consumemessageservice\",\"57\":\"13#pullmessageservice\",\"58\":\"13#负载均衡\",\"59\":\"13#消息确认\",\"60\":\"13#总结\",\"61\":\"14\",\"62\":\"14#主从同步\",\"63\":\"14#机制概述\",\"64\":\"14#step1\",\"65\":\"14#step2\",\"66\":\"14#step3-step4\",\"67\":\"14#haservice\",\"68\":\"14#haconnection\",\"69\":\"14#主从切换\",\"70\":\"14#元数据同步\",\"71\":\"14#slave-自动同步元数据\",\"72\":\"14#消费进度同步\",\"73\":\"14#总结\",\"74\":\"15\",\"75\":\"15#什么是-rocketmq\",\"76\":\"15#基本架构\",\"77\":\"15#大致流程\",\"78\":\"15#前置要求\",\"79\":\"16\",\"80\":\"16#概述\",\"81\":\"16#namesrv-的基本组成介绍\",\"82\":\"16#源码分析\",\"83\":\"16#启动流程\",\"84\":\"16#检测心跳\",\"85\":\"16#_10分钟打印一次配置信息\",\"86\":\"16#routeinfomanager\",\"87\":\"16#五个数据表介绍\",\"88\":\"16#topicqueuetable\",\"89\":\"16#注册-更新-broker-信息\",\"90\":\"16#注销-删除-broker-信息\",\"91\":\"17\",\"92\":\"17#前置要求\",\"93\":\"17#源码分析\",\"94\":\"17#从发送消息开始\",\"95\":\"17#producer-start\",\"96\":\"17#defaultmqproducer\",\"97\":\"17#defaultmqproducer-start\",\"98\":\"17#defaultmqproducerimpl-start\",\"99\":\"17#producer-send-message-msg\",\"100\":\"17#defaultmqproducer-send-message-msg\",\"101\":\"17#defaultmqproducerimpl-send-message-msg\",\"102\":\"17#defaultmqproducer-batch\",\"103\":\"17#defaultmqproducerimpl\",\"104\":\"17#总结\",\"105\":\"18\",\"106\":\"18#消息存储模块的设计概要与分析\",\"107\":\"18#常见持久化-存储方案简介\",\"108\":\"18#rocketmq-的持久化设计\",\"109\":\"18#存储模块的目录结构\",\"110\":\"18#commitlog\",\"111\":\"18#consumequeue\",\"112\":\"18#index-file\",\"113\":\"18#checkpoint\",\"114\":\"18#核心机制\",\"115\":\"18#commitlog-刷盘\",\"116\":\"18#consumequeue-刷盘\",\"117\":\"18#consumequeueext\",\"118\":\"18#indexfile-刷盘\",\"119\":\"18#文件恢复\",\"120\":\"18#transientstorepool-机制\",\"121\":\"18#总结\",\"122\":\"18#reference\",\"123\":\"19\",\"124\":\"20\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,3],\"1\":[1,7],\"2\":[1,11],\"3\":[2,170],\"4\":[2,25],\"5\":[1,13],\"6\":[2,65],\"7\":[1,33],\"8\":[1,5],\"9\":[1,16],\"10\":[1,28],\"11\":[1,19],\"12\":[1,11],\"13\":[1,79],\"14\":[1],\"15\":[1],\"16\":[1],\"17\":[2],\"18\":[1],\"19\":[1,24],\"20\":[1],\"21\":[1,7],\"22\":[1,8],\"23\":[4,75],\"24\":[1,17],\"25\":[3,20],\"26\":[2,41],\"27\":[1,7],\"28\":[1,11],\"29\":[1,4],\"30\":[1,39],\"31\":[1,50],\"32\":[1,3],\"33\":[1],\"34\":[2],\"35\":[3,12],\"36\":[2,9],\"37\":[4,28],\"38\":[1,7],\"39\":[1,116],\"40\":[3,74],\"41\":[2,85],\"42\":[1,154],\"43\":[1,14],\"44\":[3,10],\"45\":[1,6],\"46\":[1,51],\"47\":[2,21],\"48\":[2,11],\"49\":[2,26],\"50\":[2,13],\"51\":[4,21],\"52\":[2,22],\"53\":[1,9],\"54\":[1,20],\"55\":[2,279],\"56\":[1,214],\"57\":[1,484],\"58\":[1,261],\"59\":[1,54],\"60\":[1,36],\"61\":[4,25],\"62\":[1,24],\"63\":[1,32],\"64\":[1,108],\"65\":[1,85],\"66\":[2,151],\"67\":[1,240],\"68\":[1,62],\"69\":[1,172],\"70\":[1,28],\"71\":[2,64],\"72\":[1,17],\"73\":[1,19],\"74\":[3],\"75\":[2,10],\"76\":[1,36],\"77\":[1,102],\"78\":[1,7],\"79\":[3,7],\"80\":[1,50],\"81\":[2,65],\"82\":[1,4],\"83\":[1,37],\"84\":[1,289],\"85\":[1,5],\"86\":[1,6],\"87\":[1,60],\"88\":[1,69],\"89\":[4,385],\"90\":[4,34],\"91\":[3,25],\"92\":[1,6],\"93\":[1,2],\"94\":[1,59],\"95\":[3,7],\"96\":[1,116],\"97\":[3,30],\"98\":[3,229],\"99\":[5,9],\"100\":[5,24],\"101\":[5,258],\"102\":[3,137],\"103\":[1,257],\"104\":[1,11],\"105\":[3,7],\"106\":[1,5],\"107\":[2,27],\"108\":[2,74],\"109\":[1,24],\"110\":[1,247],\"111\":[1,141],\"112\":[2,170],\"113\":[1,15],\"114\":[1,20],\"115\":[2,360],\"116\":[2,322],\"117\":[1,10],\"118\":[2,3],\"119\":[1,118],\"120\":[2,30],\"121\":[1,6],\"122\":[1,8],\"123\":[1,3],\"124\":[1]},\"averageFieldLength\":[1.632,65.35922143734642],\"storedFields\":{\"0\":{\"h\":\"博客\",\"t\":[\"这里发布一些杂七杂八，就不分类了。\"]},\"1\":{\"h\":\"Future\",\"t\":[\"考虑将 docs/blog 分开发布，blog 单独发布到子域名下，通过导航跳转。\"]},\"2\":{\"h\":\"本站调试记录\",\"t\":[\"包括 vuepress 以及主题 vuepress-theme-hope 学习和调试的记录。\",\"内容是倒序的，建议使用方式：ctrl+f找关键字，或者右上角搜索本站。\"]},\"3\":{\"h\":\"TODO List\",\"t\":[\" logo & favicon：一个 svg，一个 ico。\",\"等小马哥有空的。\",\" svg 格式背景图，一张图需要两种风格对应白/黑模式，a1-light/a1-dark，*10。\",\"等小马哥有空的。\",\" 首页设计\",\"这个就任重道远了。\",\" 添加 analytics\",\"谷歌顺利添加了，但是百度检测不到，我自己打开开发者工具也没找到 hm.js，不过就先这样吧， 反正浏览量最高的两篇分别是雷蛇键盘无响应和lastPass密码错误，目前还被我下了。\",\"话说我真的觉得雷蛇那个看起来吊炸天的内置在设备里主动帮你安装驱动功能最大的作用是检测你这把键盘用多久了， 到期就给你自动失灵。 lastPass 早几年前就修正了我说的问题，下了就下了吧。\",\" 启用 tasklist 来记录调试工作\",\" 调整首页按钮跳转和文档结构\",\" 关闭右侧目录的打印按钮\",\" 研究路径导航 (breadcrumb)，看能不能去掉无用的目录路径，只显示文档关系路径\",\"合理利用 README.md 即可达成目标，breadcrumb 反而不用去管他，反正默认启用。\",\" 目录自动生成，没有README.md时自动目录可用，但是 <AutoCatalog/> 似乎不好使。\",\"插件更新了，标签改为: <Catalog>，用法跟之前一样，直接在目录页面的 md 文件正文写 <Catalog/>即可。\",\" 插件使用错误\",\"You are not allowed to use plugin \\\"vuepress-plugin-search-pro\\\" yourself in vuepress config file. Set \\\"plugin.searchPro\\\" in theme options to customize it. \",\"不要在 config.ts 中引入,把 import { searchProPlugin } from \\\"vuepress-plugin-search-pro\\\"; 移动到 theme.ts 中。\",\"找到 plugins:，然后添加searchPro: true, 即可启用。\",\" 自动侧边栏显示文件路径而非 title\",\"README.md 文件名必须大写，不然 hope 主题提供的一些插件功能不太正常。\",\" 部署中的警告\",\"Node.js 16 actions are deprecated. Please update the following actions to use Node.js 20: pnpm/action-setup@v2, actions/setup-node@v3. For more information see: https://github.blog/changelog/2023-09-22-github-actions-transitioning-from-node-16-to-node-20/. \",\"看见这个就去升级一下对应 action 的版本，不知道具体版本可以直接 github 搜索。\",\"比如 pnpm/action-setup@v2 就直接搜 pnpm/action-setup，其他细节参考警告中给的链接。\",\" build 失败\",\"pnpm docs:dev 没有问题，执行 build 就报 SyntaxError: The requested module 'vue-router' does not provide an export named 'createMemoryHistory'的错误。\",\"错误的表面意思倒是挺明确的，vue-router 没有提供 createMemoryHistory 参数，然而 由于完全不懂 node 跟没看懂没差别，一堆折腾之后，最后通过手动添加依赖解决了。\",\"pnpm add -D vue-router。\",\"真的不明白 node 这依赖关系设计，前端开发是怎么忍下来的。\"]},\"4\":{\"h\":\"debug log\",\"t\":[\"关缓存！！！\",\"前后重新发布了 n 次也没找到线上显示错误的原因，就差直接页面里面手动记录版本号了，突然记起怕不是 CL 的缓存没关...\",\"现在不用手动清缓存了，可以直接开启开发者模式禁用缓存，不用怕忘了关，这个功能是“暂时”绕过缓存，3个还是四个小时后会自动恢复到正常模式，需要的时候记得去开就好。\",\"github action\",\"权限错误检查两个位置，一个是仓库本身关于 action 的权限，另一个检查你生成的 PAT 权限是不是不够。\"]},\"5\":{\"h\":\"部署\",\"t\":[\"官方文档里就有，还挺全的，白写了，看这里。\",\"源码库 + 部署库的方式自动部署的几个需要注意的地方。\",\"PAT 权限要够，PAT 要添加到源码库的 Secrets 中。\"]},\"6\":{\"h\":\"vuepress 简介\",\"t\":[\"目录有约定，但并不强制\",\"0开发经验上手略有门槛\",\"有开发经验的体验尚可，有前端经验很好，有 nodejs/vue 经验的话你可以干很多事情。\",\"导航的 link 与 readme.md 文件绑定/readme.md 等同于 /，导航 link: '/xDir/ 意味着 /xDir/ 目录下必须有 readme.md文件，否则你点击导航会 404.\",\"依赖问题导致无法 build | build 失败\",\"根据我解决问题过程中搜索到的内容来看，依赖问题已经多次导致用户的 vuepress 项目无法正常 build。 对于对 node 依赖管理完全不了解的用户其实这是很难自行解决。\",\"先添加这个：\",\"yarn add cross-env --dev \",\"然后编辑 package.json 中的脚本部分:\",\" #package.json: \\\"scripts\\\": { \\\"dev\\\": \\\"cross-env NODE_OPTIONS=--openssl-legacy-provider vuepress dev src\\\", \\\"build\\\": \\\"cross-env NODE_OPTIONS=--openssl-legacy-provider vuepress build src\\\" } \",\"或者直接换 pnpm，反正不懂 node，用 yarn 还是用 pnpm 都没啥区别，但是 VuePress 和 VuePress-theme-hope 都是用 pnpm 进行管理的。\"]},\"7\":{\"h\":\"插件\",\"t\":[\"找插件/主题推荐使用vuepress-tools;\",\"使用方式通用流程：1. 安装插件 2.在.vuepress/config.js中添加插件并配置。\",\"@vuepress/开头的都是官方维护的插件，同时使用前注意插件支持哪个 VuePress 的版本（0.x 1.x 2）。\",\"@vuepress/plugin-back-to-top回到最上。\",\"官方没写说明也没写配置，扫了一眼代码，似乎是300行以上触发。\",\"拖了个以前写的 rocketMQ 分析源码的笔记测试了一下，右下角会自动出现一个向上的箭头。\",\"@vuepress/plugin-medium-zoom图片缩放\",\"点点看\",\"whale balloon\"]},\"8\":{\"h\":\"主题\",\"t\":[\"Hope 主题自带创建项目的脚手架，创建出的项目还自带文档，你可以在另外一个端口额外启动一个当说明书看。\"]},\"9\":{\"h\":\"命令\",\"t\":[\"创建\",\"pnpm create vuepress-theme-hope my-docs \",\"使用\",\"// 启动开发服务器 pnpm docs:dev // 构建项目并输出 pnpm docs:build // 清除缓存并启动开发服务器 pnpm docs:clean-dev \"]},\"10\":{\"h\":\"样式相关\",\"t\":[\"基本围绕着 src/.vuepress/styles 目录下的三个文件进行自定义。\",\"主题颜色覆盖src/.vuepress/styles/palette.scss文件中进行修改。\",\"其中 $theme-color: #82a6b1; 主题颜色影响各种高亮位置。 明暗切换如下:\",\"$bg-color: ( light: #ffeaec, dark: #343f3e, ); \",\"其他更多可以参考该主题的说明文档-样式配置部分，从颜色调整到布局设置啥的很全。\",\"隐藏打印按钮\",\"src/.vuepress/theme.ts中添加 print:false,\"]},\"11\":{\"h\":\"功能\",\"t\":[\"自动创建readme.md\",\"目录下没有readme.md时，会自动生成一个目录页面，该页面标题就是目录本身，外带自动驼峰。\",\"比如 mq/rocketmq/下没有手动创建readme.md时，它自动生成一个标题为 Rocketmq的目录页面。\\n如果是 rocket-mq/，则生成 RocketMq 作为标题。\"]},\"12\":{\"h\":\"更新计划列表\",\"t\":[\"近几年技术文章写的越来越多，博客性质的内容越来越少，于是打算放弃 Jekyll，投奔 VuePress。\",\"最近在整理积攒下的笔记和草稿，打算趁着切换 VuePress 的机会，逐步整理出一个自己的线上知识库。\"]},\"13\":{\"h\":\"知识库内容\",\"t\":[\"语言 以 Java 为主，其他语言等 Java 整理完再说。\",\"Java 基础部分只更新重要的基础知识点，JUC，框架部分则只更新 Spring 和 SpringBoot 中自认为比较核心的内容。 基础：注解 泛型 异常 反射 SPI ，集合更一部分，Java 的版本迭代线。\",\"JUC 就主要是 AQS + 线程池 + 工具类 + 并发集合类，顺便加一篇前置内容，把 Synchronized 这些简单介绍下。\",\"SpringCloud 系列放入微服务部分更新。\",\"JVM 部分：JVM 模型，GC，调试工具。\",\"数据库\",\"数据库就粗略的分为 SQL 和 noSQL 两类，前期主要更新 MySQL 和 Redis。\",\"中间件 这部分还没想好，就比如 Redis，你既可以把它看成数据库也可以用作缓存。 目前消息队列是单独更新。\",\"IO IO 的内容也单独更新，包括介绍 IO 类型、IO 的演进，然后是 netty 这个框架，顺便加入一些操作系统的知识点，比如内存。 网络的内容也考虑放这里。\",\"微服务\",\"服务注册/发现，网关，负载均衡，监控。\",\"devOps 一些简单的 devOps 实践。从开发工具到 CICD。\",\"方法论\",\"算法 还没想好怎么更。\",\"未分类\\n一些零碎内容。\"]},\"14\":{\"h\":\"Guide\"},\"15\":{\"h\":\"数据库\"},\"16\":{\"h\":\"消息队列\"},\"17\":{\"h\":\"MySQL 文档目录\"},\"18\":{\"h\":\"MySQL主从复制\"},\"19\":{\"h\":\"基础逻辑\",\"t\":[\"所有的主从逻辑基本上都是把数据从主服务器同步到从服务器。\",\"MySQL 也一样， 主库 上数据变化会写入二进制文件，binlog，中，然后通过IO把 binlog 的内容写入从库的中继日志中，然后从库从中继日志中读取并执行其中的 SQL语句 完成同步。\",\"主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。\",\"binlog 线程\",\"负责将主库上的数据更改写入 binlog 中。\",\"I/O 线程\",\"负责从主服务器上读取 binlog，并写入从库的中继日志中。\",\"SQL 线程\",\"负责读取中继日志并重放其中的 SQL 语句。\"]},\"20\":{\"h\":\"同步模式\"},\"21\":{\"h\":\"全同步模式\",\"t\":[\"主库在写入 binlog 之后直接开始强制同步到从库，一直要等到从库完成数据同步才会返回给客户端，性能较差，非常少见。\"]},\"22\":{\"h\":\"半同步模式\",\"t\":[\"半同步跟全同步的区别是，在IO那一步中继日志写入完成就给主库发个确认消息，主库 只要收到任意一个从库（假设一主多从）返回的确认消息就认为本次写操作成功，返回给客户端。\"]},\"23\":{\"h\":\"java.util.concurrent 简介\",\"t\":[\"平时说 JUC ，通常默认为以下三个包的统称： java.util.concurrent， java.util.concurrent.atomic， java.util.concurrent.locks。\",\"大体可以分为以下几个部分：\",\"locks 包含 AQS, LockSupport ，以及基于 AQS 的锁实现：ReentrantLock,ReentrantReadWriteLock 等。\",\"原子类 atomic 一堆原子类组成的包，可以看作是工具包，主要用来支持对变量进行非阻塞的线程安全编程。\",\"同步辅助类\",\"CountDownLatch（赛车），CyclicBarrier（厨房），Phaser（前面二者的加强版），Semaphore（信号量），Exchanger（这个是线程之间交换变量值的）\",\"线程执行和管理\",\"Future ：代表异步计算的返回结果。\",\"Executor, ExecutorService ：线程任务的执行，执行各种已提交的 Runnable 任务. （Note: 线程的设计把执行机制和执行内容分开，各种 Runnable,Callable 任务就是执行内容，而执行机制，也就是具体如何执行 task 交给 Executor）。\",\"ThreadPoolExecutor： 线程池版Executor，它的基本逻辑是从线程池里获取线程，然后执行。\",\"Executers： 工具类，他是 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和工具方法的合集。\",\"并发集合 ArrayBlockingQueue，ConcurrentHashMap，ConcurrentLinkedDeque，ConcurrentLinkedQueue，ConcurrentSkipListMap，ConcurrentSkipListSet\",\"CopyOnWriteArrayList CopyOnWriteArraySet\",\"LinkedBlockingDeque LinkedBlockingQueue LinkedTransferQueue\",\"PriorityBlockingQueue 等等\"]},\"24\":{\"h\":\"文档翻译\",\"t\":[\"java.util.concurrent，简称JUC，是 Java 为并发编程提供的标准化可扩展的框架。\",\"主要组件包括以下部分：Executor、Queues、Timing、Synchronizers、concurrent Collections、Memory Consistency Properties。\"]},\"25\":{\"h\":\"Memory Consistency Properties\",\"t\":[\"内存一致性属性，文档中这部分实际上就是介绍了一下 juc 包中如何实践 happen-before 原则和一些例子。 比如“线程必须事先将元素放入并发集合类中”这个动作happen-before于“线程从并发集合类中访问/删除这个元素”。 详见文档，如果还是对 happen-before 不理解，请重新阅读之前关于 happen-before 以及 偏序关系的介绍。\"]},\"26\":{\"h\":\"concurrent Collections\",\"t\":[\"并发集合类，就是用于并发环境下的集合类，比如 ConcurrentHashMap 可以看成是同步版本的 HashMap，ConcurrentSkipListMap 同步版本的 TreeMap等等。\",\"包中的很多类都带有 concurrent 前缀，它的含义不仅仅是线程安全，还可以“并发”访问。\",\"比如我们可以通过Collections.synchronizedMap(new HashMap())来保证 hashMap 线程安全，但它不是 concurrent 的，因为这里 hashMap 只是通过排它锁，以阻塞同步的方式来保证了线程安全，本质上同一时间只有一个线程访问它并没有并发concurrent。 而并发集合类，比如ConcurrentHashMap则是在特定情况下可以允许任意数量线程并发读取 or 可控数量线程并发写入，同时还保证线程安全。\",\"所以阅读这部分源码or文档时需要注意 synchronized 和 concurrent 的区别，Collections.synchronizedMap(new HashMap())是同步的（synchronized），ConcurrentHashMap 是并发的（concurrent）。\"]},\"27\":{\"h\":\"Synchronizers\",\"t\":[\"主要是五个常见场景的同步器：Semaphore、CountDownLatch、CyclicBarrier、Phaser、Exchanger。\"]},\"28\":{\"h\":\"Timing\",\"t\":[\"主要就是 TimeUnit 类，提供了基于不同时间粒度的操作方法，比如 sleep wait join 啥的。同时附带了一堆时间转换的方法以及时间单位的定义。\"]},\"29\":{\"h\":\"Queues\",\"t\":[\"这部分提供了阻塞/非阻塞的各种线程安全队列。 详情看文档。\"]},\"30\":{\"h\":\"Executor\",\"t\":[\"Executor 是个非常简单的标准化接口，只有一个方法 void execute(Runnable command);，它可以用来定义线程池、异步IO、轻量级任务框架这类型的线程类子系统。\",\"一个特定/具体的 Executor 实现可以是正在创建 Thread，或者是一个正在执行中的 Executor ，或者是 一个线程调用 execute()方法（异步 or 顺序执行）。\",\"可以通过 JUC 包内的例子来理解上面的定义。\",\"以异步任务执行框架为例，ExecutorService (interface ExecutorService extends Executor)在 Executor 基础上进行扩展，通过提供线程状态方法、任务的提交关闭调用等方法，定义了一个异步任务执行框架。\",\"更进一步 ScheduledExecutorService 接口，它通过继承 ExecutorService 接口进一步扩展出了延迟任务和周期任务的执行。\"]},\"31\":{\"h\":\"具体实现\",\"t\":[\"Classes ThreadPoolExecutor and ScheduledThreadPoolExecutor provide tunable, flexible thread pools. The Executors class provides factory methods for the most common kinds and configurations of Executors, as well as a few utility methods for using them. Other utilities based on Executors include the concrete class FutureTask providing a common extensible implementation of Futures, and ExecutorCompletionService, that assists in coordinating the processing of groups of asynchronous tasks.\"]},\"32\":{\"h\":\"reference\",\"t\":[\"oracle java8 doc\"]},\"33\":{\"h\":\"JUC\"},\"34\":{\"h\":\"RocketMQ 文档目录\"},\"35\":{\"h\":\"RocketMQ 源码分析-Broker\",\"t\":[\"Broker 作为消息队列的核心，它的职责很多，并且与消息生产者、消息消费者、Namesrv、持久化、ACL等均有关系。本篇只简单介绍什么是 Broker，让读者对 Broker 有个大概认识即可，\"]},\"36\":{\"h\":\"Broker 概述\",\"t\":[\"Broker 是 RocketMQ 的核心，它负责消息的传递、消息路由信息的生成、持久化、ACL等等。\"]},\"37\":{\"h\":\"Broker 的 pom.xml\",\"t\":[\"可以看到作为消息队列的核心模块，Broker 在依赖中引入了相当多的模块，这里只需要知道每个模块大致功能的即可，记不住就分别写上注释。\",\"注\",\"懒得一个个点开看，可以直接打印依赖树去看。\",\"通过阅读 pom.xml 我们可以知道 Broker 也是基于 Netty 的（rocketmq-remoting），可以 知道它包含持久化功能 rocketmq-store，它还包含 ACL 功能 rocketmq-acl 等等，这就 不详细罗列了。\"]},\"38\":{\"h\":\"启动类\",\"t\":[\"Java 项目找启动类最偷懒的办法就是搜索 main 方法，不过这里我们看文件名就能轻松定位到 BrokerStartup。\"]},\"39\":{\"h\":\"启动流程\",\"t\":[\"BrokerStartup::main --> BrokerStartup::createBrokerController --> BrokerStartup::start --> controller::start\",\"也就是进入 main 方法，然后创建 BrokerController （本质是个 netty server），同时按需初始化一堆东西，最后执行 controller.start()。\",\"接下来看 Broker 启动时具体做了什么：\",\"// BrokerController::start public void start() throws Exception { // 启动持久化 // 这部分在持久化篇展开 if (this.messageStore != null) { this.messageStore.start(); } // 启动 netty server // 持久化涉及到从文件系统恢复消息和消息写入文件系统等，所以要先启动持久化，后启动 netty server if (this.remotingServer != null) { this.remotingServer.start(); } // 启动 netty server // 与 remotingServer 二选一 if (this.fastRemotingServer != null) { this.fastRemotingServer.start(); } // 启动一个守护线程 监控文件列表 if (this.fileWatchService != null) { this.fileWatchService.start(); } // 启动一个 netty client，用于向外部发送请求 if (this.brokerOuterAPI != null) { this.brokerOuterAPI.start(); } // 启动一个守护线程 if (this.pullRequestHoldService != null) { this.pullRequestHoldService.start(); } // 启动一个单线程定时任务 // 同时 clientHousekeepingService 是一个跟 brokerController 绑定的 ChannelEventListener if (this.clientHousekeepingService != null) { this.clientHousekeepingService.start(); } // 同样是启动一个单线程定时任务 if (this.filterServerManager != null) { this.filterServerManager.start(); } // 非 DLedger CommitLog // 也就是高可用模式 if (!messageStoreConfig.isEnableDLegerCommitLog()) { startProcessorByHa(messageStoreConfig.getBrokerRole()); // 元数据同步 handleSlaveSynchronize(messageStoreConfig.getBrokerRole()); this.registerBrokerAll(true, false, true); } // 单线程定时任务，Broker 的信息注册到 NameSrv // 就是用前面的 brokerOuterAPI (netty client) 给 NameSrv list 发注册请求，默认10秒一次。 this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister()); } catch (Throwable e) { log.error(\\\"registerBrokerAll Exception\\\", e); } } }, 1000 * 10, Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), TimeUnit.MILLISECONDS); // ignore if (this.brokerStatsManager != null) { this.brokerStatsManager.start(); } // 单线程定时任务 // 快速失败模式下，用于清理无效请求 if (this.brokerFastFailure != null) { this.brokerFastFailure.start(); } } \",\"所以实际上 Broker 的启动就是读取配置，组装好各个组件，然后启动 Netty Server 提供服务。 同时启动一系列定时任务，其他组件，还有一个 netty client 用来与其他服务通信。\"]},\"40\":{\"h\":\"注册到 NameSrv List\",\"t\":[\"这里顺便看一下 broker 向 NameSrv 注册路由信息。\",\"BrokerController::doRegisterBrokerAll\",\"源码略过，可以看到注册流程是：首先组装 topicConfigWrapper 和 Broker 的基本信息(BrokerInfo)，然后使用 brokerOuterAPI::registerBrokerAll 向 namesrv 发注册请求。\",\"由于 NameSrv 可以是集群，brokerOuterAPI 使用了线程池配合 CountDownLatch 进行批量注册，返回所有注册结果registerBrokerResultList。 BrokerInfo 装入 requestHeader，Topic 信息装入 requestBody，请求类型为 RequestCode.REGISTER_BROKER，通过同步调用invokeSync的方式发起请求，拿到返回结果后解码并本地缓存。\",\"如果开启了 Broker 的高可用模式，则取出返回结果列表中第一条数据进行高可用模式的后续处理。这里逻辑实际上是反过来的，无论是否开启高可用模式，只要返回列表不为空就取出第一条结果，然后判断是否为高可用模式。\",\"首先会判断是否为高可用模式，并且要获取到HaServerAddr，满足条件则把 HaServerAddr 更新为 master。之后则是通用处理，其他 slave Broker 把 HaServerAddr 设置为自己的 master broker 的地址。\",\"最后则是进行“是否为顺序消息模式”的检查和更新。\",\"至此 NameSrv 中关于 Broker 如何注册的坑就填完了。同时也明确了， Broker 在启动时会把自己的 brokerInfo 和 Topic 信息同时注册到所有 NameSrv 上，并且默认每 10 秒会重新注册一次。由于高可用的相关逻辑也跟注册耦合在一起，因此 master broker 的设置和更新也是随注册触发。\"]},\"41\":{\"h\":\"核心功能：接收消息\",\"t\":[\"前面发送消息篇 里面我们了解了消息是如何发给 Broker 的，这里我们就来看看 Broker 是如何处理消息的。\",\"注\",\"涉及持久化的部分略过。\",\"定位代码\",\"对于 Broker 而言，接收客户端发来的消息，自然属于数据输入，再结合大家都基于 netty 进行通信， 那么回顾发送消息的底层代码，我们可以轻松发现这里的数据输入基本就是三种 RequestCode， SEND_MESSAGE，SEND_REPLY_MESSAGE_V2 | SEND_REPLY_MESSAGE （视为一种）， SEND_BATCH_MESSAGE。 也就是单向发送， 需要返回值的发送（包括同步、异步），批量发送。\",\"broker 接收到 request 后，首先他要对 request 进行解码并提取出 RequestCode，这样才能分辨是什么请求。因此我们去找 Broker 解码的部分。对于 netty 应用而言，解码器在 netty 语境就是一种 Handler，之前 NameSrv 中有提到，RocketMQ 习惯把 handler 都放在 processor 包里，所以可以去 processor 包里找。当然不是所有的 handler 都值得单独创建一个类，你也可以直接利用 IDE 的搜索功能直接在 rocketmq/broker 中搜索对应关键字，比如 SEND_MESSAGE ，简单粗暴。 再比如，RocketMQ 的命名方式， BrokerController，在传统 web 项目里，Controller 里会定义 一堆 RequestMapping，实际上 netty 应用中也可以通过自定义 handler 来实现类似的功能，所以 也可以在 Contoller 里找。\",\"到这一步就随你喜好了，办法很多，以上几个例子只是抛砖引玉。\"]},\"42\":{\"h\":\"SendMessageProcessor\",\"t\":[\"启动流程如果有认真看源码的话，在 createBrokerController 那一步中包含 controller.initialize(); 这么一个初始化方法，这个初始化方法中有一个步骤就是注册 processor， this.registerProcessor();。\",\"而这个 registerProcessor() 实际上就是把 RequestCode 和 handler/processor 以及 Executor（线程池）建立对应关系，有点儿类似 web 中的 RequestMapping。\",\"这里的 handler/processor 使用的是 processor 包下的 SendMessageProcessor。\",\"sendProcessor.registerSendMessageHook(sendMessageHookList); sendProcessor.registerConsumeMessageHook(consumeMessageHookList); \",\"从这一段可以看出，无论 Broker 接收到的是生产者的请求还是消费者的请求，都是 SendMessageProcessor 来处理。\",\"然后来看 SendMessageProcessor::processRequest 方法，它并没有对 request 进行分析， 而是直接传入 asyncProcessRequest()。\",\"asyncProcessRequest()方法中，只对 RequestCode.CONSUMER_SEND_MSG_BACK 一种请求做了区分， 其他的请求直接进入 default 分支，default 分支中也只区分了是否为批量发送，初步印证了之前\\\"发送消息\\\" 中的三种发送消息的方式对于 Broker 来说其实没啥区别。\",\"这里我们看非批量发送的处理逻辑 asyncSendMessage()，批量消息就是数据解码的时候批量解码然后遍历处理。\",\"asyncSendMessage() 方法比较长，里面混杂了一部分内部消息对象的组装、一部分 request 的解码、 还有 response 的组装等等。\",\"主要看方法最后那段即可:\",\"// asyncSendMessage() // transFlag 是事务消息的标记 （带这个属性就是事务消息 PROPERTY_TRANSACTION_PREPARED） if (transFlag != null && Boolean.parseBoolean(transFlag)) { //broker 未开启事务处理，直接拒绝 if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark( \\\"the broker[\\\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \\\"] sending transaction message is forbidden\\\"); return CompletableFuture.completedFuture(response); } // 事务消息的处理 putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner); } else { // 普通消息的处理 putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner); } // 最终返回 return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt); \",\"可以看到 Broker 会调用 messageStore::asyncPutMessage() 对消息进行持久化，也就是常说的刷盘。 在asyncPutMessage() 中，实际上真正去存放消息的是 commitLog.asyncPutMessage(msg);， 而 commitLog.asyncPutMessage(msg); 的主要工作首先是将收到的消息写入 mappedFile， 也就是 mappedFile.appendMessage(msg, ...);，之后刷盘 submitFlushRequest(...); 并返回。\",\"commitLog 这里的源码如果看着迷茫可以先跳过，等讲完持久化章节就很容易理解了，这里面涉及到了 mmap 和 RocketMQ 的文件系统设计，只看代码会很蒙，尤其是这项目木有注释。\",\"我们接着往下看最后的返回， handlePutMessageResultFuture(...)，方法就是给客户端返回响应的方法，主要工作就是等前面的异步调用都完成之后对 response 进行最后的封装，最终 writeAndFlush。\"]},\"43\":{\"h\":\"总结\",\"t\":[\"可以看到，Broker 本质就是一个 Netty Server，一个处理各种请求、返回响应的服务端。它提供/支持的其他功能，比如持久化、高可用等等，都是单独的模块，后面单独去讲。\"]},\"44\":{\"h\":\"RocketMQ 源码分析-消费消息\",\"t\":[\"RocketMQ 面向的场景很多，不同场景对消息队列的要求是不一样的，尤其是在消费环节。\",\"还是老样子，先介绍一些它的名词/基础概念，然后介绍消费相关的分类，最后跟着源码去看。\"]},\"45\":{\"h\":\"基础概念\",\"t\":[\"这部分可以直接看官方文档，有图，官方 4.x。\"]},\"46\":{\"h\":\"消费模式\",\"t\":[\"注\",\"注意跟后面的 消息模式 MessageModel 进行区分。\",\"推/拉两种模式都支持，本质上差别不大，你把 push 看成自动 pull 即可。\",\"push 在消息队列语境下，push 应该是服务端自动向 Consumer 推送消息。在 RocketMQ 语境下其实就是周期性的自动从 broker 拉取消息并存入 Consumer 本地队列，与此同时 Consumer 不断的从本地队列里取出消息进行处理。\",\"pull Consumer 主动从服务端的消息队列中拉取消息。\",\"无论哪种模式都要注意，既要避免消息在本地堆积，同时要注意消费间隔不能太长。\",\"除了推拉之外，在 Consumer 消费消息这个行为这一层，还支持顺序消费和并发消费。\",\"顺序消费 ConsumeMessageOrderly 顺序消费是在同一个队列上有序，并不是在 Topic 下全局有序，因为 Topic 通常都会有好几个队列。\",\"你可以通过设置 Topic 下只有一个队列来达成全局有序，牺牲队列本身的高可用，优势是不需要做额外的工作；也可以直接给消息加上全局自增的唯一ID的方式自行实现全局有序，就是实现方案比较麻烦，不过在分布式系统里你总能找到很多现成的功能拿来复用。\",\"顺序消费仅适用于集群模式。\",\"并发消费 就是以并发的方式消费消息。\"]},\"47\":{\"h\":\"消费者 Consumer\",\"t\":[\"可以从消息队列中消费消息的，都统一看作是消费者。 对于 Java 语境，RocketMQ 提供了 MQPushConsumer 和 MQPullConsumer 两个接口以及对应的实现类，以便用户可以快速创建 Consumer，亦或者是自行实现消费客户端。\",\"PUSH 模式的默认实现类：DefaultMQPushConsumer。\",\"PULL 模式的默认实现类：DefaultLitePullConsumer，另一个已弃用。\"]},\"48\":{\"h\":\"消费组 ConsumerGroup\",\"t\":[\"消费组由订阅相同 Topic 的消费者组成。也就是说 ConsumerGroup 和 Topic 一样必须唯一，而且要和 Topic 一一对应，参考订阅关系。\"]},\"49\":{\"h\":\"MessageMode 消息模式\",\"t\":[\"提示\",\"消息模式为非官方译名\",\"RocketMQ 提供了两种 MessageMode，集群模式和广播模式。\",\"集群模式 MessageModel.CLUSTERING ： 集群模式下，对 RocketMQ 而言，任意一条消息，只要被消费组内任意 Consumer 消费成功，该消息就被视为已消费。\",\"广播模式 MessageModel.BROADCASTING： 广播模式下，对 RocketMQ 而言，任意一条消息，需要被消费组内所有 Consumer 至少消费成功 1 次，该消息才被视为已消费。\"]},\"50\":{\"h\":\"集群模式-负载均衡\",\"t\":[\"集群模式下，消息消费的方式类似于“请求->网关->服务”的方式，所以在消息被消费之前可以加一层负载均衡来分配消息。\",\"目前 RocketMQ 提供了六种分配策略，默认为：AllocateMessageQueueAveragely。\"]},\"51\":{\"h\":\"消费位点 (consuming point)\",\"t\":[\"提示\",\"中英都是官方名称\",\"类似前几篇里我写的消费进度的概念，它代表客户端目前消费到队列中哪个位置。集群模式下 Consumer 会把消费位点提交给 Broker；广播模式下则由 Consumer 自行保存。\",\"Consumer 启动时有三种初始消费位点的选择：CONSUME_FROM_LAST_OFFSET、CONSUME_FROM_FIRST_OFFSET、CONSUME_FROM_TIMESTAMP。\",\"初始消费位点的值存储于:DefaultMQPushConsumer.consumeFromWhere。\"]},\"52\":{\"h\":\"订阅关系 && 订阅关系一致\",\"t\":[\"消费者组订阅 Topic+Tag，叫订阅关系。\",\"订阅关系一致：同一个消费者组下所有 Consumer 订阅的 Topic+Tag 必须完全一致。\",\"如果订阅关系不一致，会导致消费错乱和消息丢失。\",\"Consumer --n:1-- ConsumerGroup --1:1--> Topic + Tag。\",\"不想画图，详见官方文档-4.x-订阅关系一致。\"]},\"53\":{\"h\":\"源码分析\",\"t\":[\"主线逻辑是从 DefaultMQPushConsumer 入手，介绍 push/pull 的实现，集群和广播模式下的具体细节等。\"]},\"54\":{\"h\":\"消费端的实现类\",\"t\":[\"Consumer 跟 Producer 一样也是 Netty 客户端，相似逻辑不再解释。\",\"从源码可以看到，DefaultMQPullConsumer 和其内部实现类 DefaultMQPullConsumerImpl 已经被标注 Deprecated，PULL 模式目前默认为 DefaultLitePullConsumer。\",\"我们从 DefaultMQPushConsumer 开始。\"]},\"55\":{\"h\":\"Consumer 启动流程\",\"t\":[\"DefaultMQPushConsumer::start，这里面有一步设置消费组，重试组和 DLQ 命名空间的包装也会在这里进行，之后就是 defaultMQPushConsumerImpl.start();，如果开启消息追踪，那么还会启动 traceDispatcher.start();。\",\"然后来看 defaultMQPushConsumerImpl.start();：\",\"defaultMQPushConsumerImpl.start\",\"public synchronized void start() throws MQClientException { switch (this.serviceState) { case CREATE_JUST: // ... 省略日志 this.serviceState = ServiceState.START_FAILED; // 校验 Consumer 客户端配置，不清楚客户端配置的可以去看一眼 this.checkConfig(); // 这里做两件事 // 1. 把 defaultMQPushConsumer 中的订阅复制一份给 rebalanceImpl // 2. 如果是 MessageModel 是集群模式，那么创建 retryTopic，并再一复制订阅关系，一起添加到 rebalanceImpl this.copySubscription(); // InstanceName 校验，其实这一步可以放进 checkConfig()方法里 // 如果你的 InatanceName 是默认值，将修改为 PID+纳秒级时间戳 if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) { this.defaultMQPushConsumer.changeInstanceNameToPID(); } // 跟 Producer 一样，创建 netty 客户端 this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook); // 装配 rebalanceImpl ，关于 RebalanceImpl 后面再说，你知道他是个消费行为之前的负载均衡器即可 this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup()); this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel()); this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()); this.rebalanceImpl.setmQClientFactory(this.mQClientFactory); // 拉取消息 API 的包装器 // 无论pull or push 模式，都是 consumer 从 broker 上把消息拉回本地再进行处理 this.pullAPIWrapper = new PullAPIWrapper( mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode()); this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList); // 这里又来到一个 Deprecated 方法 // 这部分就是前文提到的消费位点的存储 if (this.defaultMQPushConsumer.getOffsetStore() != null) { this.offsetStore = this.defaultMQPushConsumer.getOffsetStore(); } else { // 根据消费模式判定 switch (this.defaultMQPushConsumer.getMessageModel()) { case BROADCASTING: // 广播模式本地存取，这里只初始化 offsetStore this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup()); break; case CLUSTERING: // 集群模式，消费位点要上传 broker，所以这里要从 broker 上拉 // 这里初始化 offsetStore this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup()); break; default: break; } // 给外部包装类初始化 offsetStore this.defaultMQPushConsumer.setOffsetStore(this.offsetStore); } // offsetStore 的具体类型取决于上面的代码， LocalFileOffsetStore or RemoteBrokerOffsetStore // LocalFileOffsetStore.load 就是从本地文件中取出消费位点 // 路径是 user.home/.rocketmq_offsets/clientID/groupName/offsets.json // 流程就是 读文件，然后 json 序列化为 wrapper 对象，然后把对象的值传给 offsetTable，顺带打印 load 日志 // 集群模式从 Broker 远程拉取，所以 RemoteBrokerOffsetStore::load 啥也不干。 this.offsetStore.load(); if (this.getMessageListenerInner() instanceof MessageListenerOrderly) { // 顺序消费 -> ConsumeMessageOrderlyService this.consumeOrderly = true; this.consumeMessageService = new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner()); } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) { // 并发消费 -> ConsumeMessageConcurrentlyService this.consumeOrderly = false; this.consumeMessageService = new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner()); } // ConsumeMessageOrderlyService 仅适用于集群模式 // 它会提交一个周期任务给 scheduledExecutorService（单线程），scheduledExecutorService 每 20 秒调用 rebalanceImpl().lockAll() 对远程队列上锁。 // ConsumeMessageConcurrentlyService // 提交一个周期任务给 cleanExpireMsgExecutors（单线程），每 15 分钟清理一次过期消息，避免消费卡住。 // 后面单独来看这俩 Service this.consumeMessageService.start(); // 就是把消费组和对应的 Consumer 存入 consumerTable boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this); if (!registerOK) { // 注册失败直接关闭 // ... } // 主要看这个方法 mQClientFactory.start(); log.info(\\\"the consumer [{}] start OK.\\\", this.defaultMQPushConsumer.getConsumerGroup()); this.serviceState = ServiceState.RUNNING; break; case RUNNING: case START_FAILED: case SHUTDOWN_ALREADY: throw new MQClientException(\\\"The PushConsumer service state not OK, maybe started once, \\\" + this.serviceState + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK), null); default: break; } // 从 NameSrv 更新路由信息，并存入 topicRouteTable this.updateTopicSubscribeInfoWhenSubscriptionChanged(); // 发送远程请求 RequestCode.CHECK_CLIENT_CONFIG this.mQClientFactory.checkClientInBroker(); this.mQClientFactory.sendHeartbeatToAllBrokerWithLock(); // 启动 rebalanceService this.mQClientFactory.rebalanceImmediately(); } \",\"mQClientFactory.start();\",\" this.serviceState = ServiceState.START_FAILED; // If not specified,looking address from name server if (null == this.clientConfig.getNamesrvAddr()) { this.mQClientAPIImpl.fetchNameServerAddr(); } // Start request-response channel // netty client this.mQClientAPIImpl.start(); // Start various schedule tasks this.startScheduledTask(); // Start pull service // 重点看 pullMessageService this.pullMessageService.start(); // Start rebalance service // rebalanceService 主要是定期执行 doRebalance // doRebalance 有三种实现方法，对应不同 Consumer 实现类 this.rebalanceService.start(); // Start push service this.defaultMQProducer.getDefaultMQProducerImpl().start(false); log.info(\\\"the client factory [{}] start OK\\\", this.clientId); this.serviceState = ServiceState.RUNNING; \",\"总结\",\"到这里启动就完成了，简单总结一下启动流程： 第一步，初始化和组装 rebalanceImpl 和 Consumer ； 第二步，载入消费位点，广播模式存在本地，集群模式存储在 broker； 第三步，初始化并启动 consumeMessageService，实现类有两个，顺序消费是 ConsumeMessageOrderlyService，并行消费是 ConsumeMessageConcurrentlyService； 第四步，把 Consumer 注册到 consumerTable； 最后启动 Consumer 和各种 Services。\",\"然后我们来看“消费”。\"]},\"56\":{\"h\":\"ConsumeMessageService\",\"t\":[\"消费这部分主要关注 ConsumeMessageService 和 PullMessageService这两块。\",\"ConsumeMessageService 前面已经看到了，它有顺序消费和并发消费两个实现类，这个 Service 主要职责就是负责消费消息。\",\"ConsumeMessageOrderlyService 顺序消费\",\"无论是哪个实现类，ConsumeMessageService 一定会有 consumeExecutor 属性，它是执行消费行为的线程/线程池，这里就统称执行器。private final ThreadPoolExecutor consumeExecutor;。\",\"ConsumeMessageOrderlyService 的 consumeExecutor 是一个包含 20 个线程的线程池，并发版本的也一样。\",\"this.consumeExecutor = new ThreadPoolExecutor( this.defaultMQPushConsumer.getConsumeThreadMin(), // core 20 this.defaultMQPushConsumer.getConsumeThreadMax(), // max 20 1000 * 60, TimeUnit.MILLISECONDS, this.consumeRequestQueue, // workQueue LinkedBlockingQueue new ThreadFactoryImpl(\\\"ConsumeMessageThread_\\\")); \",\"线程池有了，我们来看线程池要执行的任务： ConsumeRequest。\",\"代码太长还是大量省略，除了要看 run 方法外，要注意创建 ConsumeRequest 时，需要接收两个队列作为参数， processQueue 和 messageQueue。\",\"processQueue 暂且就简单理解为待消费的消息队列(local)，messageQueue 就是待拉取的消息队列(remote)。\",\"// ConsumeRequest::run public void run() { // 首先检查 processQueue.isDropped ... // 上锁，保证一个队列一次只被一个线程消费 final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue); synchronized (objLock) { // 分支判断 // 如果是广播模式 或者 processQueue 被锁住且锁未过期 则开始进行循环 for (boolean continueConsume = true; continueConsume;) { // 当成 while(continueConsume) 即可 // 再次 检查 processQueue.isDropped ，是则 break if(...){ log & break;} // 如果是集群模式 且 processQueue 未被锁住，则尝试重新上锁并重新消费 if(...){ // 这个方法就是 先对第一个参数 messageQueue 上锁， // 如果成功，则 10ms 后重新提交一个 ConsumeRequest 请求， // 如果不成功，则 3s 后重新提交一个 ConsumeRequest 请求。 ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); break } // 如果 集群模式 且 processQueue 锁过期，也是 tryLockLaterAndReconsume + break; 跟前面一样。 if(...){...} // 计算真实提交间隔 interval 当前时间 - beginTime，注意 beginTime 在循环外 long interval = System.currentTimeMillis() - beginTime; if (interval > MAX_TIME_CONSUME_CONTINUOUSLY /*60s*/) { // MAX_TIME_CONSUME_CONTINUOUSLY 是 rocketmq.client.maxTimeConsumeContinuously 的值。 ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10); break; } // 以上的四个 if + break 都是为了保证当前消息一定要被消费 // 然后是消息的批量处理 consumeMessageBatchMaxSize 默认为 1 // 从 processQueue.takeMessages 方法中就可以看出来， // 平时消息是存储于 msgTreeMap 中，只有顺序消费时才取出对应数量消息写入 consumingMsgOrderlyTreeMap List<MessageExt> msgs = this.processQueue.takeMessages(consumeBatchSize); // 创建并装配 ConsumeOrderlyContext 略 // 这里就是你自己实现的 Consumer.registerMessageListener 里面 // 注册并实现的 listener 的 consumeMessage 方法的调用。 // 换句话说这一步就是执行真正的消费 status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context); // 后面全部略 有兴趣可以自己看，就是一些后续处理 ... // 退出循环的条件就是 continueConsume == false； // 消费的最后一步， ack 消息 continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this); } // ... } // ... } \",\"由此我们可以知道顺序消费时，ProcessQueue 会从 msgTreeMap 中取出 batchSize（默认为 1）条消息存入 consumingMsgOrderlyTreeMap 并进行批量消费。\",\"目前执行器 consumeExecutor 和线程任务 ConsumeRequest 都有了，那么 ConsumeRequest 是如何提交给 consumeExecutor 的工作队列的呢？\",\"就是 ConsumeMessageOrderlyService::submitConsumeRequest 方法，非常简单，根据参数提供的俩 Queue 来创建一个 ConsumeRequest，然后直接提交。\",\"public void submitConsumeRequest( final List<MessageExt> msgs, final ProcessQueue processQueue, final MessageQueue messageQueue, final boolean dispathToConsume) { if (dispathToConsume) { ConsumeRequest consumeRequest = new ConsumeRequest(processQueue, messageQueue); this.consumeExecutor.submit(consumeRequest); } } \",\"至此，围绕 consumeExecutor 的基本要素已经凑齐。\",\"接下来我们要来看消息是怎么从 broker 传递过来的，然后经过了哪些处理，最后如何被提交给 consumeExecutor 的。 换句话说就是：ConsumeMessageOrderlyService::submitConsumeRequest 这个方法是如何被调用的。\",\"为了方便理解，我们就不从 submitConsumeRequest 向上追踪了，读者可以自行从反推验证。\"]},\"57\":{\"h\":\"PullMessageService\",\"t\":[\"还记得前面启动流程中注释了重点的 this.pullMessageService.start(); 么。\",\"PullMessageService 是就是负责把消息从 Broker 拉取到 Consumer 本地，并将消息封装成 ConsumeRequest 提交给线程池的重要 Service 。\",\"PullMessageService 内维护一个单线程执行器 scheduledExecutorService，负责定期把 PullRequest 提交到 pullRequestQueue 中。\",\"同时 PullMessageService 自身也是一个服务线程 (ServiceThread, RocketMQ 内部自定义的抽象类)，PullMessageService 的工作就是不停的从 pullRequestQueue 中取出 PullRequest 并执行 PullMessageService.pullMessage(final PullRequest pullRequest) 方法处理请求。\",\"PullMessageService::pullMessage 实际上也并不会真正对请求进行处理，它只是选择一个 Consumer，通过调用 Consumer.pullMessage(final PullRequest pullRequest) 来处理。 可能是因为 DefaultMQPullConsumerImpl 被弃用的原因，这里它默认所有的 Consumer 都是 DefaultMQPushConsumerImpl 类型，（强制类型转换）。 因此也可以认为是 DefaultMQPushConsumerImpl::pullMessage 才是真正处理 PullRequest 请求的方法。 DefaultMQPushConsumerImpl::pullMessage 的主要工作就是从 broker 上拉消息回来，它里面的 callback 则是对拉回来的消息进行处理，比如解码啊、存入 msgTreeMap 啊、把消息提交给 consumeExecutor 去执行什么的。\",\"PullMessageService 的属性和基础方法\",\"public class PullMessageService extends ServiceThread { // 存放 pullRequest 请求的队列 private final LinkedBlockingQueue<PullRequest> pullRequestQueue = new LinkedBlockingQueue<PullRequest>(); private final MQClientInstance mQClientFactory; // 单线程、周期执行 private final ScheduledExecutorService scheduledExecutorService = Executors .newSingleThreadScheduledExecutor(r -> new Thread(r, \\\"PullMessageServiceScheduledThread\\\")); // 构造方法 public PullMessageService(MQClientInstance mQClientFactory) { this.mQClientFactory = mQClientFactory; } // PullMessageService 的 run 方法 @Override public void run() { log.info(this.getServiceName() + \\\" service started\\\"); while (!this.isStopped()) { try { // 从 pullRequestQueue 中取出 pullRequest PullRequest pullRequest = this.pullRequestQueue.take(); // 转交给 consumer.pullMessage 去执行 this.pullMessage(pullRequest); } catch (InterruptedException ignored) { } catch (Exception e) { log.error(\\\"Pull Message Service Run Method exception\\\", e); } } log.info(this.getServiceName() + \\\" service end\\\"); } // ... } \",\"pullRequest 存入 pullRequestQueue\",\"两个方法，executePullRequestImmediately 和 executePullRequestLater。\",\"public void executePullRequestImmediately(final PullRequest pullRequest) { try { this.pullRequestQueue.put(pullRequest); } catch (InterruptedException e) { log.error(\\\"executePullRequestImmediately pullRequestQueue.put\\\", e); } } \",\"public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) { if (!isStopped()) { // 就是定时调用 executePullRequestImmediately this.scheduledExecutorService.schedule(() -> PullMessageService.this.executePullRequestImmediately(pullRequest), timeDelay, TimeUnit.MILLISECONDS); } else { log.warn(\\\"PullMessageServiceScheduledThread has shutdown\\\"); } } \",\"PullMessageService::pullMessage\",\"private void pullMessage(final PullRequest pullRequest) { // 从 MQClientInstance.consumerTable 中 以 consumerGroup 为 KEY 取出 consumer // 这个 consumer 就是之前 DefaultMQPushConsumerImpl::start 中注册那一步存入 consumerTable 的 final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup()); if (consumer != null) { // 强转 DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer; // 实际处理 impl.pullMessage(pullRequest); } else { log.warn(\\\"No matched consumer for the PullRequest {}, drop it\\\", pullRequest); } } \",\"PullRequest\",\"看如何处理 PullRequest 请求前，先看一下它是什么。\",\"简单的说就是拉取消息的请求。\",\"// PullRequest 属性、重要重写 Override 方法 public class PullRequest { private String consumerGroup; // 这俩 Queue 跟 ConsumeRequest 中语义一致 // 代表远程 Queue // 它里面只存储 topic + brokerName + queueID // 这三个属性足够 Consumer 确定自己从哪个 Broker 找到哪个 topic 下的哪个队列 private MessageQueue messageQueue; // 消息存入的本地 Queue // ProcessQueue 可以自己去看一下 private ProcessQueue processQueue; // 远程 Queue 的 offset，消费进度，消费位点 private long nextOffset; private boolean previouslyLocked = false; // hashcode: (1*31 + consumerGroup.hashcode) * 31 + messageQueue.hashcode @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((consumerGroup == null) ? 0 : consumerGroup.hashCode()); result = prime * result + ((messageQueue == null) ? 0 : messageQueue.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PullRequest other = (PullRequest) obj; if (consumerGroup == null) { if (other.consumerGroup != null) return false; } else if (!consumerGroup.equals(other.consumerGroup)) return false; if (messageQueue == null) { if (other.messageQueue != null) return false; } else if (!messageQueue.equals(other.messageQueue)) return false; return true; } } \",\"它的 hashCode 计算方式类似 String.hashCode，基本上也是基于以下公式：\",\"n 是迭代次数， 是变量，需要计算几次就迭代几次\",\"顺便提一句，看到 Override hashCode() 和 equals()，那么大概率他是要在某个数据表里作为 key 使用了。\",\"DefaultMQPushConsumerImpl::pullMessage\",\"这个方法也很长，老样子删减，只看主要逻辑，这里我把 pullMessage 的代码分成了三个部分。 前面控流的部分可以不看，中间 callback 要看一下，核心内容在第三段。\",\"下面控流这一段可以不看，可全部跳过。\",\"// DefaultMQPushConsumerImpl::pullMessage // get ProcessQueue final ProcessQueue processQueue = pullRequest.getProcessQueue(); // 控流 // 本地缓存消息数量 processQueue.getMsgCount > 1000 触发控流 // 间隔为 PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = 50ms if (cachedMessageCount > this.defaultMQPushConsumer.getPullThresholdForQueue()) { // 控流的处理方式就是前面贴过的 PullMessageService().executePullRequestLater // 实际上就是把 pullRequest 重新 put 回 pullRequestQueue this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); // log ... // 然后直接 return return; } // 本地缓存消息 > 100 Mb 触发控流 // 处理方式同上 代码略 if (cachedMessageSizeInMiB > this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {...} // 并发消费控流 // maxSpan > 2000 处理方式同上 if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {...} // 顺序消费 // 不算是控流、不过处理方式一样 if (processQueue.isLocked()) { // pullRequest.isPreviouslyLocked 默认为 false if (!pullRequest.isPreviouslyLocked()) { // 首次 pullMessage 会进入这里 long offset = -1L; try { // 根据默认的初始消费位点（见基础概念-消费位点部分） 计算实际消费位点 // 这个可以自己去看代码，或者看书也行 offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue()); } catch (Exception e) { this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.error(\\\"Failed to compute pull offset, pullResult: {}\\\", pullRequest, e); return; } // broker 异常 or readFile 异常时会为 true，也就是 offset 为 -1 // offset 如果正常会后面会设置为 pullRequest.nextOffset 的值 boolean brokerBusy = offset < pullRequest.getNextOffset(); log.info(\\\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\\\", pullRequest, offset, brokerBusy); if (brokerBusy) { log.info(\\\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\\\", pullRequest, offset); } pullRequest.setPreviouslyLocked(true); pullRequest.setNextOffset(offset); } } else { // pullTimeDelayMillsWhenException 默认 3000ms this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.info(\\\"pull message later because not locked in broker, {}\\\", pullRequest); return; } \",\"然后来看第二部分，一个老长的 callback，主要看 onSuccess 方法，它是给 consumer 发起异步请求成功时用的。主要功能就是把拉回来的数据解码为 msgList 然后存入 msgTreeMap 以便消费，最后调用 consumeMessageService.submitConsumeRequest 提交复制消费的执行器执行。\",\"// DefaultMQPushConsumerImpl::pullMessage PullCallback pullCallback = new PullCallback() { @Override public void onSuccess(PullResult pullResult){ // 对从 broker 上拉回来的消息进行解码过滤等处理。 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult, subscriptionData); switch (pullResult.getPullStatus()) { case FOUND: // FOUND 就是代表 从 Broker 拉回了新消息 long prevRequestOffset = pullRequest.getNextOffset(); pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 状态信息的处理 略 ... long firstMsgOffset = Long.MAX_VALUE; // MsgFoundList 为空，立刻再提交一个 pullRequest 到队列中 if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } else { // 拉回的第一条消息的 offset firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset(); // 状态处理，略 // 就是存入 msgTreeMap ，顺便同步维护 ProcessQueue 的属性 // 只要 msgTreeMap 不为空，且 ProcessQueue 不处于 消费中的状态，就返回 true // 其他情况则返回 false boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList()); // 然后就来到了 consumeMessageService.submitConsumeRequest // 也就是前文讲的 创建 ConsumeRequest 并提交给 consumeExecutor 去执行。 // 这方法有两种实现，顺序消费/并发消费 // dispatchToConsume 参数仅作用于顺序消费，如果是 false 则不会执行 // 并发消费无所谓顺序，所以 dispatchToConsume 参数就没啥用 DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest( pullResult.getMsgFoundList(), processQueue, pullRequest.getMessageQueue(), dispatchToConsume); // 这个 PullInterval 拉取间隔默认是0 ，如果大于0了自然就是等会儿再去拉取。 if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) { DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval()); } else { // PullInterval == 0 就立即拉取 DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } } if (pullResult.getNextBeginOffset() < prevRequestOffset || firstMsgOffset < prevRequestOffset) { log.warn( \\\"[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}\\\", pullResult.getNextBeginOffset(), firstMsgOffset, prevRequestOffset); } break; case NO_NEW_MSG: // 没有新消息 case NO_MATCHED_MSG: // 没有匹配的消息 pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 更新 offset,本地 or local 两种方式 DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest); DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); break; case OFFSET_ILLEGAL: // 偏移量非法 log.warn(\\\"the pull request offset illegal, {} {}\\\", pullRequest.toString(), pullResult.toString()); pullRequest.setNextOffset(pullResult.getNextBeginOffset()); pullRequest.getProcessQueue().setDropped(true); DefaultMQPushConsumerImpl.this.executeTaskLater(() -> { try { // 重新计算并更新偏移量，移除当前 processQueue // 这部分就不展开了 DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),pullRequest.getNextOffset(),false); DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue()); DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue()); log.warn(\\\"fix the pull request offset, {}\\\", pullRequest); } catch (Throwable e) { log.error(\\\"executeTaskLater Exception\\\", e); } }, 10000); break; default: break; } } @Override public void onException(Throwable e){ ... } } \",\"最后是第三部分，对 broker 发起拉取消息请求：\",\"// 3rd part boolean commitOffsetEnable = false; long commitOffsetValue = 0L; // 读取消费位点，分顺序/集群两种实现，不过集群也是从本地内存里读 if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) { commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY); if (commitOffsetValue > 0) { commitOffsetEnable = true; } } String subExpression = null; boolean classFilter = false; // 从 rebalanceImpl 中根据 topic 拿到订阅数据 SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic()); if (sd != null) { // isPostSubscriptionWhenPull 是否每次 pull 的时候都更新订阅关系 ，默认 false if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) { subExpression = sd.getSubString(); } classFilter = sd.isClassFilterMode(); } int sysFlag = PullSysFlag.buildSysFlag( commitOffsetEnable, // commitOffset true, // suspend subExpression != null, // subscription classFilter // class filter ); try { // 最后 netty client 发起拉消息的请求，这就不展开了 this.pullAPIWrapper.pullKernelImpl( pullRequest.getMessageQueue(), subExpression, subscriptionData.getExpressionType(), subscriptionData.getSubVersion(), pullRequest.getNextOffset(), this.defaultMQPushConsumer.getPullBatchSize(), sysFlag, commitOffsetValue, BROKER_SUSPEND_MAX_TIME_MILLIS, CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, CommunicationMode.ASYNC, pullCallback ); } catch (Exception e) { log.error(\\\"pullKernelImpl exception\\\", e); this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); } \"]},\"58\":{\"h\":\"负载均衡\",\"t\":[\"rebalance 这一层从理论模型角度看是加在消费行为之前的，主要针对集群消费模式。\",\"实际实现方式是，负载均衡器每隔 20s 对远程 Queue 上锁，然后执行 doRebalance，最后释放锁。\",\"换句话说就是消费组内的每个 consumer 都只管从 processQueue 中取出消息进行消费，而负载均衡器则利用分配策略为 consumer 分配他应该消费哪些消息。\",\"基本组成\",\"RebalanceImpl 是个抽象类，有三个子类，RebalanceLitePullImpl，RebalancePullImpl，RebalancePushImpl。 很明显就是对应三种 consumer 实现类。 以 Push 模式为例，负载均衡器内部维护如下三个数据表：\",\"protected final ConcurrentMap<MessageQueue, ProcessQueue> processQueueTable = new ConcurrentHashMap<MessageQueue, ProcessQueue>(64); protected final ConcurrentMap<String/* topic */, Set<MessageQueue>> topicSubscribeInfoTable = new ConcurrentHashMap<String, Set<MessageQueue>>(); protected final ConcurrentMap<String /* topic */, SubscriptionData> subscriptionInner = new ConcurrentHashMap<String, SubscriptionData>(); \",\"四条属性，在 consumer 启动阶段初始化（实际上 subscriptionInner 也会初始化）：\",\"this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup()); this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel()); this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()); this.rebalanceImpl.setmQClientFactory(this.mQClientFactory); \",\"构造方法：\",\"public RebalancePushImpl(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl) { this(null, null, null, null, defaultMQPushConsumerImpl); } \",\"负载均衡的实现和 consumer 的实现要对应。\",\"延迟解锁的值默认为 20s，也就是一个负载均衡器远程上锁的周期：\",\"private final static long UNLOCK_DELAY_TIME_MILLS = Long.parseLong(System.getProperty(\\\"rocketmq.client.unlockDelayTimeMills\\\", \\\"20000\\\")); \",\"负责执行负载均衡任务的是 RebalanceService。\",\"它的工作就是 20s 执行一次负载均衡：\",\"// RebalanceService::run while (!this.isStopped()) { this.waitForRunning(waitInterval); this.mqClientFactory.doRebalance(); } \",\"负载均衡操作 RebalanceImpl::doRebalance\",\"// RebalanceImpl::doRebalance // isOder 在 Pull 模式为 false，Push 模式根据 consumer.isConsumeOrderly 判断 public void doRebalance(final boolean isOrder) { Map<String, SubscriptionData> subTable = this.getSubscriptionInner(); if (subTable != null) { for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) { final String topic = entry.getKey(); try { // this one this.rebalanceByTopic(topic, isOrder); } catch (Throwable e) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"rebalanceByTopic Exception\\\", e); } } } } // 从 processQueueTable 中剔除订阅关系错误的消息 this.truncateMessageQueueNotMyTopic(); } \",\"然后来看 RebalanceImpl::rebalanceByTopic：\",\"private void rebalanceByTopic(final String topic, final boolean isOrder) { switch (messageModel) { case BROADCASTING: { // 广播模式跟负载均衡这个概念其实没啥关系 // 略 ... break; } case CLUSTERING: { // 主要看集群模式 // topic 下的 MessageQueue 集合 Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic); // cidAll 就是 topic 对应的 消费组下的所有 consumer 的 id 列表 List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup); if (null == mqSet) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"doRebalance, {}, but the topic[{}] not exist.\\\", consumerGroup, topic); } } if (null == cidAll) { log.warn(\\\"doRebalance, {} {}, get consumer id list failed\\\", consumerGroup, topic); } if (mqSet != null && cidAll != null) { List<MessageQueue> mqAll = new ArrayList<MessageQueue>(); mqAll.addAll(mqSet); // 排序，保证每个 consumer 上都是一致的。 Collections.sort(mqAll); Collections.sort(cidAll); AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy; List<MessageQueue> allocateResult = null; try { // 根据不同策略来分配 allocateResult = strategy.allocate( this.consumerGroup, this.mQClientFactory.getClientId(), mqAll, cidAll); } catch (Throwable e) { log.error(\\\"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}\\\", strategy.getName(), e); return; } Set<MessageQueue> allocateResultSet = new HashSet<MessageQueue>(); if (allocateResult != null) { allocateResultSet.addAll(allocateResult); } // 遍历 processQueueTable，根据 allocateResultSet 剔除无效队列，添加新队列失败时，重新计算消费位点并重拉消息。 // 只要对 processQueueTable 进行修改就会返回 true ，nothing touched return false // 通常是消费组内的 consumer 数量发生变化，然后负载均衡器就要给 consumer 重新计算它现在要负载消费哪个队列 boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder); if (changed) { log.info( \\\"rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}\\\", strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(), allocateResultSet.size(), allocateResultSet); this.messageQueueChanged(topic, mqSet, allocateResultSet); } } break; } default: break; } } \",\"可以看到广播模式就是直接执行 updateProcessQueueTableInRebalance，集群模式则是先执行 rebalance，然后再执行 updateProcessQueueTableInRebalance。 说白了广播模式不存在负载均衡这个概念。\",\"AllocateMessageQueueStrategy 负载均衡策略\",\"目前一共六种负载均衡策略，默认的是 AllocateMessageQueueAveragely，这里就不罗列了，有兴趣可以自己去看。顺便自行探索为什么文档和最佳实践都建议消费者数量要比队列数量少。\",\"总结\",\"可以看出，rebalance 是一个集群模式下的，基于队列和消费者数量的负载均衡。 它把队列和消费者进行了一对一映射，然后每个消费者按 pullMsg --> 提交消费位点 --> 持久化消费位点的流程处理消息，pullMsg 时不提交消费状态。 为了避免消息被多个消费者重复消费，每个队列仅被一个消费者消费。\",\"并且要注意，由于 rebalance 是单独一个线程每 20s 进行一次分配，当队列数、消费者数发生变化时，重复消费是有可能发生的。\",\"注意这里都是 4.x 版本，5.x 版本负载均衡这块有重构，而且提供了消息粒度的负载均衡。\"]},\"59\":{\"h\":\"消息确认\",\"t\":[\"无论是消费成功还是失败，亦或者其他情况，consumer 都会有“消费结果”，根据消费结果状态的不同，consumer 会进行不一样的处理（见 consumer.processConsumeResult()），比如 RECONSUME_LATER 就会把消息发回 broker 从而延迟消费。这个流程叫消息确认，或 SendMsgBack，或 ack 消息。\",\"这部分代码就不展开分析了，本质就是 netty client 给 netty server 发请求，具体来说就是 MQClientAPIImpl::consumerSendMessageBack 方法，请求码为 RequestCode.CONSUMER_SEND_MSG_BACK，然后按照 rocketmq 自定义的请求协议封装好 requestHeader、body，encode，发送请求。 然后发送请求依然是有同步异步两种方式，不再赘述。\",\"细节部分如果有兴趣，一方面你可以去查书 (《RocketMQ 技术内幕》)，另一方面你可以去看内部协议的实现，个人建议两种方式结合，毕竟缺乏注释和细节文档的代码有个参考书还是好的。\"]},\"60\":{\"h\":\"总结\",\"t\":[\"消息消费就到这里结束啦，已经太长了，又不是写书。没有特意讲解 pull 模式和并发消费的流程，不过大同小异。比如 Pull 模式的 consumer 实现，哪怕你不去看代码现在也应该能推测出来，它跟 DefaultMQPushConsumer 的区别就是它是自己主动去拉取消息，换句话说它不需要 PullMessageService，其他几乎都一样。ConsumeMessageConcurrentlyService 也是同理，它不需要保证顺序，所以直接消费就可以了，不需要像顺序消费一样从 consumingMsgOrderlyTreeMap 里一个个取，一个个提交。\",\"接下来我们会回到 rocketmq-store，来看看 RocketMQ 的高可用也就是 HA 的实现。\"]},\"61\":{\"h\":\"RocketMQ 源码分析-高可用 HA\",\"t\":[\"高可用基本是分布式系统必备特性之一，实现方案通常为主从机制。\",\"RocketMQ 的高可用就挺特别，它有主从同步但是没有主从切换，读写分离也并不彻底， 正常情况下所有消费者都是从 master 上拉取消息，只有积压消息超过 master 物理内存的 40%时，消费者切换到 slave 上进行消费，此时其实才是“读写分离”的。当 slave 上的积压消息小于 30% 时，消费者会再次切换回 master 进行消费。\"]},\"62\":{\"h\":\"主从同步\",\"t\":[\"RocketMQ 的主从同步实际上就是 Broker 的主从同步，每当消息送达 Broker-Master 时，要同步到 Broker-Slave，这样一旦 Master 挂了，Consumer 可以从 Slave 拉取消息。\",\"接下来看代码，源码位置：rocketmq/store.ha 的 org.apache.rocketmq.store.ha 包。\"]},\"63\":{\"h\":\"机制概述\",\"t\":[\"Broker 主从机制的基本流程如下：\",\"Step1：Master 启动并监听端口\",\"Broker-Master 启动时会监听 MessageStoreConfig.haListenPort 端口，等待 Slave 的连接。\",\"Step2：Slave 启动并主动连接 Master\",\"就是 Slave 主动与上一步的 Broker:haListenPort 建立链接。\",\"Step3：同步消息\",\"链接建立后，Slave 向 Master 发送待拉取消息的 offset，Master 根据请求返回消息给 Slave。\",\"Step4：保存 & 继续同步\",\"Slave 保存收到的消息后继续重复以上流程。\",\"接下来我们就根据这个流程来看 HA 的代码。\"]},\"64\":{\"h\":\"Step1\",\"t\":[\"首先是 Broker-Master 启动并监听端口，这一步的入口实际上就是在Broker-启动流程中没有详细展开的 BrokerStartup::createBrokerController 方法里。\",\"这里我们来看一下它：\",\"BrokerStartup::createBrokerController\",\"感觉 Broker 的下篇都没啥可写的了，都分散到其他章节里去了，回头重新调整一下 Broker 篇的内容。\",\"下面是设置监听端口(haListenPort)：\",\"// BrokerStartup::createBrokerController // 只看设置监听端口部分 其余均省略 // listenPort 默认值虽然是 8888，但这里直接设置成了 10911 nettyServerConfig.setListenPort(10911); // haListenPort 的逻辑值是 listenPort + 1 // 默认值是 10912，实际值算出来也是 10911 + 1 = 10912 messageStoreConfig.setHaListenPort(nettyServerConfig.getListenPort() + 1); // 根据角色设置 master 的 BrokerID // BrokerID 应该自行在配置文件中设置好，master 为 0，slave > 0，多个 slave 要区分开 switch (messageStoreConfig.getBrokerRole()) { case ASYNC_MASTER: case SYNC_MASTER: // Master 的 BrokerID 为 0 brokerConfig.setBrokerId(MixAll.MASTER_ID); break; // ... } \",\"然后在 BrokerController::start 中找到 this.messageStore.start();，HA 属于存储模块，在 DefaultMessageStore::start() 中找到 haService.start();。\",\"4.x 版本\",\"注意 分布式 CommitLog，或者说 DLedger 与高可用模式不兼容\",\"// from DefaultMessageStore::start() if (!messageStoreConfig.isEnableDLegerCommitLog()) { this.haService.start(); this.handleScheduleMessageService(messageStoreConfig.getBrokerRole()); } \",\"然后来看主角 HAService。\",\"HAService::start\",\"public void start() throws Exception { // 监听 haListenPort 端口， NIO this.acceptSocketService.beginAccept(); // 下面三个都是服务线程， ServiceThread this.acceptSocketService.start(); this.groupTransferService.start(); this.haClient.start(); } \",\"至此，第一步的实现已经看完了，Master 在创建 BrokerController 时会设置 haListenPort 的值，存储模块启动时会启动 haService，haService 启动时会监听 haListenPort 等待 Slave 的连接。\"]},\"65\":{\"h\":\"Step2\",\"t\":[\"Slave 启动并主动连接 Master。\",\"Broker-Slave 的 BrokerID 是用户自己在配置文件里指定的，必须大于0，而且同一个 Master 如果你配置多个 slave 的话，他们的 brokerID 不能相同。\",\"启动流程就省略了，只看它连接 Master，这部分代码就在 this.haClient.start();。\",\"HAClient 是服务线程，直接去看它的 run 方法，可以找到 this.connectMaster()。\",\"HAClient::connectMaster\",\"private boolean connectMaster() throws ClosedChannelException { if (null == socketChannel) { // sc 为空，则尝试与 master 建立连接 String addr = this.masterAddress.get(); if (addr != null) { // 转换类型，从 String 到 InetSocketAddress SocketAddress socketAddress = RemotingUtil.string2SocketAddress(addr); if (socketAddress != null) { // 连接到 master this.socketChannel = RemotingUtil.connect(socketAddress); if (this.socketChannel != null) { // 注册 OP_READ 事件，不认识的话，你就把它理解为网络IO事件的读事件 this.socketChannel.register(this.selector, SelectionKey.OP_READ); } } } this.currentReportedOffset = HAService.this.defaultMessageStore.getMaxPhyOffset(); this.lastWriteTimestamp = System.currentTimeMillis(); } return this.socketChannel != null; } \",\"提示\",\"注意 master 和 slave 建立 tls 链接这部分都是 java nio，不是 netty 语境。\"]},\"66\":{\"h\":\"Step3 & Step4\",\"t\":[\"同步消息，保存，重复以上流程。\",\"回到 HAClient::run：\",\"// HAClient::run public void run() { log.info(this.getServiceName() + \\\" service started\\\"); while (!this.isStopped()) { try { if (this.connectMaster()) { //step2 // 只要 channel 还在就会进入这里 if (this.isTimeToReportOffset()) { // 距离上次 ReportOffset 超过 5s 就为 true // Step3 中的上报 offset // 向 master 上报 slave 端当前最大偏移量 boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset); if (!result) { this.closeMaster(); // 关闭 channel } } this.selector.select(1000); // step3 中的 master 返回消息，以及 step 4 中的保存数据 // 这里的 ReadEvent 就是 IO 概念里的读事件 // 也就是 slave 读取 master 根据 slaveMaxOffset 返回的待同步消息 // 具体点说就是： 先从 channel 中读数据，一次最多读 4MB，读到数据后调用 // dispatchReadRequest 方法，这个方法会解码读到的数据，并 append 到 slave 的 commitLog 文件中。 // 保存消息的流程，详见持久化篇 defaultMessageStore.appendToCommitLog -> .commitLog.appendData -> mappedFile.appendMessage boolean ok = this.processReadEvent(); if (!ok) { this.closeMaster(); } // 更新 haService.currentReportedOffset // 并再次上报 offset if (!reportSlaveMaxOffsetPlus()) { continue; } long interval = HAService.this.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp; // 写入间隔超过 20s，则认为链接无效，关闭 channel。 if (interval > HAService.this.getDefaultMessageStore().getMessageStoreConfig() .getHaHousekeepingInterval()) { log.warn(\\\"HAClient, housekeeping, found this connection[\\\" + this.masterAddress + \\\"] expired, \\\" + interval); this.closeMaster(); log.warn(\\\"HAClient, master not response some time, so close connection\\\"); } } else { // slave 未能和 master 建立链接，则 5s 后重试 // 利用自定义的 CountDownLatch 实现的，叫 CountDownLatch2，有兴趣可以自己去看 this.waitForRunning(1000 * 5); } } catch (Exception e) { log.warn(this.getServiceName() + \\\" service has exception. \\\", e); this.waitForRunning(1000 * 5); } } log.info(this.getServiceName() + \\\" service end\\\"); } \",\"高可用流程的实现就基本看完啦，无论是之前的 netty 还是这里的 Java NIO 部分都不在讲解范围内，因此都略过啦，有兴趣可以自己去看。\",\"然后来看一下 HA 核心类。\"]},\"67\":{\"h\":\"HAService\",\"t\":[\"HAService 就是高可用的核心实现类，它有三个内部类：AcceptSocketService、GroupTransferService、HAClient。它内部还维护一个 HAConnection 列表（private final List<HAConnection> connectionList = new LinkedList<>();）。\",\"我们挨个来看，首先是 AcceptSocketService:\",\"AcceptSocketService\",\"AcceptSocketService 是个服务线程，还是先看 run 方法，它的主要工作就是监听 haListenPort 端口上的 IO 事件/状态，只要满足条件就建立链接，并且创建一个 HAConnection 对象，并存入 this.connectionList。\",\"而前面提到的另一个方法 AcceptSocketService::beginAccept，就是为监听端口的准备工作，因此要在 AcceptSocketService 启动前执行。\",\"说白了，AcceptSocketService 就是 master 用来监听 slave 连接的实现类。\",\"GroupTransferService\",\"GroupTransferService 的 run 方法逻辑为每 10ms 执行一次 doWaitTransfer 方法。\",\"private void doWaitTransfer() { if (!this.requestsRead.isEmpty()) { for (CommitLog.GroupCommitRequest req : this.requestsRead) { // tansferOK 就是主从同步是否完成的标记。 // req.getNextOffset() 是从 master 传回来的下一条新消息的 offset // push2SlaveMaxOffset 是 salve 目前已同步的最大 offset // 当 slave 上同步的 offset >= master 上新消息的起始位置，说明 salve 已经追平 master 的进度，甚至超出 boolean transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset(); long waitUntilWhen = HAService.this.defaultMessageStore.getSystemClock().now() + HAService.this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout(); // 未追平时，该循环运行间隔为 1s，SyncFlushTimeout 为 5s，所以 requestsRead 中的每个 req 通常会循环5次 // 一旦追平 or 超时都会退出循环 while (!transferOK && HAService.this.defaultMessageStore.getSystemClock().now() < waitUntilWhen) { this.notifyTransferObject.waitForRunning(1000); transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset(); } if (!transferOK) { log.warn(\\\"transfer messsage to slave timeout, \\\" + req.getNextOffset()); } // 这里是给 producer 的返回，追平说明主从刷盘均成功；如果前面哪个循环中没有追平，则返回 Slave刷盘超时的状态 req.wakeupCustomer(transferOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_SLAVE_TIMEOUT); } // 将 读列表 至空 this.requestsRead = new LinkedList<>(); } } \",\"由上述代码我们可以得出一个结论，GroupTransferService 的主要工作就是监视 slave 的同步状态，以便为发送消息的 producer 返回响应。\",\"然后来看一下 GroupTransferService 的其他内容，首先是它内部创建了俩队列，requestsWrite 和 requestsRead。这个读写队列跟前几篇讲的读写分离技巧是一样的，两个队列交换的时机是: run -> waitForRunning(10) -> this.onWaitEnd();。\",\"还有一个方法的逻辑要看，那就是 notifyTransferSome，不过 GroupTransferService::notifyTransferSome 只是唤醒逻辑，完整处理逻辑在主类的同名方法里：\",\"// HAService::notifyTransferSome public void notifyTransferSome(final long offset) { // 这里的 offset 参数可以直接看作 新的 push2SlaveMaxOffset 的值 // 或者对于 value 来说就是 newValue for (long value = this.push2SlaveMaxOffset.get(); offset > value; ) { // 更新 push2SlaveMaxOffset boolean ok = this.push2SlaveMaxOffset.compareAndSet(value, offset); if (ok) { // 唤醒 GroupTransferService this.groupTransferService.notifyTransferSome(); break; } else { value = this.push2SlaveMaxOffset.get(); } } } \",\"这个方法的调用时机时机是 master 收到 slave 的拉取请求后，细节后面会讲。\",\"HAClient\",\"HAClient 就要复杂一些，这个类 master/slave 都会用到。它主要负责处理各种业务逻辑。 比如前面我们过流程的时候提到的连接 master 就是它的 connectMaster 方法。\",\"这阅读部分代码需要注意一点，以 connectMaster 方法为例，很明显这个方法就是给 slave 用的，但实际上 master 也会进入这个方法。\",\"HAClient 的核心方法在前面分析流程的时候已经解释的差不多了，只不过因为大部分都是 IO 代码，没有单独贴出来。\",\"这里简单说说其他没出现过的方法。\",\"HAClient::updateMasterAddress，这个顾名思义，更新 Master 地址，发生在 slave 的 masterAddress 为空，或者收到新地址时。\",\"HAClient::reallocateByteBuffer 和 HAClient::swapByteBuffer 两个方法合起来实现了 byteBufferRead 的读写状态切换功能，这俩方法就相当于是手动实现了一遍 this.byteBufferRead.flip(); 。 这个也是 IO 的内容，给看不懂的小伙伴简单解释下，在这里数据都是加密的数据流的形式，你可以把他想成一个长度未知的一维数组，里面存储的都是加密(encode)后的数据，数据此时就像水管里的水流，（读事件）读数据的时候要么是读到没数据为止，要么是读固定长度，这个过程你就可以想成一个指向数组下标的指针在不断移动，读到哪就指到哪；而当你要切换到写状态时，你肯定是要把数据从头开始写，也就是下标 0 的位置，但是你指针现在在读的位置。byteBuffer::flip() 就是帮你把下标置换回 0，详细说明可以看它的注释，解释的很好，还给了用例。由于本文跳过了关于 netty 和 IO 部分的代码，实际上前面几篇中 netty 部分都是用 flip() 的。对 IO 不熟悉的小伙伴强烈建议跟着 netty 文档动手写一遍文档里所有的 demo，这样什么 handle、encode/decode、粘包处理等等常见问题都会有清晰的认识 。\"]},\"68\":{\"h\":\"HAConnection\",\"t\":[\"这个类就是用来管理连接和网络 IO 读写的类，他有俩内部类，ReadSocketService 和 WriteSocketService，这俩 Service 也是服务线程。\",\"HAConnection 的构造方法其实就是创建一个“链接:connection”，并同时为该“链接”创建读写两个线程。 其实就是把 slave 与 master 进行网络通讯的 socketChannel 封装成了一个链接对象。\",\"然后来看它的俩属性，slaveRequestOffset 属性就是 slave 要请求的 offset，默认值 -1，代表拉取还未开始，请求行为会直接放弃，0 代表按照 slave 当前的 maxOffset 拉取，其余情况就是按它的真实值拉取。\",\"slaveAckOffset，slave 向 master 反馈已同步的偏移量。这个值就是 HAService::notifyTransferSome 方法的入参。\",\"了解以上他们的含义后，分析读写线程的业务逻辑就比较简单了，二者实际上非常相似，基本流程都是先 encode 数据，然后调用 ReadSocketService::processReadEvent / WriteSocketService::transferData 完成网络传输（包括粘包处理等)，传输完成后进行 decode，如果有其他逻辑则执行。最终释放各种资源，并销毁线程。\"]},\"69\":{\"h\":\"主从切换\",\"t\":[\"主从切换/读写分离的大致逻辑就不再重复了，这里直接来看这部分逻辑是如何实现的。\",\"首先来看，Consumer 如何找到具体的 Broker 的，前面在消费篇里提过，Consumer 根据 MessageQueue 去确定 Broker。这里我们更进一步，去看之前没继续展开的调用链。\",\"通过消费篇我们知道，负责从 broker 拉取消息的是 DefaultMQPushConsumerImpl::pullMessage 方法，该方法最终是通过调用 this.pullAPIWrapper.pullKernelImpl(...) 来完成消息拉取的，而这个方法里第一步就是根据 MessageQueue 找 Broker:\",\"// mq 参数的类型就是 MessageQueue FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),this.recalculatePullFromWhichNode(mq), false); \",\"我们要找到俩方法都在这里了，一个是 findBrokerAddressInSubscribe，一个是 recalculatePullFromWhichNode。\",\"findBrokerAddressInSubscribe 方法的功能就是根据 BrokerName 和 BrokerID 找到对应的 BrokerAddress，然后把相关信息塞进 FindBrokerResult 对象中并返回。\",\"BrokerName 的值来自 mq.getBrokerName，这个没啥可说的，主要看 brokerID，也就是 this.recalculatePullFromWhichNode(mq)。\",\"public long recalculatePullFromWhichNode(final MessageQueue mq) { // 这个不用看，这是用户指定 if (this.isConnectBrokerByUser()) { return this.defaultBrokerId; } // 主从是否要切换就取决于 suggest AtomicLong suggest = this.pullFromWhichNodeTable.get(mq); if (suggest != null) { return suggest.get(); } // 默认只访问 master return MixAll.MASTER_ID; } \",\"从代码中我们可以看出，Consumer 是否切换 broker 就取决于 suggest 的值，(pullFromWhichNodeTable 中以 MessageQueue 为 key，suggest 为 value)。那么 suggest 的值是哪来的，在 processPullResult 中 this.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId()); 这一步。\",\"//updatePullFromWhichNode public void updatePullFromWhichNode(final MessageQueue mq, final long brokerId) { AtomicLong suggest = this.pullFromWhichNodeTable.get(mq); if (null == suggest) { // 为空则创建，相当于初始化 this.pullFromWhichNodeTable.put(mq, new AtomicLong(brokerId)); } else { // 非空则 update BrokerID suggest.set(brokerId); } } \",\"也就是说 suggest 是由 Broker 反馈给 Consumer 的。那么我们去 Broker 看 suggest 如何生成。\",\"前文提到了，大于 40% 时由主切从，小于 30% 由从切主，先来看这个值的初始化：\",\"// BrokerStartup.class // 物理内存最大占比， 40 就是 40%，Slave 是 30% // master 40% 是切换 slave 的阈值 // slave 30% 是切回 master 的阈值 if (BrokerRole.SLAVE == messageStoreConfig.getBrokerRole()) { int ratio = messageStoreConfig.getAccessMessageInMemoryMaxRatio() - 10; messageStoreConfig.setAccessMessageInMemoryMaxRatio(ratio); } \",\"然后来看:\",\"// DefaultMessageStore::getMessage long diff = maxOffsetPy - maxPhyOffsetPulling; long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0)); // 这里决定是否主从切换 getResult.setSuggestPullingFromSlave(diff > memory); \",\"之后在 PullMessageProcessor::processRequest 中设置 consumer 拿到的 brokerID，如下：\",\"// DefaultMessageStore::getMessage 就在这段代码前调用 // 根据 suggest 设置 brokerID if (getMessageResult.isSuggestPullingFromSlave()) { responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly()); } else { responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID); } \",\"对 PullMessageProcessor::processRequest 做个简单说明，PullMessageProcessor 可以简单看作负责处理请求的类，processRequest 就是处理请求的方法。\"]},\"70\":{\"h\":\"元数据同步\",\"t\":[\"注\",\"本章节目录结构来自《RocketMQ 技术内幕》。\",\"这里所说的元数据指的是，Broker 中存储的 topic、消费组、消费进度等信息。\",\"前两个大章节介绍了 HA 的主从同步和主从切换，除了以上功能外，master 宕机时，虽然无法写入消息，但是消费短期内是不受影响的，consumer 依然可以从 slave 上进行消费。master 恢复后，slave 可以把“元数据”，比如集群模式的消费进度，主动同步回 master。\"]},\"71\":{\"h\":\"Slave 自动同步元数据\",\"t\":[\"这个同步是单向的，只会是 slave 向 master 同步数据，这就是 broker 篇启动流程中的 BrokerController::handleSlaveSynchronize 方法。\",\"实现方式就是通过定时任务，每 10s 与 master 同步一次数据。\",\"private void handleSlaveSynchronize(BrokerRole role) { if (role == BrokerRole.SLAVE) { if (null != slaveSyncFuture) { slaveSyncFuture.cancel(false); } this.slaveSynchronize.setMasterAddr(null); slaveSyncFuture = this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { // 同步 BrokerController.this.slaveSynchronize.syncAll(); } catch (Throwable e) { log.error(\\\"ScheduledTask SlaveSynchronize syncAll error.\\\", e); } } }, 1000 * 3, 1000 * 10, TimeUnit.MILLISECONDS); } else { //handle the slave synchronise if (null != slaveSyncFuture) { slaveSyncFuture.cancel(false); } this.slaveSynchronize.setMasterAddr(null); } } \",\"具体同步哪些数据可以可根据代码自行查看：\",\"public void syncAll() { this.syncTopicConfig(); this.syncConsumerOffset(); this.syncDelayOffset(); this.syncSubscriptionGroupConfig(); } \"]},\"72\":{\"h\":\"消费进度同步\",\"t\":[\"由于消费进度变化很快，只靠 10s 一次的同步显然有点慢，因此还有另外一种方式，就是通过 consumer 发来的 pullMessage 请求，如果其中包含的消费进度的信息，就直接拿来更新本地消费进度。\",\"这部分代码也在 PullMessageProcessor::processRequest，感兴趣自行查看。\"]},\"73\":{\"h\":\"总结\",\"t\":[\"高可用也写完啦，撒花 😃\",\"关于 RocketMQ 的文章至此也就暂时告一段落啦，后续会重新调整一下 Broker 篇的内容，以及纠错等等。\",\"消息轨迹、ACL 啥的就不更啦。\",\"未来关于 RocketMQ 的文章大概就是找个合适的时间把 5.0 的内容放上来。\"]},\"74\":{\"h\":\"RocketMQ 源码分析-概述\"},\"75\":{\"h\":\"什么是 RocketMQ\",\"t\":[\"RocketMQ 是一个基于主题的发布与订阅模式的消息队列中间价。其设计核心追求高性能、高吞吐量、高可用。 MQ 的核心功能就是消息的接受、发送、存储消息。\"]},\"76\":{\"h\":\"基本架构\",\"t\":[\"其基本架构由客户端（包括消息的生产者和消费者），NameSrv，Broker 组成。\",\"NameSrv 像是“注册中心/服务发现”，但实际上只是简单的路由信息的管理模块，其高可用通过部署多个 NameSrv 来保证，各个 NameSrv 之间不进行通信，允许分钟级的数据不一致。\",\"Broker 则是定期上报各种路由信息给 NameSrv，并且复制接收、推送/拉取消息以及消息持久化。比如收到消息后先写入缓冲区，之后以同步/异步的方式刷盘写入 commit.log，并且异步转发给 ConsumeQueue 或者 index 文件方便以 topic 或者索引的方式检索消息等等。\",\"客户端从 NameSrv 上同步路由信息，并在本地进行缓存，然后根据路由信息找到对应的 Broker 进行消息的发布和订阅。\"]},\"77\":{\"h\":\"大致流程\",\"t\":[\"Producer 向 Broker 发送消息：\",\"从使用者的角度去看，Producer 是向 Topic 发布消息；从数据流动角度看，是从 Producer 流动到 Broker。\",\"先根据 topic 检查本地路由表（Producer 每 30s 会从 NameServer 拉一次），本地没有就带着 topic 去 NameServer 查询，查到了就按具体情况选好 Broker 发送消息；如果没查到（假设没有开启自动创建主题机制）抛出路由信息错误。最后 Producer 是否接收返回信息以及用什么方式处理返回信息取决于采取的是哪种发送方式。\",\"自动创建主题机制就是如果启用了该机制， Broker 会自动创建一个 TOPIC（名字挺奇怪的叫 \\\"TBW102\\\"，难道是淘宝网102？）以及对应的路由信息，所有错误/不存在的 topic 的路由信息都存在这里，TBW102 的路由信息也会自动上报到 NameServer。\",\"换句话说，当你写错 topic 的时候，Producer 执行 topic 路由的过程就变成了使用 \\\"TBW102\\\" 这个 topic 进行路由的过程。\",\"Broker 存储消息\",\"Broker 收到消息后，把消息写入 commit.log 文件，同时还有一个线程不断从 commit.log 中读取消息数据转发给消费队列。\",\"Consumer 消费消息\",\"Consumer 与 Broker 之间传递消息有两种方式:pull & push。其他的什么消费组，各种模式等等细节后续章节展开。\",\"RocketMQ 中，Consumer 消费消息是基于消费组 ConsumerGroup 开展的，一个消费组可以包含多个消费者，消费组可以订阅多个 Topic。\",\"消费组 ConsumerGroup 由 Consumer 组成，在不同的消费模式，消费组的行为并不一致。\",\"为了满足不同使用场景，RocketMQ 提供了两种消费模式：集群模式、广播模式。\",\"集群模式就是把消费组内的所有 Consumer 视为一个集群，同一个 Topic 下的同一条消息只能被其中一个 Consumer 消费，换句话说就是一条消息只能被集群（也就是 ConsumerGroup）消费一次。\",\"广播模式则是把消费组内的 Consumer 视为不同个体，一条消息可以被所有 Consumer 消费。\",\"Consumer 获取消息有两种模式: pull & push。\",\"拉模式： Consumer 主动向 Broker 发送拉取消息的请求。\",\"推模式： Broker 主动向 Consumer 推送消息，但实际上 Broker 不会向 Consumer 推送消息，推模式依然是 Consumer 自己去 pull，这里推拉两种模式主要是从使用角度，后续中展开细说。\"]},\"78\":{\"h\":\"前置要求\",\"t\":[\"阅读官方文档，完成 RocketMQ 的本地部署，并尝试发送和消费消息。下一节将从发送消息入手进行源码分析。\\n\"]},\"79\":{\"h\":\"RocketMQ 源码分析-NameSrv\",\"t\":[\"注\",\"NameSrv 比较简单，这是由它的设计决定的。 本文会以自顶向下的方式来介绍 NameSrv 的角色和功能。\"]},\"80\":{\"h\":\"概述\",\"t\":[\"RocketMQ 是一个分布式的消息队列，分布式系统自然需要一个模块来负责“路由管理”、“服务注册与发现”。 NameSrv (NameServer) 就是负责这部分的模块。\",\"前文(发送消息) 中提到了 Client 发送消息时会去 Namesrv 拉数据(updateTopicRouteInfoFromNameServer)， 确认发给哪个 Broker 的哪个 Queue。这部分就类似路由功能。\",\"Broker 启动时会把自身注册到 NameSrv，如果是 NameSrv Cluster，那就注册到所有到 NameSrv 上。NameSrv 与 Broker 之间保持长连接，10秒检测一次 Broker 是否存活，当检测的 Broker 挂掉时则从自身的路由注册表中删除该 Broker。这部分就类似“服务注册发现”。\",\"NameSrv 与常见的“服务注册发现”不太一样的地方是，它的各个节点之间并不会互相通信，就比如无论是 Eureka 还是 nacos ，他们是会相互同步信息最终数据一致的，但是 NameSrv 并不会，这是 RocketMQ 的特点之一，虽然可能会导致短暂的发送到各个 Broker 的消息不均匀，但这是可以接受的。\"]},\"81\":{\"h\":\"Namesrv 的基本组成介绍\",\"t\":[\"Namesrv 本身是个基于 netty 的服务端。\",\"NamesrvController 负责初始化 netty 服务器，以及启动各种定时任务。\",\"processor 包里是各种事件的 Handler(netty 语境)。\",\"BrokerHousekeepingService 这个说是 Service ，本质是个 ChannelEventListener，只不过他监听的 Channel 状态大部分与清理无效 Broker 相关。\",\"RouteInfoManager 主要就是维护以下五个数据表：\",\" private final HashMap<String/* topic */, List<QueueData>> topicQueueTable; private final HashMap<String/* brokerName */, BrokerData> brokerAddrTable; private final HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable; private final HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable; private final HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; \",\"可以看到，Broker / BrokerCluster / Topic 等信息都由 RouteInfoManager 进行管理。\",\"注\",\"前文中提到由于 NameSrv 集群中，各个 NameSrv 之间并不会相互通信，因此会有短暂的路由信息不一致，从而导致消费发送存在少量的不均匀。\",\"注意\",\"NameSrv 的路由注册表发生变化时并不会通知消息生产者(后简称P)，如果实际场景有要求，P 端需要在发送消息时提供容错来保证消息发送成功。\"]},\"82\":{\"h\":\"源码分析\",\"t\":[\"对 NameSrv 有了大体认识之后我们来挨个看细节。\"]},\"83\":{\"h\":\"启动流程\",\"t\":[\"实际就是启动一个 NettyServer，大致流程为： NamesrvStartup.class 是启动类 -> main() -> main0() -> 创建 NamesrvController 的对象，启动该对象.\",\"main0() 里会先创建一个 NamesrvController 的对象（其实就是自定义的 NettyServer）。 这个过程中会处理命令行参数/配置文件啥的，就把各种需要的参数/配置都准备好。\",\" // main0 NamesrvController controller = createNamesrvController(args); \",\"创建好 controller 之后接下来就启动它，也就是 start(controller);。\",\"这里会先执行 controller.initialize() 进行初始化工作，加载准备好的配置信息啦、创建 NettyServer 对象啦、创建线程池、启动定时任务等等，全部成功之后 controller.start(); 才真正启动服务器。\"]},\"84\":{\"h\":\"检测心跳\",\"t\":[\"每 10s 扫描一次 brokerLiveTable，如果发现过期的 broker，则删除。这个是controller.initialize()初始化时启动的定时任务之一。\",\"brokerLiveTable 是前面说的 RouteInfoManager 管理数据表之一，数据结构为 HashMap ，Key 是 broker 的地址，Value 是 Broker 对应的信息。\",\"HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable; \",\"每 10s 扫描一次 brokerLiveTable 的工作就是这里处理的，它单独起个线程 10 秒扫描一次（下方源码）。\",\"// scheduledExecutorService private final ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl( \\\"NSScheduledThread\\\")); // 为了方便阅读 我这里改成了 lambda 表达式 this.scheduledExecutorService.scheduleAtFixedRate(() -> NamesrvController.this.routeInfoManager.scanNotActiveBroker(), 5, 10, TimeUnit.SECONDS); \",\"注\",\"broker 默认是 30s 向 NameSrv 发一次心跳包。 NameSrv 10 秒扫一次它维护的 brokerLiveTable。\",\"扫描时对 Broker 进行判定，判断 broker 是否存活的逻辑：上次收到心跳包的时间 + 120s < 系统当前时间。 翻译一下其实就是：2分钟没收到过 broker 发来的心跳包就认为这个 broker 挂了，代码如下：\",\" // last 来自 BrokerLiveInfo.lastUpdateTimestamp，aka，上次收到心跳包的时间 // BROKER_CHANNEL_EXPIRED_TIME = 120s，也就是 broker_Channel 过期时间 (last + BROKER_CHANNEL_EXPIRED_TIME) < System.currentTimeMillis() \",\"最后来看看他是如何删除 broker 信息的，RouteInfoManager::scanNotActiveBroker。\",\" // RouteInfoManager::scanNotActiveBroker Iterator<Entry<String, BrokerLiveInfo>> it = this.brokerLiveTable.entrySet().iterator(); while (it.hasNext()) { Entry<String, BrokerLiveInfo> next = it.next(); long last = next.getValue().getLastUpdateTimestamp(); if ((last + BROKER_CHANNEL_EXPIRED_TIME) < System.currentTimeMillis()) { // 先尝试主动关闭 channel，内部逻辑就是 netty 的 closeChannel，添加了一个 listener 监控，成功关闭时打印 log // 注意这里的 Channel 是 netty 定义的(io.netty.channel.Channel)，不是 Java NIO 那个 RemotingUtil.closeChannel(next.getValue().getChannel()); // 从 brokerLiveTable 中删除过期 broker 信息 it.remove(); log.warn(\\\"The broker channel expired, {} {}ms\\\", next.getKey(), BROKER_CHANNEL_EXPIRED_TIME); // 从方法命名看应该是 Channel 关闭后触发的方法 // 正常使用方式应该是通过 BrokerHousekeepingService 定义的监控去调用， // 类似前面给 close 方法加个 Listener，监控关闭成功，然后打印关闭日志。 // 然鹅这里不知道为何就这么直接调用了，不过这条流程本来就写的很成问题，不必深究 // 这个方法是从 RouteInfoManager 维护的五个数据表里删除过期 broker 的对应信息。 this.onChannelDestroy(next.getKey(), next.getValue().getChannel()); } } \",\"RouteInfoManager##onChannelDestroy方法主要功能就是前面注释里说的从 RouteInfoManager 维护的五个数据表里删除过期 broker 的对应信息，这个方法正常的调用方式是通过 BrokerHousekeepingService 这个 ChannelEventListener 注册到 channel 的不同状态上去调用，比如:\",\"public void onChannelClose(String remoteAddr, Channel channel) { this.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel); } \",\"而不应该像 RouteInfoManager::scanNotActiveBroker 里面那样直接调用，源码里也就这么一处是直接调用。 然后你自然会发现，这一处不规范导致多了一堆迷一样的判定，代码可读性迅速降低。\",\" public void onChannelDestroy(String remoteAddr, Channel channel) { String brokerAddrFound = null; // 遍历 brokerLiveTable，根据 channel 找 brokerAddr if (channel != null) { try { try { // 加读锁 这里的 this.lock 就是 JUC 提供的可重入读写锁 ReentrantReadWriteLock this.lock.readLock().lockInterruptibly(); // 迭代器 Iterator<Entry<String, BrokerLiveInfo>> itBrokerLiveTable = this.brokerLiveTable.entrySet().iterator(); // 开始遍历 while (itBrokerLiveTable.hasNext()) { Entry<String, BrokerLiveInfo> entry = itBrokerLiveTable.next(); // 根据 channel 找对应的 brokerAddr 信息 if (entry.getValue().getChannel() == channel) { // 把找到的 brokerAddr 存到 brokerAddrFound 后面要用 brokerAddrFound = entry.getKey(); break; } } } finally { this.lock.readLock().unlock(); // 取消读锁 } } catch (Exception e) { log.error(\\\"onChannelDestroy Exception\\\", e); } } // 无法根据 channel 找到 brokerAddr 时，则直接使用 remoteAddr 参数 // remoteAddr 参数 就是要删除的 brokerAddr if (null == brokerAddrFound) { brokerAddrFound = remoteAddr; } else { log.info(\\\"the broker's channel destroyed, {}, clean it's data structure at once\\\", brokerAddrFound); } // 从五个数据表 中删除 broker 的相关信息。 if (brokerAddrFound != null && brokerAddrFound.length() > 0) { try { try { this.lock.writeLock().lockInterruptibly(); // 写锁 // 从 brokerLiveTable 中删除 this.brokerLiveTable.remove(brokerAddrFound); // 从 filterServerTable 中删除 this.filterServerTable.remove(brokerAddrFound); String brokerNameFound = null; boolean removeBrokerName = false; Iterator<Entry<String, BrokerData>> itBrokerAddrTable = this.brokerAddrTable.entrySet().iterator(); while (itBrokerAddrTable.hasNext() && (null == brokerNameFound)) { // brokerData 里存的是 broker 主从集群的信息 BrokerData brokerData = itBrokerAddrTable.next().getValue(); // 主从集群的迭代器，Long 对应 brokerID, String 对应 brokerAddr Iterator<Entry<Long, String>> it = brokerData.getBrokerAddrs().entrySet().iterator(); // 从主从集群里删除无效 broker while (it.hasNext()) { Entry<Long, String> entry = it.next(); Long brokerId = entry.getKey(); String brokerAddr = entry.getValue(); if (brokerAddr.equals(brokerAddrFound)) { brokerNameFound = brokerData.getBrokerName(); it.remove(); log.info(\\\"remove brokerAddr[{}, {}] from brokerAddrTable, because channel destroyed\\\", brokerId, brokerAddr); break; } } if (brokerData.getBrokerAddrs().isEmpty()) { // broker 主从集群为空的话，设置 removeBrokerName 为 true，后面还要根据这个标记来判断是否要删除对应的 Topic removeBrokerName = true; itBrokerAddrTable.remove(); log.info(\\\"remove brokerName[{}] from brokerAddrTable, because channel destroyed\\\", brokerData.getBrokerName()); } } // 跟前面区别不大，这里是从 clusterAddrTable 中删除 cluster 以及这个 cluster 包含的 broker if (brokerNameFound != null && removeBrokerName) { Iterator<Entry<String, Set<String>>> it = this.clusterAddrTable.entrySet().iterator(); while (it.hasNext()) { Entry<String, Set<String>> entry = it.next(); String clusterName = entry.getKey(); Set<String> brokerNames = entry.getValue(); boolean removed = brokerNames.remove(brokerNameFound); if (removed) { log.info(\\\"remove brokerName[{}], clusterName[{}] from clusterAddrTable, because channel destroyed\\\", brokerNameFound, clusterName); if (brokerNames.isEmpty()) { log.info(\\\"remove the clusterName[{}] from clusterAddrTable, because channel destroyed and no broker in this cluster\\\", clusterName); it.remove(); } break; } } } // 从 topicQueueTable 中删除 对应的 topic if (removeBrokerName) { Iterator<Entry<String, List<QueueData>>> itTopicQueueTable = this.topicQueueTable.entrySet().iterator(); while (itTopicQueueTable.hasNext()) { Entry<String, List<QueueData>> entry = itTopicQueueTable.next(); String topic = entry.getKey(); List<QueueData> queueDataList = entry.getValue(); Iterator<QueueData> itQueueData = queueDataList.iterator(); while (itQueueData.hasNext()) { QueueData queueData = itQueueData.next(); if (queueData.getBrokerName().equals(brokerNameFound)) { itQueueData.remove(); log.info(\\\"remove topic[{} {}], from topicQueueTable, because channel destroyed\\\", topic, queueData); } } if (queueDataList.isEmpty()) { itTopicQueueTable.remove(); log.info(\\\"remove topic[{}] all queue, from topicQueueTable, because channel destroyed\\\", topic); } } } } finally { this.lock.writeLock().unlock(); } } catch (Exception e) { log.error(\\\"onChannelDestroy Exception\\\", e); } } } \"]},\"85\":{\"h\":\"10分钟打印一次配置信息\",\"t\":[\"就是打印 KVConfigManager 管理的配置信息。 略。\"]},\"86\":{\"h\":\"RouteInfoManager\",\"t\":[\"Namesrv 承担着类似服务发现/路由的功能，RouteInfoManager 这个类就可以看作是路由功能的实现。\"]},\"87\":{\"h\":\"五个数据表介绍\",\"t\":[\"前面说了，它维护了五个数据表：\",\" private final HashMap<String/* topic */, List<QueueData>> topicQueueTable; private final HashMap<String/* brokerName */, BrokerData> brokerAddrTable; private final HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable; private final HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable; private final HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; \",\"注\",\"简单了解一下 RocketMQ 的基本概念，可以帮助理解 RouteInfoManager 维护了些什么东西\",\"RocketMQ 主要基于订阅/发布机制，一个 topic 可以拥有多个 Queue，一个 Broker 默认情况下会为每个 topic 创建 4个 readQueue 和 4个 writeQueue。\",\"多个 brokerName 相同的 broker 可以组成一个主从集群，这个主从集群的集群名存储在 cluster 中。 主从 broker 之间通过 brokerID 进行区分，一个 broker 的 brokerID = 0l，则为主节点；brokerID > 0l 时为从节点。\",\"接下来分别看一下这五个数据表。\"]},\"88\":{\"h\":\"topicQueueTable\",\"t\":[\"private final HashMap<String/* topic */, List<QueueData>> topicQueueTable;\",\"这个数据表里存储的是每个 topic 和自身所对应的 broker + queue 的信息列表。 换句话说这个是 topic 的路由表，发送消息时会根据这个表进行负载均衡。\",\"// QueueData private String brokerName; private int readQueueNums; private int writeQueueNums; private int perm; // 读写权限 private int topicSysFlag; // topic 同步标记 \",\"brokerAddrTable\",\"private final HashMap<String/* brokerName */, BrokerData> brokerAddrTable;\",\"这个里面存的是 BrokerName 和它对应的 broker 主从集群信息。 如果一个 broker 的 brokerId 为 0L，那它就是主broker。\",\"// BrokerData private String cluster; private String brokerName; private HashMap<Long/* brokerId */, String/* broker address */> brokerAddrs; \",\"clusterAddrTable\",\"private final HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable;\",\"这个就是集群路由表，clusterName 和属于该集群的所有 broker 的 brokerName 集合一一映射。\",\"brokerLiveTable\",\"private final HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable;\",\"brokerAddr 和其对应的存活信息（BrokerLiveInfo）。 每次 Namesrv 收到 broker 发来的心跳包后都会根据 brokerAddr 来更新对应的 BrokerLiveInfo。\",\"filterServerTableprivate final HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable;\",\"这个是 brokerAddr 与 FilterServer列表的对应关系。\"]},\"89\":{\"h\":\"注册/更新 Broker 信息\",\"t\":[\"Broker 每隔30秒向 Namesrv 集群发送一次心跳包（启动时也会发送一次），Namesrv 收到心跳包后会去更新对应的 BrokerLiveInfo，具体的说是更新上一次收到该 broker 发来心跳包的时间戳(BrokerLiveInfo.lastUpdateTimestamp)。 同时 Namesrv 会每隔10秒扫描一次整个 brokerLiveTable，如果任意 broker 的 lastUpdateTimestamp 超过120秒没有更新过则从所有数据表中删除该 Broker 的信息，同时关闭 Channel (Netty语境)，或者说是关闭 Socket 连接。\",\"Broker 发送心跳包\",\"这部分源码分析放到 Broker 章节，其实这部分如果熟悉 Netty 的话就挺简单的，就是发个请求，不熟悉的话最好先看看 Netty。\",\"Namesrv 处理心跳包\",\"由于 RocketMQ 是基于 Netty 来进行网络通信的，而对于 Netty 来说，所有的“请求”都是 Socket 传入的数据包。因此要区分不同“请求”，通常的做法是发送数据的时候额外携带“请求类型”， 通过 Decoder 解码数据后再判定是什么类型的\\\"请求\\\"。\",\"客户端发送请求时候将请求类型+请求参数一起通过编码器（Encoder）编码为 byte 数组（或者理解为二进制数据，就像 Redis 那样，这样当 NettyServer 收到数据包时，先通过解码器(Decoder)解码为 Java 对象，然后就可以判断请求类型了。\",\"这个过程也是通讯协议从设计到实践的过程，有兴趣可以在自己的 netty demo 里面先自定义一个协议，然后手动实践一下。\",\"注\",\"这里提到的 Encoder/Decoder 以及后续判断请求类型这些在 Netty 语境都是不同的 handler。\",\"RocketMQ 的习惯是把 handler 都放在 processor 包下面，所以有了上面的基础知识我们就知道去哪里找 Namesrv 处理心跳包的逻辑了。\",\"org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor就是我们要找的类。\",\"这个类也简单，可以先大概浏览一遍，就是processRequest()方法里面通过 switch (request.getCode())来判断请求类型，然后根据请求类型转发给后续处理方法。\",\"org.apache.rocketmq.common.protocol.RequestCode里面定义了所有的请求类型CODE。 我们这里要关注的是 Broker 发来的注册请求，所以你搜 BROKER 或者 REGISTER 就可以了。\",\"case RequestCode.REGISTER_BROKER: Version brokerVersion = MQVersion.value2Version(request.getVersion()); if (brokerVersion.ordinal() >= MQVersion.Version.V3_0_11.ordinal()) { return this.registerBrokerWithFilterServer(ctx, request); } else { return this.registerBroker(ctx, request); } \",\"可以看到它提供了两个注册方法，一个是带 FilterServer 模式的，一个是普通的注册。 这里只分析this.registerBroker(ctx, request);。\",\" // 首先这里的入参不用管，就是 netty 中典型的 handler 方法，看过 netty 自然秒懂 public RemotingCommand registerBroker(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { // 从这里开始跳过 都是 netty 构造数据包的内容 final RemotingCommand response = RemotingCommand.createResponseCommand(RegisterBrokerResponseHeader.class); final RegisterBrokerResponseHeader responseHeader = (RegisterBrokerResponseHeader) response.readCustomHeader(); final RegisterBrokerRequestHeader requestHeader = (RegisterBrokerRequestHeader) request.decodeCommandCustomHeader(RegisterBrokerRequestHeader.class); if (!checksum(ctx, request, requestHeader)) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"crc32 not match\\\"); return response; } TopicConfigSerializeWrapper topicConfigWrapper; if (request.getBody() != null) { topicConfigWrapper = TopicConfigSerializeWrapper.decode(request.getBody(), TopicConfigSerializeWrapper.class); } else { topicConfigWrapper = new TopicConfigSerializeWrapper(); topicConfigWrapper.getDataVersion().setCounter(new AtomicLong(0)); topicConfigWrapper.getDataVersion().setTimestamp(0); } // 以上都不用看，编码解码校验请求，不懂的先去看 Netty RegisterBrokerResult result = this.namesrvController.getRouteInfoManager().registerBroker( requestHeader.getClusterName(), requestHeader.getBrokerAddr(), requestHeader.getBrokerName(), requestHeader.getBrokerId(), requestHeader.getHaServerAddr(), topicConfigWrapper, null, ctx.channel() ); // 这里开始往后也不用看，就是构造 response 的数据包 responseHeader.setHaServerAddr(result.getHaServerAddr()); responseHeader.setMasterAddr(result.getMasterAddr()); byte[] jsonValue = this.namesrvController.getKvConfigManager().getKVListByNamespace(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG); response.setBody(jsonValue); response.setCode(ResponseCode.SUCCESS); response.setRemark(null); return response; } \",\"所以你看DefaultRequestProcessor就是转发了一下注册请求，真正处理注册逻辑的是RouteInfoManager::registerBroker。 下面来看这部分代码：\",\"public RegisterBrokerResult registerBroker( final String clusterName, final String brokerAddr, final String brokerName, final long brokerId, final String haServerAddr, final TopicConfigSerializeWrapper topicConfigWrapper, final List<String> filterServerList, final Channel channel) { RegisterBrokerResult result = new RegisterBrokerResult(); try { try { // RouteInfoManager 中维护的五个数据表都是 HashMap // 并且通过前面的代码我们知道会有一个线程定期扫描并剔除无效 broker，五个表都有涉及。 // 所以修改前一定要加锁防止并发问题 this.lock.writeLock().lockInterruptibly(); // -------------- 处理 clusterAddrTable --------------------- // 先判断 发送请求的 Broker 所属集群是否存在，如果不存在就添加集群 Set<String> brokerNames = this.clusterAddrTable.get(clusterName); if (null == brokerNames) { brokerNames = new HashSet<String>(); this.clusterAddrTable.put(clusterName, brokerNames); } brokerNames.add(brokerName); // -------------- clusterAddrTable 完成 -------------------- // -------------------- 处理 brokerAddrTable -------------------- boolean registerFirst = false; // 先确认 brokerName 对应的 brokerData 是否存在，如果不存在则创建。 BrokerData brokerData = this.brokerAddrTable.get(brokerName); if (null == brokerData) { // 这里标记为首次注册，因为当 brokerAddrTable 里连 BrokerData 都没有，说明这个主从集群里一台 broker 都没有 registerFirst = true; brokerData = new BrokerData(clusterName, brokerName, new HashMap<Long, String>()); this.brokerAddrTable.put(brokerName, brokerData); } Map<Long, String> brokerAddrsMap = brokerData.getBrokerAddrs(); /* 注册过程中，如果发起注册请求的 broker 是已经存在于 brokerAddrTable 的 slave broker, 但是请求参数 brokerID 为0的话，会发生主从交换。 实际上交换不太准确，类似晋升，因为这时候 master 已经挂了，slave broker 现在作为 master 来重新注册而已。 因此处理逻辑只需要先删除掉原来的 slave broker 信息，然后重走一次注册流程即可。 */ //Switch slave to master: first remove <1, IP:PORT> in namesrv, then add <0, IP:PORT> //The same IP:PORT must only have one record in brokerAddrTable Iterator<Entry<Long, String>> it = brokerAddrsMap.entrySet().iterator(); while (it.hasNext()) { Entry<Long, String> item = it.next(); if (null != brokerAddr && brokerAddr.equals(item.getValue()) && brokerId != item.getKey()) { it.remove(); } } // 再次判断是否为首次注册 String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr); // oldAddr == null 就回到了前面第一次标记的情况 // oldAddr != null 那说明有新的 broker 代替了该 brokerID 对应的旧 broker，这是第二种首次注册的情况 registerFirst = registerFirst || (null == oldAddr); // Broker 为 主节点，并且该 Broker 对应的 topicConfig 信息发生变化(包括首次注册) // 这个情况下，需要创建/更新该 Broker 对应的 Topic 信息。 // 说白了就是维护 topicQueueTable 中与该 Broker 相关的信息。 if (null != topicConfigWrapper && MixAll.MASTER_ID == brokerId) { if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || registerFirst) { ConcurrentMap<String, TopicConfig> tcTable = topicConfigWrapper.getTopicConfigTable(); if (tcTable != null) { for (Map.Entry<String, TopicConfig> entry : tcTable.entrySet()) { // 这个方法就不详细展开了，其内容就是 // 1. 利用 brokerName 和 topicConfig（aka entry.getValue()）来组装 queueData // 2. topicQueueTable 利用 topicConfig.getTopicName() 来判断该 topic 的信息是否存在 // 3. 不存在就把这个 topic 注册进来，存在就更新 this.createAndUpdateQueueData(brokerName, entry.getValue()); } } } } // 这里就是之前心跳包时候说的，更新 brokerLiveTable BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr, new BrokerLiveInfo( System.currentTimeMillis(), topicConfigWrapper.getDataVersion(), channel, haServerAddr)); if (null == prevBrokerLiveInfo) {// 首次注册 log.info(\\\"new broker registered, {} HAServer: {}\\\", brokerAddr, haServerAddr); } // filterServer 模式 if (filterServerList != null) { if (filterServerList.isEmpty()) { this.filterServerTable.remove(brokerAddr); } else { this.filterServerTable.put(brokerAddr, filterServerList); } } if (MixAll.MASTER_ID != brokerId) { String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID); if (masterAddr != null) { BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr); if (brokerLiveInfo != null) { result.setHaServerAddr(brokerLiveInfo.getHaServerAddr()); result.setMasterAddr(masterAddr); } } } } finally { this.lock.writeLock().unlock(); } } catch (Exception e) { log.error(\\\"registerBroker Exception\\\", e); } return result; } \"]},\"90\":{\"h\":\"注销/删除 Broker 信息\",\"t\":[\"Namesrv 注销 broker 分两种情况：\",\"120秒没收到 broker 发来的心跳包，自动删除，这个前面分析过了。\",\"Broker 正常关闭时会给 Namesrv 发出注销请求（unregisterBroker）。\",\"有兴趣的话可以按照之前分析 broker 注册的思路在 Namesrv 的代码中找到如下方法自行分析。 \",\"public RemotingCommand unregisterBroker(ChannelHandlerContext ctx, RemotingCommand request) \",\"两种情况下，Namesrv 的处理逻辑是一致的，都是从RouteInfoManager 维护的数据表中删除/更新与该 broker 相关的信息，\\n唯一的区别就是 broker 正常注销的话，Namesrv 不会主动关闭 channel，因为他要给 Broker 返回注销成功的 response。\"]},\"91\":{\"h\":\"RocketMQ 源码分析-发送消息\",\"t\":[\"这里开始详细聊聊 RocketMQ 发送消息的各种细节。\",\"前面在简介里面说了，从使用者的角度，Producer 看起来就是直接往 Topic 里面塞消息。而实际上呢，要先去 Namesrv 找到 Topic 的路由信息，然后才能确定 Topic 是由哪个 Broker 管理。\",\"发送消息支持三种方式，同步、异步、单向，区别很简单不再赘述，下文以同步为例进行分析。\"]},\"92\":{\"h\":\"前置要求\",\"t\":[\"这里就假设读者已经顺利完成了 quick start 中的内容，收发消息已经全部成功。\"]},\"93\":{\"h\":\"源码分析\",\"t\":[\"整个过程以描述+代码注释的方式进行。\"]},\"94\":{\"h\":\"从发送消息开始\",\"t\":[\"下面贴了一段简单的发送消息的代码，逻辑很简单，先创建并启动 producer， 然后发送消息。\",\"// 创建 Producer DefaultMQProducer producer = new DefaultMQProducer(\\\"ProducerGroupName\\\"); producer.start(); // 启动 - 这是个 netty client for (int i = 0; i < 128; i++) try { { // 构造消息 Message msg = new Message(\\\"TopicTest\\\", \\\"TagA\\\", \\\"OrderID188\\\", \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); // 发送消息，这里是以同步的方式拿到返回结果。 // 异步则是通过 callback // 单向则不关心结果 SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } } catch (Exception e) { e.printStackTrace(); } producer.shutdown(); // 关闭 \",\"确实非常简单对吧，接下来进入 producer.start(); 方法。\"]},\"95\":{\"h\":\"producer.start()\",\"t\":[\"producer 是 DefaultMQProducer 的实例，于是我们来看 DefaultMQProducer 是啥。\"]},\"96\":{\"h\":\"DefaultMQProducer\",\"t\":[\"分析一个类就跟我们自己写一个类的流程差不多，先看他的属性和构造方法，然后再去看他的功能，也就是提供了哪些方法。\",\"属性\",\"源码中这部分是有注释的，可以先自己过一遍源码。\",\" protected final transient DefaultMQProducerImpl defaultMQProducerImpl; // 重试的响应码 private final Set<Integer> retryResponseCodes = new CopyOnWriteArraySet<Integer>(Arrays.asList( ResponseCode.TOPIC_NOT_EXIST, ResponseCode.SERVICE_NOT_AVAILABLE, ResponseCode.SYSTEM_ERROR, ResponseCode.NO_PERMISSION, ResponseCode.NO_BUYER_ID, ResponseCode.NOT_IN_CURRENT_UNIT )); // 生产者组，这个概念后面细说 private String producerGroup; // 这就是自动创建主题机制的那个 Topic private String createTopicKey = TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC; // 前面 Namesrv 里提过，一个 Broker 默认情况下会为每个 topic 创建 4个 readQueue 和 4个 writeQueue。 private volatile int defaultTopicQueueNums = 4; private int sendMsgTimeout = 3000; // 这个是压缩消息的阈值，Message.body 的大小超过 4k 就进行压缩 private int compressMsgBodyOverHowmuch = 1024 * 4; // 发送消息失败会重试两次（总共最多发3次） 后面细说 private int retryTimesWhenSendFailed = 2; // 这是发送异步消息失败也是重试两次 // 源码注释里写了，这里也先提一下，异步消息失败的重试机制可能会造成消息重复发送。 private int retryTimesWhenSendAsyncFailed = 2; // 这个是消息发送失败时，是否切换另外的 broker private boolean retryAnotherBrokerWhenNotStoreOK = false; // 消息大小的上限 aka 4M private int maxMessageSize = 1024 * 1024 * 4; // 这个先无视 private TraceDispatcher traceDispatcher = null; \",\"构造方法\",\"数了一下...有10个构造方法，就不全贴出来了，只看这一个就行。\",\"public DefaultMQProducer(final String namespace, final String producerGroup, RPCHook rpcHook) { this.namespace = namespace; this.producerGroup = producerGroup; defaultMQProducerImpl = new DefaultMQProducerImpl(this, rpcHook); } \",\"可以看出来 DefaultMQProducer 其实就是对 DefaultMQProducerImpl 做了一层包装，他的其他方法就不列出来了，可以自己观察一下，这里我们直接去看 DefaultMQProducer::start()。\"]},\"97\":{\"h\":\"DefaultMQProducer::start()\",\"t\":[\"// DefaultMQProducer::start() public void start() throws MQClientException { this.setProducerGroup(withNamespace(this.producerGroup)); // 实际实现启动的是 DefaultMQProducerImpl 类 this.defaultMQProducerImpl.start(); if (null != traceDispatcher) { try { traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel()); } catch (MQClientException e) { log.warn(\\\"trace dispatcher start failed \\\", e); } } } \",\"接下来进入 DefaultMQProducerImpl::start()。\"]},\"98\":{\"h\":\"DefaultMQProducerImpl::start()\",\"t\":[\"public void start() throws MQClientException { this.start(true); } \",\"public void start(final boolean startFactory) throws MQClientException { // 起手就是个 switch switch (this.serviceState) { // serviceState 属性默认是 CREATE_JUST // 而无论是 DefaultMQProducerImpl 或者 DefaultMQProducer 的构造方法中都没有修改该属性的操作，所以我们的 producer.start() 肯定会进入 CREATE_JUST 分支。 case CREATE_JUST: // 进来之后直接先标记为 “启动失败” 的状态。 this.serviceState = ServiceState.START_FAILED; /* --- 校验开始 --- */ // 然后开始检查配置，实际就是检查 producerGroup 是否存在，是不是默认的 \\\"DEFAULT_PRODUCER\\\" ，不符合要求就抛个异常提醒用户修改。 // 比如 new DefaultMQProducer();时没有自定义 producerGroup 时，rocketmq 会默认你的 producerGroup 为 “DEFAULT_PRODUCER”， 之后代码运行到这里就抛异常了 this.checkConfig(); // 这段判定的作用跟上面的 this.checkConfig(); 其实差不多，也是提醒你要自定义 producerGroup。 // 只要 ProducerGroup 不等于 \\\"CLIENT_INNER_PRODUCER\\\" // 这个默认值是走 MQClientInstance 初始化 producer 用的。 if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) { // 这里要做的事情就是 如果 InstanceName 为 \\\"DEFAULT\\\" 就改成 Pid#TimeStamp 的形式。 // 目的是为了区分不同的 producer 实例 this.defaultMQProducer.changeInstanceNameToPID(); } /* --- 校验结束 --- */ /** 创建 MQ客户端的实例，这里简单说一下 MQClientInstance 是个啥，本质上就是 netty 客户端 + RocketMQ 自身的需求实现。 注意这里说的客户端/client 的概念是不区分 Consumer 和 Producer ，这两种角色都看作客户端。 MQClientManager ，他里面维护了一个 clientID 和 MQClientInstance 一一对应的 kv 结构，这里为了满足并发的需要用的是 ConcurrentHashMap。 */ /* 然后我们来看代码， MQClientManager.getInstance() 返回的是 MQClientManager 的 getOrCreateMQClientInstance() 返回的是 MQClientInstance 。 也就是前面说的 netty 客户端。 getOrCreateMQClientInstance 方法的逻辑是 key(clientId) 对应的 value(MQClientInstance) 存在则直接返回，不存在则创建后返回。 */ // 创建 instance // 无视掉 mQClientFactory 这个变量名，就是个 instance. this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook); /* MQClientInstance 创建好了，但是 Instance 的角色还不明确，前面说了，它可以是生产者也可以是消费者，这里 registerProducer 就是给 MQClientInstance 明确身份 registerProducer() 方法就是把刚创建的这个 MQClientInstance 注册到其内部维护的 producerTable 中 producerTable 也是 ConcurrentHashMap，他的 key 就是创建 Producer 时我们自定义的 ProducerGroup 一个 group 只对应一个 instance, 从这里我们就可以看出 ProducerGroup 这个 group 概念是基于集群的. 之后消费环节的 ConsumerGroup 同理 */ // 把 instance 注册到 producerTable，明确 instance 角色 boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this); if (!registerOK) { // ProducerGroup 和 MQClientInstance 一一对应，重复就会抛下面的异常 this.serviceState = ServiceState.CREATE_JUST; throw new MQClientException(\\\"The producer group[\\\" + this.defaultMQProducer.getProducerGroup() + \\\"] has been created before, specify another name please.\\\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL), null); } // 把 producer 的信息存入本地的 Topic 路由信息表中，并且初始化该 topic 的路由信息 this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo()); if (startFactory) { mQClientFactory.start(); // 最终可以看出，producer.start() 其实就是启动 netty 客户端。 } log.info(\\\"the producer [{}] start OK. sendMessageWithVIPChannel={}\\\", this.defaultMQProducer.getProducerGroup(), this.defaultMQProducer.isSendMessageWithVIPChannel()); // 将 ServiceState 修改为 运行中 this.serviceState = ServiceState.RUNNING; break; case RUNNING: case START_FAILED: case SHUTDOWN_ALREADY: throw new MQClientException(\\\"The producer service state not OK, maybe started once, \\\" + this.serviceState + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK), null); default: break; } // producer 发送首次心跳请求。 this.mQClientFactory.sendHeartbeatToAllBrokerWithLock(); // 启动定时任务，这个定时任务是扫描并移除 requestFutureTable 中的过期请求 // 初始启动延迟3秒，之后一秒执行一次 this.startScheduledTask(); } \",\"简单总结一下，创建 producer 并执行 producer.start() 的过程，实际上就是创建了一个自定义的 netty 客户端，标记为 Producer 角色，并且初始化其对应的 groupTable 和本地路由信息表，然后启动该客户端。客户端启动后发出首次心跳，并开启定时任务这个流程。\"]},\"99\":{\"h\":\"producer.send(Message msg)\",\"t\":[\"搞清楚了什么是 producer 和 producer.start() 都做了什么之后，接下来我们来看 producer.send()，也就是发送消息的流程。\"]},\"100\":{\"h\":\"DefaultMQProducer::send(Message msg)\",\"t\":[\" public SendResult send( Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 校验 msg Validators.checkMessage(msg, this); // 完善 Topic 信息 msg.setTopic(withNamespace(msg.getTopic())); return this.defaultMQProducerImpl.send(msg); } \",\"依然是包装。\"]},\"101\":{\"h\":\"DefaultMQProducerImpl::send(Message msg)\",\"t\":[\" public SendResult send( Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { return send(msg, this.defaultMQProducer.getSendMsgTimeout()); } \",\" public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 可以看到我们直接 producer.send(msg) 时，默认为同步的方式。 // CommunicationMode.SYNC return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout); } \",\"主要看 sendDefaultImpl() 方法：\",\" private SendResult sendDefaultImpl( Message msg, final CommunicationMode communicationMode, // 同步、异步、单向由该参数决定 final SendCallback sendCallback, final long timeout ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 校验 // 检查 ServiceState 是不是 RUNNING this.makeSureStateOK(); // 校验 msg 的合法性，是不是为空啊，是不是超过4m最大小限制等等。 // 跟 defaultMQProducer::send 里面那行校验是一样的是。 Validators.checkMessage(msg, this.defaultMQProducer); final long invokeID = random.nextLong(); // 用来算超时的各种时间戳变量 long beginTimestampFirst = System.currentTimeMillis(); long beginTimestampPrev = beginTimestampFirst; long endTimestamp = beginTimestampFirst; // tryToFindTopicPublishInfo 方法就是 Intro 中提到的 producer 发消息时的整个路由流程 // 前面看 producer.start() 时，结尾部分不是创建了一个空的路由信息么 new TopicPublishInfo() // 这个空的 topicPublishInfo 也在这里完成真正的初始化。 // 后面看 DefaultMQProducerImpl 时具体展开。 TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); // 本地路由表不为空 才继续执行 if (topicPublishInfo != null && topicPublishInfo.ok()) { boolean callTimeout = false; MessageQueue mq = null; Exception exception = null; SendResult sendResult = null; // timesTotal就是一条消息的发送总次数，同步模式下 最多3次，1是正常发送那一次，剩下的两次是默认的重试次数； // 非同步模式为1次，非同步模式就是单向和异步，单向自然就是一次，异步其实是可以重试的，也就是不止一次。 int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; int times = 0; /* 下面是发送流程 */ // brokersSent 发送次数 String[] brokersSent = new String[timesTotal]; for (; times < timesTotal; times++) // mq 里保存了 topic, brokerName, queueId 三项属性。 String lastBrokerName = null == mq ? null : mq.getBrokerName(); /* Broker 会为 Topic 创建多个 Queue，默认为 4个 readQueue 和 4个 writeQueue selectOneMessageQueue()这个方法这里不过多展开了，可以自己看一下。 */ // 根据路由信息找到用哪个 Queue，放在什么位置。 MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); if (mqSelected != null) { mq = mqSelected; brokersSent[times] = mq.getBrokerName(); try { beginTimestampPrev = System.currentTimeMillis(); if (times > 0) { //Reset topic with namespace during resend. msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic())); } long costTime = beginTimestampPrev - beginTimestampFirst; if (timeout < costTime) { callTimeout = true; break; } // 这里还是先不展开说明，概括一下就是 ENCODE 好数据包，然后执行 netty 的 writeAndFlush // sendKernelImpl 再下一层的代码不明白的可以去看一眼 Netty，过一遍 netty 的 quick start 再回来看毕竟好懂。 // 发送消息并拿到返回结果。 sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime); endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false); // 不同模式下返回结果的处理 switch (communicationMode) { case ASYNC: // 异步获取结果是利用 callback return null; case ONEWAY: // 单向发送不需要返回结果 return null; case SYNC: // 这里是我们要看的同步 if (sendResult.getSendStatus() != SendStatus.SEND_OK) { // 重试逻辑，这个变量名 =_= if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) { continue; } } return sendResult; default: break; } // 后面都是异常的处理啥的 } catch (RemotingException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true); log.warn(String.format(\\\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); exception = e; continue; } catch (MQClientException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true); log.warn(String.format(\\\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); exception = e; continue; } catch (MQBrokerException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true); log.warn(String.format(\\\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); exception = e; if (this.defaultMQProducer.getRetryResponseCodes().contains(e.getResponseCode())) { continue; } else { if (sendResult != null) { return sendResult; } throw e; } } catch (InterruptedException e) { endTimestamp = System.currentTimeMillis(); this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false); log.warn(String.format(\\\"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s\\\", invokeID, endTimestamp - beginTimestampPrev, mq), e); log.warn(msg.toString()); log.warn(\\\"sendKernelImpl exception\\\", e); log.warn(msg.toString()); throw e; } } else { break; } } if (sendResult != null) { return sendResult; } String info = String.format(\\\"Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s\\\", times, System.currentTimeMillis() - beginTimestampFirst, msg.getTopic(), Arrays.toString(brokersSent)); info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED); MQClientException mqClientException = new MQClientException(info, exception); if (callTimeout) { throw new RemotingTooMuchRequestException(\\\"sendDefaultImpl call timeout\\\"); } if (exception instanceof MQBrokerException) { mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode()); } else if (exception instanceof RemotingConnectException) { mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION); } else if (exception instanceof RemotingTimeoutException) { mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT); } else if (exception instanceof MQClientException) { mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION); } throw mqClientException; } validateNameServerSetting(); throw new MQClientException(\\\"No route info of this topic: \\\" + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO), null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION); } \",\"到此 producer.send() 的源码分析告一段落。\",\"前面说过，发送消息支持三种模式，同步、异步、单向。 从前面的代码中我们可以发现，无论那种，最终具体实现都是 defaultMQProducerImpl::sendDefaultImpl() 里完成的。同步和异步的区别主要是入参的不同以及异步需要 callback 获取返回结果。而单向跟同步一个逻辑，只不过返回值被无视了。\",\"文章最后稍微再补充一些关于 defaultMQProducerImpl 的内容。\",\"发送消息这里还有一个可以看一下，批量发送消息，也就是 DefaultMQProducer::batch()方法.\"]},\"102\":{\"h\":\"DefaultMQProducer::batch()`\",\"t\":[\"批量其实就是给单次发送的处理流程外面加了层循环。\",\"private MessageBatch batch(Collection<Message> msgs) throws MQClientException { // MessageBatch 内部结构就是 List<Message> messages; MessageBatch msgBatch; try { // 这里 generateFromList 其实主要是对消息集合进行过滤 // 不满足批量发送条件会直接抛异常 注意跟后面的 Validators.checkMessage 进行区分 msgBatch = MessageBatch.generateFromList(msgs); for (Message message : msgBatch) { // 校验消息合法性 非批量发送也有这一步 Validators.checkMessage(message, this); // 在 Message.properties 里添加一组 kv 参数 // UNIQ_KEY：具体的key值，就通过 ip + host + 类加载的 hashcode 啥的有兴趣自己去看 MessageClientIDSetter.setUniqID(message); // 设置 topic，非批量发送也有这一步 message.setTopic(withNamespace(message.getTopic())); } // 这里 msgBatch.encode() 就是对整个 messageList 进行 encode。 // 具体细节下面展开说 msgBatch.setBody(msgBatch.encode()); } catch (Exception e) { throw new MQClientException(\\\"Failed to initiate the MessageBatch\\\", e); } msgBatch.setTopic(withNamespace(msgBatch.getTopic())); return msgBatch; } \",\"通过代码可以看出batch()方法的逻辑就是把所有 message 加好对应的标记，之后批量 encode，然后存放到msgBatch.setBody等待发送。\",\" // msgBatch.encode() 就是调用 MessageDecoder.encodeMessages() public static byte[] encodeMessages(List<Message> messages) { //TODO refactor, accumulate in one buffer, avoid copies // 那个 TODO 是源码里的，无视掉就好了 // 创建一个 buffer list 用来存 encode 之后的 message。 List<byte[]> encodedMessages = new ArrayList<byte[]>(messages.size()); // 目前还不知道所有 message 加起来一共占用多大内存，所以初始化为0. int allSize = 0; // 这个循环，首先对 msg 逐条 encode。 // 然后把 encode 完的 msg 存到 buffer list里 // 之后累加计算所有 msg 最终需要多大的 buffer / 也就是内存。 for (Message message : messages) { byte[] tmp = encodeMessage(message); encodedMessages.add(tmp); allSize += tmp.length; } // 按照计算出的 size 分配内存 byte[] allBytes = new byte[allSize]; int pos = 0; /* 通过 System.arraycopy 来将前面 buff list， 也就是 encodedMessages，中的数据复制到 allBytes 中， 这个 allBytes 就是之后 msgBatch.setBody()的参数。 */ for (byte[] bytes : encodedMessages) { System.arraycopy(bytes, 0, allBytes, pos, bytes.length); pos += bytes.length; } return allBytes; } \"]},\"103\":{\"h\":\"DefaultMQProducerImpl\",\"t\":[\"接下来我们来看看 DefaultMQProducerImpl 类提供的各种具体实现，不过还是老样子，先看属性和构造方法。\",\"属性\",\" // 随机数 private final Random random = new Random(); // 外层的壳子 private final DefaultMQProducer defaultMQProducer; // 之前 intro 里面提过，Producer 本地是有缓存 topic 的路由信息的，就是存在这里。 //本地路由信息表。key: Topic, Value: TopicPublishInfo private final ConcurrentMap<String/* topic */, TopicPublishInfo> topicPublishInfoTable = new ConcurrentHashMap<String, TopicPublishInfo>(); // 存 hook 的 list private final ArrayList<SendMessageHook> sendMessageHookList = new ArrayList<SendMessageHook>(); private final ArrayList<EndTransactionHook> endTransactionHookList = new ArrayList<EndTransactionHook>(); // hook ，支持两个阶段，request 之前 和 request 之后 private final RPCHook rpcHook; // 异步发送时用的 workQueue 和 Executor private final BlockingQueue<Runnable> asyncSenderThreadPoolQueue; private final ExecutorService defaultAsyncSenderExecutor; // 定时任务的 Executor private final ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(r -> new Thread(r, \\\"RequestHouseKeepingService\\\")); // 这俩也是一套 workQueue + Executor。 protected BlockingQueue<Runnable> checkRequestQueue; protected ExecutorService checkExecutor; // 状态字段 代表 instance 刚刚创建 private ServiceState serviceState = ServiceState.CREATE_JUST; // instance private MQClientInstance mQClientFactory; private ArrayList<CheckForbiddenHook> checkForbiddenHookList = new ArrayList<CheckForbiddenHook>(); // 压缩级别 private int zipCompressLevel = Integer.parseInt(System.getProperty(MixAll.MESSAGE_COMPRESS_LEVEL, \\\"5\\\")); // 失败策略 private MQFaultStrategy mqFaultStrategy = new MQFaultStrategy(); private ExecutorService asyncSenderExecutor; \",\"构造方法\",\" public DefaultMQProducerImpl(final DefaultMQProducer defaultMQProducer, RPCHook rpcHook) { this.defaultMQProducer = defaultMQProducer; this.rpcHook = rpcHook; // 下面就是创建 workQueue 和 ThreadPoolExecutor this.asyncSenderThreadPoolQueue = new LinkedBlockingQueue<Runnable>(50000); this.defaultAsyncSenderExecutor = new ThreadPoolExecutor( Runtime.getRuntime().availableProcessors(), Runtime.getRuntime().availableProcessors(), 1000 * 60, TimeUnit.MILLISECONDS, this.asyncSenderThreadPoolQueue, new ThreadFactory() { private AtomicInteger threadIndex = new AtomicInteger(0); @Override public Thread newThread(Runnable r) { return new Thread(r, \\\"AsyncSenderExecutor_\\\" + this.threadIndex.incrementAndGet()); } }); } \",\"tryToFindTopicPublishInfo 方法\",\" private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) { // 从本地路由信息表里，根据 topic 取出对应的本地路由信息 TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic); if (null == topicPublishInfo || !topicPublishInfo.ok()) { // 如果 topic 的路由信息不存在 // 保护代码 this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo()); // 从 NameServer 上拉数据，更新本地路由信息表以及一系列相关信息。 // 这个方法是线程安全的。 这个展开也超长，有兴趣可以自己看一下 this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic); // 更新完本地路由信息表后重新取出 topic 的路由信息 topicPublishInfo = this.topicPublishInfoTable.get(topic); } // 路由信息存在，则直接返回。 if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) { return topicPublishInfo; } else { // 还不存在，再次去 broker 更新 this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer); topicPublishInfo = this.topicPublishInfoTable.get(topic); return topicPublishInfo; } } \",\"sendKernelImpl\",\"这里就是前面说的 producer.send() 方法\",\"// 这个可就太长了，只贴 switch 这段 switch (communicationMode) { case ASYNC: // 异步 Message tmpMessage = msg; boolean messageCloned = false; if (msgBodyCompressed) { //If msg body was compressed, msgbody should be reset using prevBody. //Clone new message using commpressed message body and recover origin massage. //Fix bug:https://github.com/apache/rocketmq-externals/issues/66 tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; msg.setBody(prevBody); } if (topicWithNamespace) { if (!messageCloned) { tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; } msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace())); } // 超时判断 long costTimeAsync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeAsync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), tmpMessage, requestHeader, timeout - costTimeAsync, communicationMode, sendCallback, topicPublishInfo, this.mQClientFactory, this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), context, this); break; case ONEWAY: case SYNC: long costTimeSync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeSync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } // 同步发送消息。 sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), msg, requestHeader, timeout - costTimeSync, communicationMode, context, this); break; default: assert false; break; } \",\"有兴趣的话可以从 this.mQClientFactory.getMQClientAPIImpl() 方法继续往下看， 再下面一层就是 netty 层了，如何封装 request/response，header/body，api 怎么写什么的。 最终你应该能找到对 NettyRemotingAbstract::invokeSyncImpl() 方法的调用，这个方法 里就能看到熟悉的 channel.writeAndFlush(request)。\"]},\"104\":{\"h\":\"总结\",\"t\":[\"本文以跟随 producer.send() 为主线，通过对源码进行跟踪来了解 producer 发送消息背后的整体逻辑和流程。\",\"PS. RocketMQ 的源码是真的很难读，后面的篇幅会进一步省略一些与主线逻辑关系不大的代码片段。\"]},\"105\":{\"h\":\"RocketMQ 源码分析-消息存储和持久化\",\"t\":[\"本文会先从概念上介绍 RocketMQ 消息存储的设计，为了达成设计目标实现了哪些机制，顺便补充一些背景知识方便读者理解机制的实现。之后会结合源码来详解具体机制的实现。\"]},\"106\":{\"h\":\"消息存储模块的设计概要与分析\",\"t\":[\"先笼统的解释 MQ 产品的方案，然后具体到 RocketMQ\"]},\"107\":{\"h\":\"常见持久化/存储方案简介\",\"t\":[\"任意应用的存储方案常见的基本上就三种：要么你直接使用文件系统进行数据存储，这个在桌面应用里很常见；要么使用各类 KV 存储，比如使用 redis 作为数据库并开启持久化；要么用关系型数据库，比如 MySQL。\",\"文件系统操作效率最高，但可靠性最低，经典场景就是“突然停电/死机/重启，我忘记保存了！！！”； KV存储方式基本介于中间，这也是为什么大家都喜欢在数据库前加一层 Redis；数据库可靠性最高，但是性能相对前两者最差，这也是为啥所有性能压力的场景我们都要想方设法不让请求直接打在数据库上，同时还要让数据库尽可能的具备更大的抗压能力。\"]},\"108\":{\"h\":\"RocketMQ 的持久化设计\",\"t\":[\"RocketMQ 作为一款分布式、高性能、高可用的消息队列产品，为了提供持久化能力，并且还要满足使用中可以通过多种方式查找消息的要求，它采用的是自研文件系统的方案。\",\"提示\",\"基于文件编程： 日常我们接触最多的是基于内存编程，就比如数组、链表、HashMap 这些数据结构的读写都是直接对内存操作。而文件编程则是对磁盘上的数据（文件）进行操作，这就跟内存编程产生了极大的不同。\",\"首先内存编程直接操作内存非常简单，而文件编程需要访问硬盘进行读写，这就来到了 I/O 的领域；然后是访问速读，内存的数据传输速读天然比硬盘要快，而且是数量级的快；硬盘的物理设计本身也会对数据读写有很大的影响，无论是普通硬盘还是SSD，进行文件编程时往往会对此进行特殊的优化，比如 MySQL InnoDB 引擎的默认索引的数据结构。\",\"RocketMQ 的自研文件系统，后面就叫他存储模块(rocketmq/store)，主要包括三种文件: CommitLog、ConsumeQueue、Index File。\",\"其中 CommitLog 文件采用顺序写的方式用于存储所有消息数据，它是最基础也是最核心的数据文件。ConsumeQueue 是为了提升消费效率的设计，当消息存入 CommitLog 后，会被异步转发至 ConsumeQueue 中，用于供给给消费端进行消费。Index 则是为快速检索/查找消息服务，它里面存储的是 msg key 与 offset 的关系。\",\"至此，我们可以对存储模块有个大致的认识，当 Broker 收到消息后，它会存入 CommitLog 进行持久化，同时异步转发给 ConsumeQueue 供客户端进行消费，当需要检索消息时，则通过 Index 定位消息在文件中的具体位置。\",\"接下来详细介绍一下这三种文件的具体信息。\"]},\"109\":{\"h\":\"存储模块的目录结构\",\"t\":[\"# 仅供参考 . ├── checkpoint ├── commitlog │ └── 00000000000000000000 ├── config │ ├── consumerFilter.json │ ├── consumerFilter.json.bak │ ├── consumerOffset.json │ ├── consumerOffset.json.bak │ ├── delayOffset.json │ ├── delayOffset.json.bak │ ├── subscriptionGroup.json │ ├── topics.json │ └── topics.json.bak ├── consumequeue │ └── TopicTest │ ├── 0 │ │ └── 00000000000000000000 │ ├── 1 │ │ └── 00000000000000000000 │ ├── 2 │ │ └── 00000000000000000000 │ └── 3 │ └── 00000000000000000000 ├── index └── lock \"]},\"110\":{\"h\":\"CommitLog\",\"t\":[\"对于文件编程，或者通俗的说就是往硬盘里写数据，最快的方式就是顺序写，这跟硬盘的物理设计有关（虽然 SSD 跟普通硬盘磁盘式的写入方式不同，导致顺序写比随机写快的原因不同，但结论一致）。\",\"为避免翻译带来的歧义\",\"顺序读写 Sequential Access 随机读写 Random Access Random Access: the process of transferring information to or from memory in which every memory location can be accessed directly rather than being accessed in a fixed sequence. 随机读写/存取，这个是翻译上存在已久的争议，不必深究，简单的说就是可以对任意位置直接进行读写。\",\"不同硬盘 IO 的区别\",\"普通硬盘读取数据是从磁道中读取，先定位磁道，然后在磁道中读写，因此对于普通硬盘而言连续 IO (Sequential IO) 效率高于随机 IO （Random IO），因为磁盘寻道更少。\",\"而 SSD 读取数据的方式有点像内存，它最小可读单元是 Page，Page 大小由硬盘本身决定，家用版有 2k、4k、8k、16k 等等，服务器版会有一些超大页的，不过通常是 4k（ps：这就是“4k对齐”的底层逻辑）。\",\"扯远了，SSD 的优势除了天然比传统机械硬盘更快之外，实际它是 random IO 效率很高，跟传统硬盘比，它不需要寻道，跟自身 Sequential IO 比也要更快，当然综合来看其实差别不大。SSD IO 的另一个特点是读的速读远大于写。只看数据写入的话，由于 “erase-before-write” 机制的存在，连续写好于随机写（比如连续写入 1m > 随机写入 256 个 4k）。\",\"因此 RocketMQ 采用将所有消息按抵达 broker 的次序顺序写入 CommitLog，每个文件大小固定，写满一个就去写新的。\",\"// CommitLog 源码位置 org.apache.rocketmq.store.CommitLog \",\"CommitLog 这个类你简单理解它内部包含一个 MappedFileQueue，而 MappedFileQueue 由 MappedFile 组成。\",\"MappedFileQueue 可以暂且看作是一个 MappedFile 组成的数组，它的真实类型是: CopyOnWriteArrayList<MappedFile> mappedFiles = new CopyOnWriteArrayList<MappedFile>();。对应到存储模块的目录结构中，你可以暂且认为它就是那个 commitlog/ 目录，具体细节在后面会详细展开。\",\"MappedFile 目前可以简单理解为就是 commitLog/ 目录下的 commitLog 文件，它内部数据就是系统写入的消息，具体细节在后面会详细展开。\",\"然后我们来介绍下 CommitLog 文件的设计，首先单个文件大小固定，默认为 1GB，文件名长度固定为 20，文件名格式为 偏移量+高位补0 ｜ 000... + offset ，看起来就是00000000000000000321这种样子。\",\"文件大小的配置：Broker 配置文件中的 mapedFileSizeCommitLog 选项。\",\"CommitLog 文件内部的结构大致为：已写入的全部消息：大小不定 + maxBlank(空闲空间大小)：4字节 + BLANK_MAGIC_CODE：4字节。\",\"存储目录: 默认值：${ROCKET_HOME}/store/commitlog，这里的 ${ROCKET_HOME} 通常就是你用户目录，你可以理解为~。可以通过修改 broker 配置文件中的 storePathRootDir 来自定义存储目录。\",\"简单总结\",\"先回顾一下 commitlog 文件的命名方式，看似平平无奇的设计里隐藏着一个优秀的特性。\",\"这个设计巧妙的地方在于，只要给出任意一个消息的偏移量 (offset)，就可以利用二分查找迅速定位这个消息存储在哪个 CommitLog 中，定位到文件后只需要msg.offset - commitLog.name 就能得到消息在 commitLog 中的绝对位置。\",\"以上这个查找流程相当于轻松实现了一套基于文件系统的高效随机访问 (Random Access) 的功能。文件系统的随机访问，尤其是传统机械硬盘上的随机访问是一个非常低效的过程，同理可参考之前提到的 MySQL 索引的数据结构选择，也是为了实现相同的目标。\",\"之前说了写入方式就是顺序写入，一个文件写满之后写入下一个文件，实际上你想想看就知道，消息本身长度是不可控的，不可能把 1GB 正好写满，如果一个消息来写 CommitLog 时发现自己的长度 + 8 超过当前 commitLog 文件的剩余空间时，就会直接创建一个新的 commitLog 并写入消息。\",\"// CommitLog::doAppend if ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) \",\"前面说的 + 8，也就是代码中的END_FILE_MIN_BLANK_LENGTH，实际上就是说每个 CommitLog 文件至少会有 8 个字节的空闲，高 4 位用于记录 CommitLog 文件剩余的空闲空间，低 4 位存放魔数。\",\"最后，通过详细介绍（其实还是有很多细节没讲，会在后面分析具体机制时讲解）CommitLog 文件，我们不难发现该文件的设计核心就是在强调写入效率的最大化，同时兼顾了高效的根据 offset 进行随机读的能力（因为消息只写不删，而写入全是顺序写，删除是直接删 CommitLog 文件）。至此作为消息队列，消息写入的能力有了，而消费并没有实现，毕竟 RocketMQ 的卖点是基于消息主题 Topic 进行消息传输，很明显虽然 CommitLog 写入很高效，但它完全没有提供根据 topic 去找到消息的能力，总不可能去遍历 commitLog 去找 topic，何况相同 topic 下的消息很可能分布在不同的 commitLog 文件中，所以接下来我们就来看看专门为消息消费服务的 ConsumeQueue。\"]},\"111\":{\"h\":\"ConsumeQueue\",\"t\":[\"ConsumeQueue 设计目的也非常明确，那就是为消费端提供高效的根据 topic 查找消息的能力。\",\"而同一个 topic 中的消息在 CommitLog 文件中的分布基本上可以认为是不连续和随机的，想要根据 topic 快速查找消息，ConsumeQueue 的做法相当于是给 commitlog 加了 Topic 索引。\",\"从前文的目录结构中就可以清楚的看到，ConsumeQueue/ 下的一级目录名就是主题 topic 名称，二级目录名就是该主题包含的队列ID，二级目录下的文件就是待消费的消息队列，这个待消费的消息队列就是 ConsumeQueue 文件。\",\"前面已经提到，ConsumeQueue 中的数据来自 CommitLog 写入完成后的异步转发。这里异步转发的数据实际上就是 ConsumeQueue 文件中最小的数据单元。\",\"// 源码位置 org.apache.rocketmq.store.ConsumeQueue \",\"ConsumeQueue 这个类内部依然包含一个 MappedFileQueue，而 MappedFileQueue 依然 MappedFile 组成。\",\"MappedFileQueue 在这里相当于是 ConsumeQueue/queueid/ 目录，而 MappedFile 相当于是 ConsumeQueue 文件，它里面存储的就是异步转发来的数据。\",\"然后来看 ConsumeQueue 文件的设计，ConsumeQueue 整体都采用了固定长度的设计，其最小数据单元，随便起个名字，cqNode，定长 20 byte，内部结构为:\",\"8 byte\",\"4 byte\",\"8 byte\",\"commitlog-offset\",\"msg.size\",\"hash(msg.tag)\",\"该消息在 commitlog 中的偏移量\",\"消息的总长度\",\"消息的 tag 的 hash 值\",\"单个 ConsumeQueue 文件默认包含 30w 个 cqNode，因此 ConsumeQueue 文件的固定大小为：300000 * ConsumeQueue.CQ_STORE_UNIT_SIZE(CQ_STORE_UNIT_SIZE 就是 cqNode 的定长 20 byte)。\",\"ConsumeQueue 同样是顺序写，文件命名的方式与 commitlog 文件一致，也是 offset + 高位补0，唯一的区别是这里的 offset 永远是 20 的整数倍。\",\"存储目录: $HOME/store/consumequeue/{topic}/{queueID}/{ConsumeQueueFile}。\",\"总结分析 了解 ConsumeQueue 的设计之后我们来看它为消费消息带来了什么变化。\",\"消费端可以根据 topic 和 queueid 轻松定位到具体的 ConsumeQueue 文件，接下来要找到需要的 cqNode。\",\"消费端在当前主题的当前队列下的消费进度实际上就是所需 cqNode 在 ConsumeQueue 中的偏移量， 比如你消费到第3条消息，那么 3 * 20 就是第四条消息的 cqNode 在 ConsumeQueue 中的偏移量。\",\"觉得不好理解可以参考下表:\",\"消费进度\",\"0\",\"1\",\"2\",\"...\",\"cqNode-head-position\",\"0*20\",\"1*20\",\"2*20\",\"...\",\"ConsumeQueue\",\"cqNode-0\",\"cqNode-1\",\"cqNode-2\",\"....\",\"其实仔细思考一下你会发现由于全是定长设计，ConsumeQueue 完全可以看作是一个数组，它的每个元素都是一个 cqNode，数组下标和对应 cqNode 在文件中的起始位置就是下标*20的线性关系。\",\"无论消费进度在这里代表最新已消费进度还是下一个未消费进度，无非就是计算消息起始位置时候 +20/-20 的区别，常数计算反正不会影响线性关系。\",\"准确定位到 cqNode 后，通过 commitlog-offset 可以从 commitlog 中准确定位到消息所处具体的文件的具体位置起始， msg.size 可以准确读出消息的全部数据。而 hash(msg.tag) 是用来支持消息过滤功能的，也就是去 commitLog 中查找之前多加一个根据 tag 过滤的环节，需要注意的是，为了满足定长设计，这里存储的是 tag 的 hash 值，注意哈希冲突。\"]},\"112\":{\"h\":\"Index File\",\"t\":[\"有了 CommitLog 和 ConsumeQueue，其实 RocketMQ 的基础功能基本齐活儿了。\",\"Index 文件的引入则可以看作是产品功能增强，它为 rocketmq 提供了按照消息属性进行检索的能力。 这里说的消息属性就是 Message 类里的 private Map<String/*name*/, String/*value*/> properties;。 后面提到的 Key 实际上是 Key = Topic + \\\"#\\\" + msg.key，msg.key 就是 Message.properties.name，但是要注意 Message.getKeys() 方法返回的是所有 name + 空格拼接的字符串。\",\"源码位置：org.apache.rocketmq.store.index.IndexFile\",\"Index 文件也是定长设计，主要由三个部分组成：文件头、哈希槽(Hash Slot)、索引数据(indexData)。其中文件头固定 40 byte，Hash Slot 500万个，indexData 槽 2000万个。数据也是来自 commitlog，消息写完 commitlog 后会转发 key 和 commitlog-offset（phyoffset）过来。\",\"大体结构：\",\"文件头 indexHeader\",\"Hash Slot\",\"indexData Slot\",\"40 byte\",\"4 byte * 500w\",\"20 byte * 2000w\",\"文件头 indexHeader：\",\"beginTimestamp\",\"endTimestamp\",\"beginPhyoffset\",\"endPhyoffset\",\"hashSlotCount\",\"index count\",\"8 byte\",\"8 byte\",\"8 byte\",\"8 byte\",\"4 byte\",\"4 byte\",\"首个消息 put 的存储时间\",\"最新消息的存储时间\",\"首个的消息在 commitlog 中的偏移量\",\"最新消息的偏移量\",\"已使用的 hashSlot\",\"消息已使用的 indexData 的总数\",\"文件头实际上当成临时变量存储区域就好了。begin 开头的就是 index 文件中收到的第一个消息的信息，end 开头的就是最新消息 put 时的信息，hashSlotCount 是有消息的 key 落到任意槽时自增 +1，index count 是每次有消息进来就自增+1。\",\"hashSlot：\",\"4 byte，里面的数据是 indexcount，实际上 40 + 4*500w + indexcount * 20 = index-offset，你把它当成 hashMap 里链表的尾指针就好。\",\"indexData:\",\"hashcode\",\"phyoffset\",\"timedif\",\"preIndexNo\",\"消息的 key 的 hashcode\",\"消息在 commitlog 中的 offset\",\"timedif = 该消息存入 index 文件时的timestamp - indexHeader.beginTimestamp (秒)\",\"0 or indexcount，其实就是冲突时前一个结点的 offset，计算方式跟 hashSlot 里面一样，当成前指针即可\",\"总结\",\"根据以上说明你可以发现每个 index file 实际上就是一个 hashMap。与 ConsumeQueue 类似，它的数据也来自 commitlog，不同于前两个文件的顺序写，IndexFile 中只有 indexData 部分是顺序写。\",\"每当消息的 key 和 commitlog-offset 转发给 IndexFile 后，它会先拼接生成 Key，然后对 Key 进行哈希，哈希方法就是简单的 String::hash 取绝对值，然后对 hashSlotNum(500w) 取模得到 hashSlot 的逻辑位置 slotPos，int slotPos = keyHash % this.hashSlotNum;，之后定长计算得到 slot 在 IndexFile 中的 offset。indexData 的 index-offset 计算方式也差不多，因为这部分是顺序写，所以直接 40 + 4*500w + indexHeader.indexcount * 20。\",\"所谓根据属性查找消息，其实就是根据 key 得到 hashcode，根据 hashcode 找到 slot-offset，从中取出 indexcount，计算出 indexData 的 index-offset，取出 commitlog-offset，有了 commitlog-offset 就可以去 commitlog 里取消息了。\",\"所以你看，不管是 consumequeue 还是 IndexFile 都是 先找到消息的 commitlog-offset，然后回到 commitlog 中查找。\"]},\"113\":{\"h\":\"CheckPoint\",\"t\":[\"源码:StoreCheckpoint\",\"这个文件就是用来记录刷盘时间点的。\",\"physicMsgTimestamp\",\"logicsMsgTimestamp\",\"indexMsgTimestamp\",\"CommitLog 刷盘时间点\",\"ConsumeQueue 刷盘时间点\",\"IndexFile 刷盘时间点\",\"因为是记录时间戳，所以都是占 8 byte。\"]},\"114\":{\"h\":\"核心机制\",\"t\":[\"MMAP\",\"简单介绍一下 MMAP，前文中反复出现的 MappedFile 就是这种技术的应用。\",\"它是一种通过系统调用将文件映射到内存的技术，零拷贝方案之一。\",\"简单的说就是可以直接从内核空间映射到用户空间，并且数据的修改和数据写入硬件（刷盘）是分开的。 你可以使用修改内存的方式修改文件数据，并且可以自行决定在什么时间点将修改刷盘。\",\"对 MMAP 感兴趣可以先去看操作系统（Linux）、内存、IO 等相关知识。\"]},\"115\":{\"h\":\"CommitLog 刷盘\",\"t\":[\"在 Broker 上篇中我们提到了接收消息时会发起异步调用进行刷盘，也就是 SendMessageProcessor::asyncSendMessage 中的 this.brokerController.getMessageStore().asyncPutMessage(msgInner);。\",\"现在来具体看一下刷盘流程，源码位置:DefaultMessageStore::asyncPutMessage。\",\"@Override public CompletableFuture<PutMessageResult> asyncPutMessage(MessageExtBrokerInner msg) { // 首先检查 MsgStore 状态是否正常，正常则返回 PUT_OK。 // 以下四种状态均为异常 // 1. MsgStore 是否为 shutdown 状态。 // 2. Broker 是否为 Slave // 3. MsgStore 是否为可写状态 // 4. 是否缓存页繁忙 PutMessageStatus checkStoreStatus = this.checkStoreStatus(); // 不正常直接返回 if (checkStoreStatus != PutMessageStatus.PUT_OK) { return CompletableFuture.completedFuture(new PutMessageResult(checkStoreStatus, null)); } // 检查消息状态，检查 topic 和属性长度 不能过长 PutMessageStatus msgCheckStatus = this.checkMessage(msg); if (msgCheckStatus == PutMessageStatus.MESSAGE_ILLEGAL) { return CompletableFuture.completedFuture(new PutMessageResult(msgCheckStatus, null)); } long beginTime = this.getSystemClock().now(); // 异步调用 coomitlog 存储消息 CompletableFuture<PutMessageResult> putResultFuture = this.commitLog.asyncPutMessage(msg); putResultFuture.thenAccept((result) -> { long elapsedTime = this.getSystemClock().now() - beginTime; if (elapsedTime > 500) { log.warn(\\\"putMessage not in lock elapsed time(ms)={}, bodyLength={}\\\", elapsedTime, msg.getBody().length); } this.storeStatsService.setPutMessageEntireTimeMax(elapsedTime); if (null == result || !result.isOk()) { this.storeStatsService.getPutMessageFailedTimes().add(1); } }); return putResultFuture; } \",\"然后来到 this.commitLog.asyncPutMessage(msg);，该方法有两种实现，一种是分布式 CommitLog ，另一种就是普通的 commitLog，这里我们看普通的即可，5.0 之前不建议使用分布式。\",\"// CommitLog::asyncPutMessage // 前面 msg 组装啥的省略 // 先上锁 默认是 ReentrantLock putMessageLock.lock(); //spin or ReentrantLock ,depending on store config try { // 拿到最新的 mappedFile，mmap，其实就是最新的 commitlog 文件 MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(); // 继续省略 // 注意同名方法，前面那个 getLastMappedFile() 是会返回 null的。 // mappedFile 为空 or 写满，则创建新文件 if (null == mappedFile || mappedFile.isFull()) { // 实际调用的是 tryCreateMappedFile(0) -> doCreateMappedFile -> ... // 调用链太长了，正常情况下，最后负责创建 mappedFile 的一定是 allocateMappedFileService::mmapOperation mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise } // mappedFile.appendMessage 就是 前文说的 消息会顺序写入 CommitLog // 调用链结尾是 CommitLog.doAppend result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext); switch (result.getStatus()) { //... /* 这里看这好几个分支，实际上就三种状态： PUT_OK 代表写入成功， END_OF_FILE 代表文件写满了，创建一个新文件重新 appendMessage， 其他就是消息格式异常和未知错误，理论上客户端如果正确校验过消息，消息格式异常也不会出现在这里（防御性编程）。 所以真的看到消息错误的异常时要小心，特别要注意该消息的来源。 */ } // ... // submitFlushRequest 就是刷盘方法，里面有同步刷盘 SYNC_FLUSH，异步刷盘 ASYNC_FLUSH 两种逻辑 // 无论是哪种刷盘，都是创建请求，然后提交给 xxService(就是不同类型的刷盘线程)，Service/线程去完成刷盘操作 // 就比如 flushCommitLogService 可以是 GroupCommitService 类型(同步) ，也可以是 FlushRealTimeService(异步)。 // 最终执行的方法是 mappedByteBuffer.force(); 或者 fileChannel.force(); // 执行成功，则 pageCache 内的数据就被写入硬盘 // 这里还有个概念是 GroupCommit，后面再详细说明 CompletableFuture<PutMessageStatus> flushResultFuture = submitFlushRequest(result, msg); // 这个提交重复请求，就是 broker 高可用，master 写完给 slave 转发。 CompletableFuture<PutMessageStatus> replicaResultFuture = submitReplicaRequest(result, msg); // ... } \",\"CommitLog::submitFlushRequest\",\"public CompletableFuture<PutMessageStatus> submitFlushRequest(AppendMessageResult result, MessageExt messageExt) { // Synchronization flush if (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) { final GroupCommitService service = (GroupCommitService) this.flushCommitLogService; if (messageExt.isWaitStoreMsgOK()) { // 构造 request GroupCommitRequest request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes(), this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout()); // 提交 request 多眼熟几遍 service.putRequest(request); return request.future(); } else { service.wakeup(); return CompletableFuture.completedFuture(PutMessageStatus.PUT_OK); } } // Asynchronous flush else { if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) { // 默认情况，真实类型 FlushRealTimeService flushCommitLogService.wakeup(); } else { // 开启 TransientStorePool 机制时 // 真实类型 CommitRealTimeService commitLogService.wakeup(); } return CompletableFuture.completedFuture(PutMessageStatus.PUT_OK); } } \",\"自动创建 MappedFile 的线程: allocateMappedFileService\",\"allocateMappedFileService::mmapOperation这里稍微补充说明以下，allocateMappedFileService 这个线程专门负责自动创建 MappedFile 文件，它里面维护一个 requestTable，不管是 CommitLog 还是 ConsumeQueue ，只要需要创建文件的时候就会生成一个创建请求 AllocateRequest，然后放入 requestTable， 配合 CountDownLatch ,allocateMappedFileService 就会自动从这个表里取出信息然后创建文件。成功创建好文件之后会对文件预热，MappedFile::warmMappedFile，预热行为就是给文件里写满0。全部完成后创建好的 mappedFile 会 set 回 AllocateRequest 里，这样请求方就可以直接从 requestTable 里读取了。\",\"组提交 GroupCommit ：\",\"GroupCommitService里面有一个“组提交(GroupCommit)”的概念，里面应用了一个读写分离的小技巧。\",\"GroupCommitService 里维护了两个 List，requestsRead 和 requestsWrite，刷盘请求（GroupCommitRequest）会进入 requestsWrite，而刷盘线程从 requestsRead 里读取刷盘请求。 每当 requestsRead 里的请求全部执行完后，就会把 requestsRead 重置为一个空 List，然后去和 requestsWrite 交换数据。 整个过程中只有交换数据这一步是阻塞的。（实际代码中的交换流程好像是直接 Read = Write，然后 write = new List()，不重要，反正一个意思）\",\"flushCommitLogService\",\"if (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) { this.flushCommitLogService = new GroupCommitService(); } else { this.flushCommitLogService = new FlushRealTimeService(); } \",\"GroupCommitService 不会在没有刷盘任务的时候一直空转，他会停个 10ms，如果还是没有刷盘任务，则继续停。\",\"FlushRealTimeService 的线程间隔默认是 200ms。\",\"他俩的源码就不展开看了，感兴趣可以自行浏览，他们仨（包括 CommitRealTimeService）都是线程，直接看 run 方法即可。\",\"commitLogService\",\"CommitLog 类里还有一个线程叫做 commitLogService，这个线程只有在开启 TransientStorePool 机制时才会启动，他是用来代替 flushCommitLogService的。\",\"// CommitLog::start public void start() { this.flushCommitLogService.start(); if (defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) { this.commitLogService.start(); } } \",\"它的真实类型是 CommitRealTimeService，它刷盘的方式跟前面都不一样，有兴趣可以先看一下后面的 TransientStorePool 机制的介绍，然后再去看他的代码，这里就只注明个别参数的含义，不展开看了。\",\"MessageStoreConfig.commitIntervalCommitLog：\",\"CommitRealTimeService 线程的间隔，默认 200ms，跟异步刷盘那个线程一致，这个 TransientStorePool 机制通常也是用来替换异步刷盘的，毕竟如果你都开启实时刷盘的模式了，说明数据安全高于性能，而 TransientStorePool 机制下一旦发生意外，丢的可是一大块内存的消息。\",\"MessageStoreConfig.commitCommitLogLeastPages：\",\"一次至少提交几个页(Page)的数据，默认为 4。页数不满足的时候会直接跳过，等下次提交。\",\"MessageStoreConfig.commitCommitLogThoroughInterval：\",\"两次有效提交的最大间隔，默认 200ms。 注意跟线程间隔区分，因为有前一个参数在，所以 CommitRealTimeService 是有可能拿着一部分的数据一直不提交的，该参数你可以认为是用来强制要求线程提交数据的。\",\"MessageStoreConfig 里面有一部分属性是有英文注释，可以参考。\"]},\"116\":{\"h\":\"ConsumeQueue 刷盘\",\"t\":[\"开始阅读前可以先对比以下 CommitLog 和 ConsumeQueue 的属性字段(field)，看起来 ConsumeQueue 似乎没有自己的 Service，实际上是有的，只不过是在 DefaultMessageStore 中。\",\"前文一直说消息写完 commitLog 后会转发给 ConsumeQueue 和 IndexFile，现在我们来看这个转发。\",\"源码位置：org.apache.rocketmq.store.DefaultMessageStore。\",\"DefaultMessageStore 应该也算是 RocketMQ-store 的核心类了，它这里管理着很多线程（Service）。 前面提到的线程基本都是它来创建和启动。在它的构造方法里，你能看到如下代码：\",\"// from DefaultMessageStore field LinkedList<CommitLogDispatcher> dispatcherList; // from DefaultMessageStore Constructor this.dispatcherList = new LinkedList<>(); this.dispatcherList.addLast(new CommitLogDispatcherBuildConsumeQueue()); this.dispatcherList.addLast(new CommitLogDispatcherBuildIndex()); \",\"这里你就把 dispatcherList 看成是任务列表，后面的对象就是任务，这个任务必须实现 void dispatch(final DispatchRequest request);方法。\",\"然后 DefaultMessageStore 中有个 ReputMessageService，ReputMessageService 这个线程就不停的执行 doReput()，实际上有 1ms 间隔，然后这个 doReput() 会根据 dispatchRequest 状态去调用 DefaultMessageStore.this.doDispatch(dispatchRequest);，这个 doDispatch(dispatchRequest) 方法就是遍历前面的任务列表，分别执行任务的 dispatch(DispatchRequest request) 方法，也就是前面的 CommitLogDispatcherBuildConsumeQueue() 和 CommitLogDispatcherBuildIndex()。\",\"然后我们来看 CommitLogDispatcherBuildConsumeQueue::dispatch:\",\"CommitLogDispatcherBuildConsumeQueue::dispatch\",\"// DefaultMessageStore.CommitLogDispatcherBuildConsumeQueue::dispatch public void dispatch(DispatchRequest request) { final int tranType = MessageSysFlag.getTransactionValue(request.getSysFlag()); switch (tranType) { case MessageSysFlag.TRANSACTION_NOT_TYPE: case MessageSysFlag.TRANSACTION_COMMIT_TYPE: // 状态 消息已提交 DefaultMessageStore.this.putMessagePositionInfo(request); break; case MessageSysFlag.TRANSACTION_PREPARED_TYPE: case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: break; } } \",\"DefaultMessageStore::putMessagePositionInfo\",\"//DefaultMessageStore::putMessagePositionInfo // 前文介绍 ConsumeQueue 时讲过的，根据 Topic 和 QueueID 定位文件 // 其实就是1级目录/2级目录/cq文件， findConsumeQueue 这个方法自己去看吧 ConsumeQueue cq = this.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId()); // 写入文件的包装方法 cq.putMessagePositionInfoWrapper(dispatchRequest); \",\"ConsumeQueue::putMessagePositionInfoWrapper\",\"这个其实也没啥可看的。\",\"public void putMessagePositionInfoWrapper(DispatchRequest request) { final int maxRetries = 30; // cq 文件可写标记 boolean canWrite = this.defaultMessageStore.getRunningFlags().isCQWriteable(); for (int i = 0; i < maxRetries && canWrite; i++) { long tagsCode = request.getTagsCode(); // cqExt 扩展文件处理逻辑 直接跳过 if (isExtWriteEnable()) { //... } // putMessagePositionInfo 方法去写文件 boolean result = this.putMessagePositionInfo( request.getCommitLogOffset(), // msg.phyoffset request.getMsgSize(), // msg.size tagsCode, // msg.tag.hashcode request.getConsumeQueueOffset()); // cur cq logic-offset // 根据结果更新 checkpoint 文件 if (result) { // Slave or 分布式 commitLog if (this.defaultMessageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE || this.defaultMessageStore.getMessageStoreConfig().isEnableDLegerCommitLog()) { this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(request.getStoreTimestamp()); } this.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(request.getStoreTimestamp()); // 注意前面是循环写，只要成功就直接 return return; } else { // XXX: warn and notify me // log try { Thread.sleep(1000); } catch (InterruptedException e) { log.warn(\\\"\\\", e); } } } // XXX: warn and notify me log.error(\\\"[BUG]consume queue can not write, {} {}\\\", this.topic, this.queueId); this.defaultMessageStore.getRunningFlags().makeLogicsQueueError(); } \",\"ConsumeQueue::putMessagePositionInfo\",\"这个方法本来也不打算贴的，因为 ConsumeQueue 其实也是顺序写，所以处理逻辑跟 commitLog 一样， 都是 mappedFile::appendMessage。 不打算贴的原因是很容易跟前文逻辑混淆，比如代码中 ConsumeQueue 文件的物理偏移量都叫 xxxLogicOffset，按代码表达意思其实就是 commitLog 文件才叫物理偏移量， ConsumeQueue 就是逻辑文件，毕竟 ConsumeQueue 的数据都是可以从 CommitLog 中推理出来的。\",\"再比如 PhysicOffset 突然就加上了 msg.size，然后还没有注释解释原因，实际上它突然加个 msg.size 只是为了恢复文件的时候跟 commitlog 文件进行比较，毕竟你要判断 commitlog 中的消息是否损坏，它起始位置是判断不出来的（除非消息整个丢了），只有结尾大小不一样，说明这个消息没写全，是损坏的。\",\"换句话说，ConsumeQueue.maxPhysicOffset 相当于保存了两部分信息，一是消息的物理偏移量，二是消息的正确大小。\",\"private boolean putMessagePositionInfo(final long offset, final int size, final long tagsCode, final long cqOffset) { // offset：PhysicOffset aka 消息在 commitlog 中的 offset // maxPhysicOffset： cq 中存储的消息在 commitlog 中的 offset + msg.size // 最新消息的 phyOffset + msg.size 必然大于CQ中已有消息的 maxPhysicOffset if (offset + size <= this.maxPhysicOffset) { log.warn(\\\"Maybe try to build consume queue repeatedly maxPhysicOffset={} phyOffset={}\\\", maxPhysicOffset, offset); return true; } this.byteBufferIndex.flip(); // buffer 指针归 0 this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE); // 20 byte this.byteBufferIndex.putLong(offset); // PhysicOffset this.byteBufferIndex.putInt(size); // msg.size this.byteBufferIndex.putLong(tagsCode); // msg.tag.hashcode // 计算消息在 CQ 中的 物理位置 // cqOffset 在这里是逻辑位置，至少是本文说的 消息在这个 cq 队列中的逻辑位置 // 但是吧，算出来的 offset，它代码里叫 LogicOffset，明明相同语境下，commitlog 你叫物理位置 // 到 cq 文件里就变成逻辑位置了，而且这个 offset 是不加 msg.size 的 final long expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE; // 根据预期的 CQ 中的物理偏移量，二分查找 找出对应的 ConsumeQueue 文件，满了则创建信息 // 这儿的逻辑跟 commitlog 文件是一样的，CQ 里很多处理逻辑跟 CommitLog 中都是同一套 MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(expectLogicOffset); if (mappedFile != null) { // 队列为空，起始可写入位置也为0，但是 cq 逻辑偏移量(cqOffset) 不为 0 // 说明当前要写入 CQ 的消息不是第一条消息，那么先写空结点占位 fillPreBlank if (mappedFile.isFirstCreateInQueue() && cqOffset != 0 && mappedFile.getWrotePosition() == 0) { // 结合这里看，这个 LogicOffset 的意思大概是，CQ 文件中的物理偏移量都叫 LogicOffset this.minLogicOffset = expectLogicOffset; this.mappedFileQueue.setFlushedWhere(expectLogicOffset); this.mappedFileQueue.setCommittedWhere(expectLogicOffset); // 向前面应该有数据的空的CQ结点中写入 空结点：0L + Integer.MAX + 0L // 一直填充到 本消息的起始位置为止。 this.fillPreBlank(mappedFile, expectLogicOffset); log.info(\\\"fill pre blank space \\\" + mappedFile.getFileName() + \\\" \\\" + expectLogicOffset + \\\" \\\" + mappedFile.getWrotePosition()); } if (cqOffset != 0) { // 这段不用看，就是 offset 对不上的话，打印偏差值的地方。 } // maxPhysicOffset 是 消息结尾位置，而不是消息写入位置 this.maxPhysicOffset = offset + size; return mappedFile.appendMessage(this.byteBufferIndex.array()); } return false; } \"]},\"117\":{\"h\":\"ConsumeQueueExt\",\"t\":[\"ConsumeQueue 扩展文件，ConsumeQueue 只有三个字段，Ext 版本就是比 ConsumeQueue 多了几个字段。 由于多了字段，自然要有单独的逻辑，这部分不展开。\"]},\"118\":{\"h\":\"indexFile 刷盘\",\"t\":[\"同 ConsumeQueue 。\"]},\"119\":{\"h\":\"文件恢复\",\"t\":[\"要恢复的文件自然就是 CommitLog、ConsumeQueue、IndexFile 这三种。由于后两者的数据均来自 CommitLog，因此恢复时基本以 ComitLog 为准。 这里只介绍 CommitLog、ConsumeQueue，IndexFile 的恢复流程省略，这篇幅已经太长了。\",\"文件恢复是 Broker 启动，或者说 DefaultMessageStore 启动时，加载过程中的一步，也就是 DefaultMessageStore::recover(boolean lastExitOK)，无论是正常退出还是异常关闭， recover(lastExitOK) 的第一件事是先恢复 ConsumeQueue 文件，找到最新一条格式正确的消息的记录，并取出该消息的 commitLog-offset 的值，存储到 maxPhyOffsetOfConsumeQueue 中作为下一步的入参。\",\"详见: DefaultMessageStore::load。\",\"正常退出\",\"Broker 正常退出时，会先完成刷盘，然后再关闭 Broker，也就是说内存中所有数据都保存在文件中了。\",\"此时文件恢复会进入 this.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);，从倒数第三个 commitlog 文件开始恢复，不足 3 个文件则从第一个开始恢复。 恢复过程，先 checkMessageAndReturnSize，然后设置 ConsumeQueue。\",\"异常退出\",\"异常关闭则进入 this.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);（注意该方法已标记 Deprecated，代码就不贴了，不建议看，知道大体逻辑就好了。\",\"这里的逻辑基本上是：利用 CheckPoint 文件中记录的三个时间戳（CommitLog、ConsumeQueue、Index文件最后的刷盘时间戳）中，最小的来进行辅助判定。\",\"那个方法会从 commitLog 的最后一个文件(int index = mappedFiles.size() - 1;)开始判定，判定逻辑在 isMappedFileMatchedRecover，读出该文件第一条消息的存储时间，如果这个存储时间小于 CheckPoint 文件中的最小刷盘时间（），就可以从这个文件开始恢复，如果大于，则寻找上一个文件（index = index - 1），这里相当于默认了 CheckPoint.getMinTimestampIndex 之前的消息绝对有效。后面流程就跟正常恢复一样了。\",\"这个 CheckPoint.getMinTimestampIndex 的值如下：\",\" public long getMinTimestampIndex() { return Math.min(this.getMinTimestamp(), this.indexMsgTimestamp); } public long getMinTimestamp() { long min = Math.min(this.physicMsgTimestamp, this.logicsMsgTimestamp); min -= 1000 * 3; if (min < 0) min = 0; return min; } \",\"recoverTopicQueueTable\",\"无论是正常退出还是异常关闭，recover 还有最后一步恢复 CommitLog.topicQueueTable 的数据，其实就是初始化这个表里的数据，它里面的数据来自 DefaultMessageStore.consumeQueueTable，而 consumeQueueTable 中的数据则是在 loadConsumeQueue() 时从 ConsumeQueue 文件中读出来的。\"]},\"120\":{\"h\":\"TransientStorePool 机制\",\"t\":[\"默认情况下，RocketMQ 是先写页缓存（pageCache），消费消息也是从 pageCache 查，高并发时就会在 broker 日志中发现瞬时 broker busy 的异常，大部分情况下就是 pageCache 太忙。\",\"这个机制的引入就是为了解决这个问题，它采用的方式你可以理解为空间换时间，也可以理解为内存的读写分离。\",\"启用该机制后，Broker 收到的消息会先写入堆外内存并立刻返回，然后用异步的方式提交给 pageCache，之后再异步刷盘。这样相当于写消息操作都在堆外内存，而 pageCache 主要面对消息消费，也就是读操作。\",\"不过缺点是，broker 意外退出时，pageCache 还有可能保留一部分数据，堆外内存的数据就全丢了。\"]},\"121\":{\"h\":\"总结\",\"t\":[\"熟悉三种文件的设计思路和文件结构，了解刷盘/恢复的大致流程即可。\",\"本文跳过了消息消费相关的一部分内容，后续在消息消费章节再进行说明。\"]},\"122\":{\"h\":\"reference\",\"t\":[\"《RocketMQ技术内幕: RocketMQ架构设计与实现原理》\",\"RocketMQ 文档 4.x 版\"]},\"123\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"124\":{\"h\":\"Java\"}},\"dirtCount\":0,\"index\":[[\"版\",{\"1\":{\"122\":1}}],[\"版本就是比\",{\"1\":{\"117\":1}}],[\"版本负载均衡这块有重构\",{\"1\":{\"58\":1}}],[\"版本\",{\"1\":{\"58\":1,\"64\":1}}],[\"熟悉三种文件的设计思路和文件结构\",{\"1\":{\"121\":1}}],[\"堆外内存的数据就全丢了\",{\"1\":{\"120\":1}}],[\"意外退出时\",{\"1\":{\"120\":1}}],[\"意味着\",{\"1\":{\"6\":1}}],[\"太忙\",{\"1\":{\"120\":1}}],[\"判定逻辑在\",{\"1\":{\"119\":1}}],[\"判断\",{\"1\":{\"58\":1,\"84\":1}}],[\"恢复的大致流程即可\",{\"1\":{\"121\":1}}],[\"恢复过程\",{\"1\":{\"119\":1}}],[\"恢复后\",{\"1\":{\"70\":1}}],[\"此时文件恢复会进入\",{\"1\":{\"119\":1}}],[\"此时其实才是\",{\"1\":{\"61\":1}}],[\"扩展文件\",{\"1\":{\"117\":1}}],[\"扩展文件处理逻辑\",{\"1\":{\"116\":1}}],[\"打印偏差值的地方\",{\"1\":{\"116\":1}}],[\"打算趁着切换\",{\"1\":{\"12\":1}}],[\"逻辑偏移量\",{\"1\":{\"116\":1}}],[\"逻辑很简单\",{\"1\":{\"94\":1}}],[\"起始可写入位置也为0\",{\"1\":{\"116\":1}}],[\"起手就是个\",{\"1\":{\"98\":1}}],[\"队列为空\",{\"1\":{\"116\":1}}],[\"队列中的逻辑位置\",{\"1\":{\"116\":1}}],[\"满了则创建信息\",{\"1\":{\"116\":1}}],[\"满足条件则把\",{\"1\":{\"40\":1}}],[\"算出来的\",{\"1\":{\"116\":1}}],[\"算法\",{\"1\":{\"13\":1}}],[\"物理位置\",{\"1\":{\"116\":1}}],[\"物理内存最大占比\",{\"1\":{\"69\":1}}],[\"物理内存的\",{\"1\":{\"61\":1}}],[\"指针归\",{\"1\":{\"116\":1}}],[\"必然大于cq中已有消息的\",{\"1\":{\"116\":1}}],[\"必须大于0\",{\"1\":{\"65\":1}}],[\"必须完全一致\",{\"1\":{\"52\":1}}],[\"除非消息整个丢了\",{\"1\":{\"116\":1}}],[\"除了以上功能外\",{\"1\":{\"70\":1}}],[\"除了要看\",{\"1\":{\"56\":1}}],[\"除了推拉之外\",{\"1\":{\"46\":1}}],[\"按代码表达意思其实就是\",{\"1\":{\"116\":1}}],[\"按照计算出的\",{\"1\":{\"102\":1}}],[\"间隔\",{\"1\":{\"116\":1}}],[\"间隔为\",{\"1\":{\"57\":1}}],[\"页数不满足的时候会直接跳过\",{\"1\":{\"115\":1}}],[\"丢的可是一大块内存的消息\",{\"1\":{\"115\":1}}],[\"交换数据\",{\"1\":{\"115\":1}}],[\"交给\",{\"1\":{\"23\":1}}],[\"预热行为就是给文件里写满0\",{\"1\":{\"115\":1}}],[\"成功创建好文件之后会对文件预热\",{\"1\":{\"115\":1}}],[\"成功关闭时打印\",{\"1\":{\"84\":1}}],[\"配合\",{\"1\":{\"115\":1}}],[\"配置文件中的\",{\"1\":{\"110\":2}}],[\"配置文件啥的\",{\"1\":{\"83\":1}}],[\"配置都准备好\",{\"1\":{\"83\":1}}],[\"多了几个字段\",{\"1\":{\"117\":1}}],[\"多眼熟几遍\",{\"1\":{\"115\":1}}],[\"多个\",{\"1\":{\"64\":1,\"87\":1}}],[\"特别要注意该消息的来源\",{\"1\":{\"115\":1}}],[\"防御性编程\",{\"1\":{\"115\":1}}],[\"理论上客户端如果正确校验过消息\",{\"1\":{\"115\":1}}],[\"继续省略\",{\"1\":{\"115\":1}}],[\"继续同步\",{\"1\":{\"63\":1}}],[\"刷盘请求\",{\"1\":{\"115\":1}}],[\"刷盘\",{\"0\":{\"115\":1,\"116\":1,\"118\":1},\"1\":{\"114\":1}}],[\"刷盘时间点\",{\"1\":{\"113\":3}}],[\"零拷贝方案之一\",{\"1\":{\"114\":1}}],[\"得到\",{\"1\":{\"112\":1}}],[\"哈希方法就是简单的\",{\"1\":{\"112\":1}}],[\"哈希槽\",{\"1\":{\"112\":1}}],[\"落到任意槽时自增\",{\"1\":{\"112\":1}}],[\"槽\",{\"1\":{\"112\":1}}],[\"空结点\",{\"1\":{\"116\":1}}],[\"空格拼接的字符串\",{\"1\":{\"112\":1}}],[\"空闲空间大小\",{\"1\":{\"110\":1}}],[\"准确定位到\",{\"1\":{\"111\":1}}],[\"常数计算反正不会影响线性关系\",{\"1\":{\"111\":1}}],[\"常见持久化\",{\"0\":{\"107\":1}}],[\"觉得不好理解可以参考下表\",{\"1\":{\"111\":1}}],[\"轻松定位到具体的\",{\"1\":{\"111\":1}}],[\"轻量级任务框架这类型的线程类子系统\",{\"1\":{\"30\":1}}],[\"了解刷盘\",{\"1\":{\"121\":1}}],[\"了解\",{\"1\":{\"111\":1}}],[\"了解以上他们的含义后\",{\"1\":{\"68\":1}}],[\"永远是\",{\"1\":{\"111\":1}}],[\"唯一的区别是这里的\",{\"1\":{\"111\":1}}],[\"唯一的区别就是\",{\"1\":{\"90\":1}}],[\"值\",{\"1\":{\"111\":2}}],[\"随便起个名字\",{\"1\":{\"111\":1}}],[\"随机写入\",{\"1\":{\"110\":1}}],[\"随机读写\",{\"1\":{\"110\":2}}],[\"随机数\",{\"1\":{\"103\":1}}],[\"名称\",{\"1\":{\"111\":1}}],[\"名字挺奇怪的叫\",{\"1\":{\"77\":1}}],[\"索引数据\",{\"1\":{\"112\":1}}],[\"索引\",{\"1\":{\"111\":1}}],[\"索引的数据结构选择\",{\"1\":{\"110\":1}}],[\"快速查找消息\",{\"1\":{\"111\":1}}],[\"快速失败模式下\",{\"1\":{\"39\":1}}],[\"想要根据\",{\"1\":{\"111\":1}}],[\"设计目的也非常明确\",{\"1\":{\"111\":1}}],[\"设置\",{\"1\":{\"69\":1,\"84\":1,\"102\":1}}],[\"设置为自己的\",{\"1\":{\"40\":1}}],[\"何况相同\",{\"1\":{\"110\":1}}],[\"毕竟你要判断\",{\"1\":{\"116\":1}}],[\"毕竟如果你都开启实时刷盘的模式了\",{\"1\":{\"115\":1}}],[\"毕竟\",{\"1\":{\"110\":1,\"116\":1}}],[\"毕竟缺乏注释和细节文档的代码有个参考书还是好的\",{\"1\":{\"59\":1}}],[\"位存放魔数\",{\"1\":{\"110\":1}}],[\"位用于记录\",{\"1\":{\"110\":1}}],[\"低\",{\"1\":{\"110\":1}}],[\"正好写满\",{\"1\":{\"110\":1}}],[\"正常退出时\",{\"1\":{\"119\":1}}],[\"正常退出\",{\"1\":{\"119\":1}}],[\"正常情况下\",{\"1\":{\"115\":1}}],[\"正常情况下所有消费者都是从\",{\"1\":{\"61\":1}}],[\"正常则返回\",{\"1\":{\"115\":1}}],[\"正常注销的话\",{\"1\":{\"90\":1}}],[\"正常关闭时会给\",{\"1\":{\"90\":1}}],[\"正常使用方式应该是通过\",{\"1\":{\"84\":1}}],[\"已使用的\",{\"1\":{\"112\":1}}],[\"已写入的全部消息\",{\"1\":{\"110\":1}}],[\"已经挂了\",{\"1\":{\"89\":1}}],[\"已经追平\",{\"1\":{\"67\":1}}],[\"已经太长了\",{\"1\":{\"60\":1}}],[\"已经被标注\",{\"1\":{\"54\":1}}],[\"选项\",{\"1\":{\"110\":1}}],[\"｜\",{\"1\":{\"110\":1}}],[\"采用将所有消息按抵达\",{\"1\":{\"110\":1}}],[\"连续写好于随机写\",{\"1\":{\"110\":1}}],[\"连接\",{\"1\":{\"89\":1}}],[\"连接的实现类\",{\"1\":{\"67\":1}}],[\"连接到\",{\"1\":{\"65\":1}}],[\"机制\",{\"0\":{\"120\":1}}],[\"机制下一旦发生意外\",{\"1\":{\"115\":1}}],[\"机制通常也是用来替换异步刷盘的\",{\"1\":{\"115\":1}}],[\"机制的介绍\",{\"1\":{\"115\":1}}],[\"机制的存在\",{\"1\":{\"110\":1}}],[\"机制时才会启动\",{\"1\":{\"115\":1}}],[\"机制时\",{\"1\":{\"115\":1}}],[\"机制概述\",{\"0\":{\"63\":1}}],[\"效率很高\",{\"1\":{\"110\":1}}],[\"效率高于随机\",{\"1\":{\"110\":1}}],[\"扯远了\",{\"1\":{\"110\":1}}],[\"家用版有\",{\"1\":{\"110\":1}}],[\"普通硬盘读取数据是从磁道中读取\",{\"1\":{\"110\":1}}],[\"普通消息的处理\",{\"1\":{\"42\":1}}],[\"导致顺序写比随机写快的原因不同\",{\"1\":{\"110\":1}}],[\"导航\",{\"1\":{\"6\":1}}],[\"导航的\",{\"1\":{\"6\":1}}],[\"└──\",{\"1\":{\"109\":9}}],[\"│\",{\"1\":{\"109\":22}}],[\"├──\",{\"1\":{\"109\":16}}],[\"仅供参考\",{\"1\":{\"109\":1}}],[\"仅适用于集群模式\",{\"1\":{\"55\":1}}],[\"供客户端进行消费\",{\"1\":{\"108\":1}}],[\"引擎的默认索引的数据结构\",{\"1\":{\"108\":1}}],[\"硬盘的物理设计本身也会对数据读写有很大的影响\",{\"1\":{\"108\":1}}],[\"链表\",{\"1\":{\"108\":1}}],[\"链接\",{\"1\":{\"68\":2}}],[\"链接这部分都是\",{\"1\":{\"65\":1}}],[\"链接建立后\",{\"1\":{\"63\":1}}],[\"日常我们接触最多的是基于内存编程\",{\"1\":{\"108\":1}}],[\"日志中发现瞬时\",{\"1\":{\"120\":1}}],[\"日志\",{\"1\":{\"55\":1}}],[\"死机\",{\"1\":{\"107\":1}}],[\"突然就加上了\",{\"1\":{\"116\":1}}],[\"突然停电\",{\"1\":{\"107\":1}}],[\"突然记起怕不是\",{\"1\":{\"4\":1}}],[\"经典场景就是\",{\"1\":{\"107\":1}}],[\"经验的话你可以干很多事情\",{\"1\":{\"6\":1}}],[\"产品的方案\",{\"1\":{\"106\":1}}],[\"怎么写什么的\",{\"1\":{\"103\":1}}],[\"层了\",{\"1\":{\"103\":1}}],[\"zipcompresslevel\",{\"1\":{\"103\":1}}],[\"zoom图片缩放\",{\"1\":{\"7\":1}}],[\"压缩级别\",{\"1\":{\"103\":1}}],[\"刚刚创建\",{\"1\":{\"103\":1}}],[\"支持两个阶段\",{\"1\":{\"103\":1}}],[\"支持的其他功能\",{\"1\":{\"43\":1}}],[\"外层的壳子\",{\"1\":{\"103\":1}}],[\"外带自动驼峰\",{\"1\":{\"11\":1}}],[\"逐条\",{\"1\":{\"102\":1}}],[\"逐步整理出一个自己的线上知识库\",{\"1\":{\"12\":1}}],[\"`\",{\"0\":{\"102\":1}}],[\"获取返回结果\",{\"1\":{\"101\":1}}],[\"获取消息有两种模式\",{\"1\":{\"77\":1}}],[\"过来\",{\"1\":{\"112\":1}}],[\"过滤的环节\",{\"1\":{\"111\":1}}],[\"过一遍\",{\"1\":{\"101\":1}}],[\"过期时间\",{\"1\":{\"84\":1}}],[\"好数据包\",{\"1\":{\"101\":1}}],[\"放在什么位置\",{\"1\":{\"101\":1}}],[\"三项属性\",{\"1\":{\"101\":1}}],[\"剩下的两次是默认的重试次数\",{\"1\":{\"101\":1}}],[\"结合这里看\",{\"1\":{\"116\":1}}],[\"结尾部分不是创建了一个空的路由信息么\",{\"1\":{\"101\":1}}],[\"结构\",{\"1\":{\"98\":1}}],[\"搞清楚了什么是\",{\"1\":{\"99\":1}}],[\"标记为\",{\"1\":{\"98\":1}}],[\"标签改为\",{\"1\":{\"3\":1}}],[\"运行中\",{\"1\":{\"98\":1}}],[\"修改为\",{\"1\":{\"98\":1}}],[\"角色\",{\"1\":{\"98\":2}}],[\"明明相同语境下\",{\"1\":{\"116\":1}}],[\"明确\",{\"1\":{\"98\":1}}],[\"明确身份\",{\"1\":{\"98\":1}}],[\"明暗切换如下\",{\"1\":{\"10\":1}}],[\"进来之后直接先标记为\",{\"1\":{\"98\":1}}],[\"进行哈希\",{\"1\":{\"112\":1}}],[\"进行随机读的能力\",{\"1\":{\"110\":1}}],[\"进行持久化\",{\"1\":{\"108\":1}}],[\"进行文件编程时往往会对此进行特殊的优化\",{\"1\":{\"108\":1}}],[\"进行操作\",{\"1\":{\"108\":1}}],[\"进行\",{\"1\":{\"102\":1}}],[\"进行判定\",{\"1\":{\"84\":1}}],[\"进行初始化工作\",{\"1\":{\"83\":1}}],[\"进行管理\",{\"1\":{\"81\":1}}],[\"进行管理的\",{\"1\":{\"6\":1}}],[\"进行路由的过程\",{\"1\":{\"77\":1}}],[\"进行消息传输\",{\"1\":{\"110\":1}}],[\"进行消息的发布和订阅\",{\"1\":{\"76\":1}}],[\"进行消费\",{\"1\":{\"61\":1}}],[\"进行网络通讯的\",{\"1\":{\"68\":1}}],[\"进行一次分配\",{\"1\":{\"58\":1}}],[\"进行修改就会返回\",{\"1\":{\"58\":1}}],[\"进行区分\",{\"1\":{\"46\":1,\"87\":1,\"102\":1}}],[\"进行最后的封装\",{\"1\":{\"42\":1}}],[\"进行分析\",{\"1\":{\"42\":1}}],[\"进行解码并提取出\",{\"1\":{\"41\":1}}],[\"进行通信\",{\"1\":{\"41\":1}}],[\"进行批量注册\",{\"1\":{\"40\":1}}],[\"肯定会进入\",{\"1\":{\"98\":1}}],[\"做了一层包装\",{\"1\":{\"96\":1}}],[\"做个简单说明\",{\"1\":{\"69\":1}}],[\"总不可能去遍历\",{\"1\":{\"110\":1}}],[\"总共最多发3次\",{\"1\":{\"96\":1}}],[\"总结分析\",{\"1\":{\"111\":1}}],[\"总结\",{\"0\":{\"43\":1,\"60\":1,\"73\":1,\"104\":1,\"121\":1},\"1\":{\"55\":1,\"58\":1,\"112\":1}}],[\"生产者组\",{\"1\":{\"96\":1}}],[\"于是我们来看\",{\"1\":{\"95\":1}}],[\"于是打算放弃\",{\"1\":{\"12\":1}}],[\"整个过程中只有交换数据这一步是阻塞的\",{\"1\":{\"115\":1}}],[\"整个过程以描述+代码注释的方式进行\",{\"1\":{\"93\":1}}],[\"整体都采用了固定长度的设计\",{\"1\":{\"111\":1}}],[\"整理完再说\",{\"1\":{\"13\":1}}],[\"收发消息已经全部成功\",{\"1\":{\"92\":1}}],[\"收到的消息会先写入堆外内存并立刻返回\",{\"1\":{\"120\":1}}],[\"收到数据包时\",{\"1\":{\"89\":1}}],[\"收到心跳包后会去更新对应的\",{\"1\":{\"89\":1}}],[\"收到消息后\",{\"1\":{\"77\":1,\"108\":1}}],[\"收到\",{\"1\":{\"67\":1,\"88\":1}}],[\"quick\",{\"1\":{\"92\":1,\"101\":1}}],[\"queuedata\",{\"1\":{\"84\":4,\"88\":1,\"89\":1}}],[\"queuedatalist\",{\"1\":{\"84\":3}}],[\"queueid\",{\"1\":{\"57\":1,\"101\":1,\"111\":3,\"116\":2}}],[\"queueidint\",{\"1\":{\"42\":1}}],[\"queue\",{\"1\":{\"56\":1,\"57\":4,\"58\":1,\"80\":1,\"84\":1,\"87\":1,\"88\":1,\"101\":2,\"116\":2}}],[\"queues\",{\"0\":{\"29\":1},\"1\":{\"24\":1}}],[\"区别很简单不再赘述\",{\"1\":{\"91\":1}}],[\"删除是直接删\",{\"1\":{\"110\":1}}],[\"删除\",{\"0\":{\"90\":1}}],[\"删除这个元素\",{\"1\":{\"25\":1}}],[\"利用\",{\"1\":{\"89\":2,\"119\":1}}],[\"利用自定义的\",{\"1\":{\"66\":1}}],[\"现在我们来看这个转发\",{\"1\":{\"116\":1}}],[\"现在来具体看一下刷盘流程\",{\"1\":{\"115\":1}}],[\"现在作为\",{\"1\":{\"89\":1}}],[\"现在不用手动清缓存了\",{\"1\":{\"4\":1}}],[\"五个表都有涉及\",{\"1\":{\"89\":1}}],[\"五个数据表介绍\",{\"0\":{\"87\":1}}],[\"真实类型\",{\"1\":{\"115\":2}}],[\"真正处理注册逻辑的是routeinfomanager\",{\"1\":{\"89\":1}}],[\"真的不明白\",{\"1\":{\"3\":1}}],[\"编码解码校验请求\",{\"1\":{\"89\":1}}],[\"编码为\",{\"1\":{\"89\":1}}],[\"处理\",{\"1\":{\"89\":2}}],[\"处理心跳包的逻辑了\",{\"1\":{\"89\":1}}],[\"处理心跳包\",{\"1\":{\"89\":1}}],[\"处理方式同上\",{\"1\":{\"57\":2}}],[\"章节\",{\"1\":{\"89\":1}}],[\"维护的数据表中删除\",{\"1\":{\"90\":1}}],[\"维护的五个数据表里删除过期\",{\"1\":{\"84\":2}}],[\"维护了些什么东西\",{\"1\":{\"87\":1}}],[\"承担着类似服务发现\",{\"1\":{\"86\":1}}],[\"管理\",{\"1\":{\"91\":1}}],[\"管理的配置信息\",{\"1\":{\"85\":1}}],[\"管理数据表之一\",{\"1\":{\"84\":1}}],[\"写完给\",{\"1\":{\"115\":1}}],[\"写满\",{\"1\":{\"115\":1}}],[\"写满一个就去写新的\",{\"1\":{\"110\":1}}],[\"写入文件的包装方法\",{\"1\":{\"116\":1}}],[\"写入完成后的异步转发\",{\"1\":{\"111\":1}}],[\"写入很高效\",{\"1\":{\"110\":1}}],[\"写入间隔超过\",{\"1\":{\"66\":1}}],[\"写锁\",{\"1\":{\"84\":1}}],[\"无非就是计算消息起始位置时候\",{\"1\":{\"111\":1}}],[\"无视掉就好了\",{\"1\":{\"102\":1}}],[\"无视掉\",{\"1\":{\"98\":1}}],[\"无法根据\",{\"1\":{\"84\":1}}],[\"无论消费进度在这里代表最新已消费进度还是下一个未消费进度\",{\"1\":{\"111\":1}}],[\"无论那种\",{\"1\":{\"101\":1}}],[\"无论是正常退出还是异常关闭\",{\"1\":{\"119\":2}}],[\"无论是哪种刷盘\",{\"1\":{\"115\":1}}],[\"无论是哪个实现类\",{\"1\":{\"56\":1}}],[\"无论是普通硬盘还是ssd\",{\"1\":{\"108\":1}}],[\"无论是之前的\",{\"1\":{\"66\":1}}],[\"无论是消费成功还是失败\",{\"1\":{\"59\":1}}],[\"无论是否开启高可用模式\",{\"1\":{\"40\":1}}],[\"无论pull\",{\"1\":{\"55\":1}}],[\"无论哪种模式都要注意\",{\"1\":{\"46\":1}}],[\"无论\",{\"1\":{\"42\":1}}],[\"取模得到\",{\"1\":{\"112\":1}}],[\"取绝对值\",{\"1\":{\"112\":1}}],[\"取消读锁\",{\"1\":{\"84\":1}}],[\"取出对应的本地路由信息\",{\"1\":{\"103\":1}}],[\"取出\",{\"1\":{\"57\":1,\"112\":1}}],[\"迭代器\",{\"1\":{\"84\":1}}],[\"加载过程中的一步\",{\"1\":{\"119\":1}}],[\"加载准备好的配置信息啦\",{\"1\":{\"83\":1}}],[\"加了\",{\"1\":{\"111\":1}}],[\"加起来一共占用多大内存\",{\"1\":{\"102\":1}}],[\"加好对应的标记\",{\"1\":{\"102\":1}}],[\"加读锁\",{\"1\":{\"84\":1}}],[\"翻译一下其实就是\",{\"1\":{\"84\":1}}],[\"系统当前时间\",{\"1\":{\"84\":1}}],[\"系列放入微服务部分更新\",{\"1\":{\"13\":1}}],[\"表达式\",{\"1\":{\"84\":1}}],[\"扫描时对\",{\"1\":{\"84\":1}}],[\"扫描一次\",{\"1\":{\"84\":2}}],[\"扫了一眼代码\",{\"1\":{\"7\":1}}],[\"检测心跳\",{\"0\":{\"84\":1}}],[\"检查消息状态\",{\"1\":{\"115\":1}}],[\"检查本地路由表\",{\"1\":{\"77\":1}}],[\"检查\",{\"1\":{\"56\":1,\"101\":1,\"115\":1}}],[\"才继续执行\",{\"1\":{\"101\":1}}],[\"才真正启动服务器\",{\"1\":{\"83\":1}}],[\"才是真正处理\",{\"1\":{\"57\":1}}],[\"全部完成后创建好的\",{\"1\":{\"115\":1}}],[\"全部成功之后\",{\"1\":{\"83\":1}}],[\"全同步模式\",{\"0\":{\"21\":1}}],[\"虽然\",{\"1\":{\"110\":1}}],[\"虽然可能会导致短暂的发送到各个\",{\"1\":{\"80\":1}}],[\"虽然无法写入消息\",{\"1\":{\"70\":1}}],[\"挂掉时则从自身的路由注册表中删除该\",{\"1\":{\"80\":1}}],[\"挂了\",{\"1\":{\"62\":1,\"84\":1}}],[\"确实非常简单对吧\",{\"1\":{\"94\":1}}],[\"确认发给哪个\",{\"1\":{\"80\":1}}],[\"确定自己从哪个\",{\"1\":{\"57\":1}}],[\"比也要更快\",{\"1\":{\"110\":1}}],[\"比较简单\",{\"1\":{\"79\":1}}],[\"比如代码中\",{\"1\":{\"116\":1}}],[\"比如你消费到第3条消息\",{\"1\":{\"111\":1}}],[\"比如连续写入\",{\"1\":{\"110\":1}}],[\"比如使用\",{\"1\":{\"107\":1}}],[\"比如收到消息后先写入缓冲区\",{\"1\":{\"76\":1}}],[\"比如集群模式的消费进度\",{\"1\":{\"70\":1}}],[\"比如前面我们过流程的时候提到的连接\",{\"1\":{\"67\":1}}],[\"比如解码啊\",{\"1\":{\"57\":1}}],[\"比如持久化\",{\"1\":{\"43\":1}}],[\"比如concurrenthashmap则是在特定情况下可以允许任意数量线程并发读取\",{\"1\":{\"26\":1}}],[\"比如我们可以通过collections\",{\"1\":{\"26\":1}}],[\"比如内存\",{\"1\":{\"13\":1}}],[\"比如\",{\"1\":{\"3\":1,\"11\":1,\"25\":1,\"26\":1,\"28\":1,\"41\":1,\"59\":1,\"60\":1,\"84\":1,\"98\":1,\"107\":1,\"108\":1}}],[\"阅读官方文档\",{\"1\":{\"78\":1}}],[\"视为不同个体\",{\"1\":{\"77\":1}}],[\"视为一个集群\",{\"1\":{\"77\":1}}],[\"视为一种\",{\"1\":{\"41\":1}}],[\"路由信息存在\",{\"1\":{\"103\":1}}],[\"路由信息表中\",{\"1\":{\"98\":1}}],[\"路由的功能\",{\"1\":{\"86\":1}}],[\"路由的过程就变成了使用\",{\"1\":{\"77\":1}}],[\"路由管理\",{\"1\":{\"80\":1}}],[\"路径是\",{\"1\":{\"55\":1}}],[\"难道是淘宝网102\",{\"1\":{\"77\":1}}],[\"抛出路由信息错误\",{\"1\":{\"77\":1}}],[\"假设没有开启自动创建主题机制\",{\"1\":{\"77\":1}}],[\"假设一主多从\",{\"1\":{\"22\":1}}],[\"查\",{\"1\":{\"120\":1}}],[\"查找消息的能力\",{\"1\":{\"111\":1}}],[\"查找消息服务\",{\"1\":{\"108\":1}}],[\"查到了就按具体情况选好\",{\"1\":{\"77\":1}}],[\"查询\",{\"1\":{\"77\":1}}],[\"流动到\",{\"1\":{\"77\":1}}],[\"流程就是\",{\"1\":{\"55\":1}}],[\"允许分钟级的数据不一致\",{\"1\":{\"76\":1}}],[\"各个\",{\"1\":{\"76\":1,\"81\":1}}],[\"各种模式等等细节后续章节展开\",{\"1\":{\"77\":1}}],[\"各种\",{\"1\":{\"23\":1}}],[\"服务器版会有一些超大页的\",{\"1\":{\"110\":1}}],[\"服务器\",{\"1\":{\"81\":1}}],[\"服务发现\",{\"1\":{\"76\":1}}],[\"服务注册发现\",{\"1\":{\"80\":2}}],[\"服务注册与发现\",{\"1\":{\"80\":1}}],[\"服务注册\",{\"1\":{\"13\":1}}],[\"像是\",{\"1\":{\"76\":1}}],[\"组提交\",{\"1\":{\"115\":2}}],[\"组装啥的省略\",{\"1\":{\"115\":1}}],[\"组装好各个组件\",{\"1\":{\"39\":1}}],[\"组成的数组\",{\"1\":{\"110\":1}}],[\"组成\",{\"1\":{\"76\":1,\"77\":1,\"110\":1,\"111\":1}}],[\"高并发时就会在\",{\"1\":{\"120\":1}}],[\"高位补0\",{\"1\":{\"111\":1}}],[\"高\",{\"1\":{\"110\":1}}],[\"高性能\",{\"1\":{\"108\":1}}],[\"高吞吐量\",{\"1\":{\"75\":1}}],[\"高可用的消息队列产品\",{\"1\":{\"108\":1}}],[\"高可用也写完啦\",{\"1\":{\"73\":1}}],[\"高可用流程的实现就基本看完啦\",{\"1\":{\"66\":1}}],[\"高可用基本是分布式系统必备特性之一\",{\"1\":{\"61\":1}}],[\"高可用\",{\"0\":{\"61\":1},\"1\":{\"75\":1,\"115\":1}}],[\"高可用等等\",{\"1\":{\"43\":1}}],[\"什么是\",{\"0\":{\"75\":1}}],[\"😃\",{\"1\":{\"73\":1}}],[\"撒花\",{\"1\":{\"73\":1}}],[\"感兴趣可以自行浏览\",{\"1\":{\"115\":1}}],[\"感兴趣可以先去看操作系统\",{\"1\":{\"114\":1}}],[\"感兴趣自行查看\",{\"1\":{\"72\":1}}],[\"感觉\",{\"1\":{\"64\":1}}],[\"篇启动流程中的\",{\"1\":{\"71\":1}}],[\"篇的内容\",{\"1\":{\"64\":1,\"73\":1}}],[\"元数据\",{\"1\":{\"70\":1}}],[\"元数据同步\",{\"0\":{\"70\":1},\"1\":{\"39\":1}}],[\"依然\",{\"1\":{\"111\":1}}],[\"依然是包装\",{\"1\":{\"100\":1}}],[\"依然可以从\",{\"1\":{\"70\":1}}],[\"依赖管理完全不了解的用户其实这是很难自行解决\",{\"1\":{\"6\":1}}],[\"依赖问题已经多次导致用户的\",{\"1\":{\"6\":1}}],[\"依赖问题导致无法\",{\"1\":{\"6\":1}}],[\"宕机时\",{\"1\":{\"70\":1}}],[\"小于\",{\"1\":{\"69\":1}}],[\"大部分情况下就是\",{\"1\":{\"120\":1}}],[\"大体结构\",{\"1\":{\"112\":1}}],[\"大体可以分为以下几个部分\",{\"1\":{\"23\":1}}],[\"大小不定\",{\"1\":{\"110\":1}}],[\"大小由硬盘本身决定\",{\"1\":{\"110\":1}}],[\"大致流程为\",{\"1\":{\"83\":1}}],[\"大致流程\",{\"0\":{\"77\":1}}],[\"大于\",{\"1\":{\"69\":1}}],[\"相当于保存了两部分信息\",{\"1\":{\"116\":1}}],[\"相当于是\",{\"1\":{\"111\":1}}],[\"相当于初始化\",{\"1\":{\"69\":1}}],[\"相同的\",{\"1\":{\"87\":1}}],[\"相关的信息\",{\"1\":{\"89\":1,\"90\":1}}],[\"相关\",{\"1\":{\"81\":1}}],[\"相似逻辑不再解释\",{\"1\":{\"54\":1}}],[\"去找\",{\"1\":{\"110\":1}}],[\"去找到消息的能力\",{\"1\":{\"110\":1}}],[\"去\",{\"1\":{\"77\":1}}],[\"去看之前没继续展开的调用链\",{\"1\":{\"69\":1}}],[\"去确定\",{\"1\":{\"69\":1}}],[\"去执行\",{\"1\":{\"57\":2}}],[\"去执行什么的\",{\"1\":{\"57\":1}}],[\"二分查找\",{\"1\":{\"116\":1}}],[\"二是消息的正确大小\",{\"1\":{\"116\":1}}],[\"二级目录下的文件就是待消费的消息队列\",{\"1\":{\"111\":1}}],[\"二级目录名就是该主题包含的队列id\",{\"1\":{\"111\":1}}],[\"二者实际上非常相似\",{\"1\":{\"68\":1}}],[\"二选一\",{\"1\":{\"39\":1}}],[\"封装成了一个链接对象\",{\"1\":{\"68\":1}}],[\"粘包处理等等常见问题都会有清晰的认识\",{\"1\":{\"67\":1}}],[\"解释的很好\",{\"1\":{\"67\":1}}],[\"解码为\",{\"1\":{\"89\":1}}],[\"解码数据后再判定是什么类型的\",{\"1\":{\"89\":1}}],[\"解码器在\",{\"1\":{\"41\":1}}],[\"解码的部分\",{\"1\":{\"41\":1}}],[\"地址\",{\"1\":{\"67\":1}}],[\"很明显虽然\",{\"1\":{\"110\":1}}],[\"很明显这个方法就是给\",{\"1\":{\"67\":1}}],[\"很明显就是对应三种\",{\"1\":{\"58\":1}}],[\"细节后面会讲\",{\"1\":{\"67\":1}}],[\"细节部分如果有兴趣\",{\"1\":{\"59\":1}}],[\"唤醒\",{\"1\":{\"67\":1}}],[\"新的\",{\"1\":{\"67\":1}}],[\"完全可以看作是一个数组\",{\"1\":{\"111\":1}}],[\"完的\",{\"1\":{\"102\":1}}],[\"完善\",{\"1\":{\"100\":1}}],[\"完成\",{\"1\":{\"78\":1,\"89\":1}}],[\"完成网络传输\",{\"1\":{\"68\":1}}],[\"完成同步\",{\"1\":{\"19\":1}}],[\"完整处理逻辑在主类的同名方法里\",{\"1\":{\"67\":1}}],[\"将\",{\"1\":{\"67\":1,\"98\":1}}],[\"将修改为\",{\"1\":{\"55\":1}}],[\"追平说明主从刷盘均成功\",{\"1\":{\"67\":1}}],[\"超时判断\",{\"1\":{\"103\":1}}],[\"超时都会退出循环\",{\"1\":{\"67\":1}}],[\"超过当前\",{\"1\":{\"110\":1}}],[\"超过120秒没有更新过则从所有数据表中删除该\",{\"1\":{\"89\":1}}],[\"超过\",{\"1\":{\"66\":1}}],[\"甚至超出\",{\"1\":{\"67\":1}}],[\"说明当前要写入\",{\"1\":{\"116\":1}}],[\"说明这个消息没写全\",{\"1\":{\"116\":1}}],[\"说明这个主从集群里一台\",{\"1\":{\"89\":1}}],[\"说明数据安全高于性能\",{\"1\":{\"115\":1}}],[\"说明\",{\"1\":{\"67\":1}}],[\"说白了就是维护\",{\"1\":{\"89\":1}}],[\"说白了\",{\"1\":{\"67\":1}}],[\"说白了广播模式不存在负载均衡这个概念\",{\"1\":{\"58\":1}}],[\"传入的数据包\",{\"1\":{\"89\":1}}],[\"传输完成后进行\",{\"1\":{\"68\":1}}],[\"传回来的下一条新消息的\",{\"1\":{\"67\":1}}],[\"传递过来的\",{\"1\":{\"56\":1}}],[\"叫\",{\"1\":{\"66\":1}}],[\"叫订阅关系\",{\"1\":{\"52\":1}}],[\"概括一下就是\",{\"1\":{\"101\":1}}],[\"概念是基于集群的\",{\"1\":{\"98\":1}}],[\"概念里的读事件\",{\"1\":{\"66\":1}}],[\"概述\",{\"0\":{\"36\":1,\"74\":1,\"80\":1}}],[\"端需要在发送消息时提供容错来保证消息发送成功\",{\"1\":{\"81\":1}}],[\"端当前最大偏移量\",{\"1\":{\"66\":1}}],[\"端口上的\",{\"1\":{\"67\":1}}],[\"端口\",{\"1\":{\"63\":1,\"64\":1}}],[\"距离上次\",{\"1\":{\"66\":1}}],[\"事件\",{\"1\":{\"65\":1,\"67\":1}}],[\"事务消息的处理\",{\"1\":{\"42\":1}}],[\"转发\",{\"1\":{\"115\":1}}],[\"转发给\",{\"1\":{\"112\":1}}],[\"转换类型\",{\"1\":{\"65\":1}}],[\"转交给\",{\"1\":{\"57\":1}}],[\"他俩的源码就不展开看了\",{\"1\":{\"115\":1}}],[\"他会停个\",{\"1\":{\"115\":1}}],[\"他的\",{\"1\":{\"98\":1}}],[\"他的其他方法就不列出来了\",{\"1\":{\"96\":1}}],[\"他里面维护了一个\",{\"1\":{\"98\":1}}],[\"他们仨\",{\"1\":{\"115\":1}}],[\"他们是会相互同步信息最终数据一致的\",{\"1\":{\"80\":1}}],[\"他们的\",{\"1\":{\"65\":1}}],[\"他有俩内部类\",{\"1\":{\"68\":1}}],[\"他是用来代替\",{\"1\":{\"115\":1}}],[\"他是\",{\"1\":{\"23\":1}}],[\"监听\",{\"1\":{\"64\":1}}],[\"监控关闭成功\",{\"1\":{\"84\":1}}],[\"监控文件列表\",{\"1\":{\"39\":1}}],[\"监控\",{\"1\":{\"13\":1,\"84\":1}}],[\"属于存储模块\",{\"1\":{\"64\":1}}],[\"属性默认是\",{\"1\":{\"98\":1}}],[\"属性就是\",{\"1\":{\"68\":1}}],[\"属性\",{\"1\":{\"56\":1,\"57\":1,\"96\":1,\"103\":1}}],[\"8\",{\"1\":{\"110\":3,\"111\":2,\"112\":4,\"113\":1}}],[\"8k\",{\"1\":{\"110\":1}}],[\"8888\",{\"1\":{\"64\":1}}],[\"82a6b1\",{\"1\":{\"10\":1}}],[\"保护代码\",{\"1\":{\"103\":1}}],[\"保存消息的流程\",{\"1\":{\"66\":1}}],[\"保存收到的消息后继续重复以上流程\",{\"1\":{\"63\":1}}],[\"保存\",{\"1\":{\"63\":1,\"66\":1}}],[\"保证每个\",{\"1\":{\"58\":1}}],[\"保证一个队列一次只被一个线程消费\",{\"1\":{\"56\":1}}],[\"哪怕你不去看代码现在也应该能推测出来\",{\"1\":{\"60\":1}}],[\"又不是写书\",{\"1\":{\"60\":1}}],[\"个文件则从第一个开始恢复\",{\"1\":{\"119\":1}}],[\"个字节的空闲\",{\"1\":{\"110\":1}}],[\"个\",{\"1\":{\"110\":1,\"111\":1}}],[\"个人建议两种方式结合\",{\"1\":{\"59\":1}}],[\"个线程的线程池\",{\"1\":{\"56\":1}}],[\"另一种就是普通的\",{\"1\":{\"115\":1}}],[\"另一方面你可以去看内部协议的实现\",{\"1\":{\"59\":1}}],[\"另一个已弃用\",{\"1\":{\"47\":1}}],[\"另一个检查你生成的\",{\"1\":{\"4\":1}}],[\"技术内幕\",{\"1\":{\"59\":1,\"70\":1}}],[\"或\",{\"1\":{\"59\":2}}],[\"或者通俗的说就是往硬盘里写数据\",{\"1\":{\"110\":1}}],[\"或者理解为二进制数据\",{\"1\":{\"89\":1}}],[\"或者索引的方式检索消息等等\",{\"1\":{\"76\":1}}],[\"或者收到新地址时\",{\"1\":{\"67\":1}}],[\"或者对于\",{\"1\":{\"67\":1}}],[\"或者说是关闭\",{\"1\":{\"89\":1}}],[\"或者说\",{\"1\":{\"64\":1,\"119\":1}}],[\"或者看书也行\",{\"1\":{\"57\":1}}],[\"或者\",{\"1\":{\"56\":1,\"76\":1,\"89\":1,\"98\":1,\"115\":1}}],[\"或者是\",{\"1\":{\"30\":1}}],[\"或者是一个正在执行中的\",{\"1\":{\"30\":1}}],[\"或者直接换\",{\"1\":{\"6\":1}}],[\"或者右上角搜索本站\",{\"1\":{\"2\":1}}],[\"见\",{\"1\":{\"59\":1}}],[\"见基础概念\",{\"1\":{\"57\":1}}],[\"亦或者其他情况\",{\"1\":{\"59\":1}}],[\"亦或者是自行实现消费客户端\",{\"1\":{\"47\":1}}],[\"500\",{\"1\":{\"115\":1}}],[\"500w\",{\"1\":{\"112\":4}}],[\"500万个\",{\"1\":{\"112\":1}}],[\"50000\",{\"1\":{\"103\":1}}],[\"50ms\",{\"1\":{\"57\":1}}],[\"5s\",{\"1\":{\"66\":2,\"67\":1}}],[\"5\",{\"1\":{\"58\":1,\"66\":2,\"73\":1,\"84\":1,\"103\":1,\"115\":1}}],[\"数了一下\",{\"1\":{\"96\":1}}],[\"数组下标和对应\",{\"1\":{\"111\":1}}],[\"数组\",{\"1\":{\"89\":1}}],[\"数据也是来自\",{\"1\":{\"112\":1}}],[\"数据结构为\",{\"1\":{\"84\":1}}],[\"数据\",{\"1\":{\"68\":1}}],[\"数据此时就像水管里的水流\",{\"1\":{\"67\":1}}],[\"数据库可靠性最高\",{\"1\":{\"107\":1}}],[\"数据库就粗略的分为\",{\"1\":{\"13\":1}}],[\"数据库\",{\"0\":{\"15\":1},\"1\":{\"13\":1}}],[\"数量发生变化\",{\"1\":{\"58\":1}}],[\"剔除无效队列\",{\"1\":{\"58\":1}}],[\"遍历\",{\"1\":{\"58\":1,\"84\":1}}],[\"排序\",{\"1\":{\"58\":1}}],[\"列表\",{\"1\":{\"58\":1,\"67\":1}}],[\"延迟解锁的值默认为\",{\"1\":{\"58\":1}}],[\"四条属性\",{\"1\":{\"58\":1}}],[\"66\",{\"1\":{\"103\":1}}],[\"64\",{\"1\":{\"58\":1}}],[\"60s\",{\"1\":{\"56\":1}}],[\"60\",{\"1\":{\"56\":1,\"103\":1}}],[\"60000\",{\"1\":{\"39\":1}}],[\"拿到最新的\",{\"1\":{\"115\":1}}],[\"拿到的\",{\"1\":{\"69\":1}}],[\"拿到订阅数据\",{\"1\":{\"57\":1}}],[\"拿到返回结果后解码并本地缓存\",{\"1\":{\"40\":1}}],[\"移除当前\",{\"1\":{\"57\":1}}],[\"移动到\",{\"1\":{\"3\":1}}],[\"偏移量+高位补0\",{\"1\":{\"110\":1}}],[\"偏移量非法\",{\"1\":{\"57\":1}}],[\"偏序关系的介绍\",{\"1\":{\"25\":1}}],[\"状态去调用\",{\"1\":{\"116\":1}}],[\"状态是否正常\",{\"1\":{\"115\":1}}],[\"状态字段\",{\"1\":{\"103\":1}}],[\"状态大部分与清理无效\",{\"1\":{\"81\":1}}],[\"状态\",{\"1\":{\"67\":1,\"115\":1,\"116\":1}}],[\"状态处理\",{\"1\":{\"57\":1}}],[\"状态信息的处理\",{\"1\":{\"57\":1}}],[\"立刻再提交一个\",{\"1\":{\"57\":1}}],[\"回到\",{\"1\":{\"66\":1}}],[\"回头重新调整一下\",{\"1\":{\"64\":1}}],[\"回\",{\"1\":{\"57\":1,\"115\":1}}],[\"触发控流\",{\"1\":{\"57\":2}}],[\"控流的处理方式就是前面贴过的\",{\"1\":{\"57\":1}}],[\"控流\",{\"1\":{\"57\":1}}],[\"核心机制\",{\"0\":{\"114\":1}}],[\"核心类\",{\"1\":{\"66\":1}}],[\"核心内容在第三段\",{\"1\":{\"57\":1}}],[\"核心功能\",{\"0\":{\"41\":1}}],[\"老样子删减\",{\"1\":{\"57\":1}}],[\"计算消息在\",{\"1\":{\"116\":1}}],[\"计算出\",{\"1\":{\"112\":1}}],[\"计算方式也差不多\",{\"1\":{\"112\":1}}],[\"计算方式跟\",{\"1\":{\"112\":1}}],[\"计算方式类似\",{\"1\":{\"57\":1}}],[\"计算实际消费位点\",{\"1\":{\"57\":1}}],[\"计算真实提交间隔\",{\"1\":{\"56\":1}}],[\"远程\",{\"1\":{\"57\":1}}],[\"远程拉取\",{\"1\":{\"55\":1}}],[\"强转\",{\"1\":{\"57\":1}}],[\"强制类型转换\",{\"1\":{\"57\":1}}],[\"kv存储方式基本介于中间\",{\"1\":{\"107\":1}}],[\"kv\",{\"1\":{\"98\":1,\"102\":1,\"107\":1}}],[\"kvconfigmanager\",{\"1\":{\"85\":1}}],[\"keyhash\",{\"1\":{\"112\":1}}],[\"key\",{\"1\":{\"57\":2,\"69\":1,\"84\":1,\"96\":1,\"98\":2,\"102\":1,\"103\":1,\"108\":1,\"112\":11}}],[\"kinds\",{\"1\":{\"31\":1}}],[\"构造\",{\"1\":{\"115\":1}}],[\"构造消息\",{\"1\":{\"94\":1}}],[\"构造数据包的内容\",{\"1\":{\"89\":1}}],[\"构造方法\",{\"1\":{\"57\":1,\"58\":1,\"96\":1,\"103\":1}}],[\"构建项目并输出\",{\"1\":{\"9\":1}}],[\"周期执行\",{\"1\":{\"57\":1}}],[\"存取\",{\"1\":{\"110\":1}}],[\"存\",{\"1\":{\"103\":1}}],[\"存在则直接返回\",{\"1\":{\"98\":1}}],[\"存在就更新\",{\"1\":{\"89\":1}}],[\"存到\",{\"1\":{\"84\":1,\"102\":1}}],[\"存储到\",{\"1\":{\"119\":1}}],[\"存储目录\",{\"1\":{\"110\":1,\"111\":1}}],[\"存储模块的目录结构\",{\"0\":{\"109\":1}}],[\"存储模块启动时会启动\",{\"1\":{\"64\":1}}],[\"存储\",{\"1\":{\"107\":1}}],[\"存储方案简介\",{\"0\":{\"107\":1}}],[\"存储消息\",{\"1\":{\"75\":1,\"77\":1,\"115\":1}}],[\"存放\",{\"1\":{\"57\":1}}],[\"存入\",{\"1\":{\"55\":1,\"57\":2}}],[\"啊\",{\"1\":{\"57\":1}}],[\"被弃用的原因\",{\"1\":{\"57\":1}}],[\"被锁住且锁未过期\",{\"1\":{\"56\":1}}],[\"么\",{\"1\":{\"57\":1}}],[\"读出该文件第一条消息的存储时间\",{\"1\":{\"119\":1}}],[\"读写权限\",{\"1\":{\"88\":1}}],[\"读写的类\",{\"1\":{\"68\":1}}],[\"读写分离的大致逻辑就不再重复了\",{\"1\":{\"69\":1}}],[\"读写分离\",{\"1\":{\"61\":1}}],[\"读写分离也并不彻底\",{\"1\":{\"61\":1}}],[\"读到哪就指到哪\",{\"1\":{\"67\":1}}],[\"读到数据后调用\",{\"1\":{\"66\":1}}],[\"读数据的时候要么是读到没数据为止\",{\"1\":{\"67\":1}}],[\"读事件\",{\"1\":{\"67\":1}}],[\"读列表\",{\"1\":{\"67\":1}}],[\"读取数据的方式有点像内存\",{\"1\":{\"110\":1}}],[\"读取\",{\"1\":{\"66\":1}}],[\"读取消费位点\",{\"1\":{\"57\":1}}],[\"读者可以自行从反推验证\",{\"1\":{\"56\":1}}],[\"读文件\",{\"1\":{\"55\":1}}],[\"换句话说这个是\",{\"1\":{\"88\":1}}],[\"换句话说这一步就是执行真正的消费\",{\"1\":{\"56\":1}}],[\"换句话说\",{\"1\":{\"77\":1,\"116\":1}}],[\"换句话说它不需要\",{\"1\":{\"60\":1}}],[\"换句话说就是一条消息只能被集群\",{\"1\":{\"77\":1}}],[\"换句话说就是消费组内的每个\",{\"1\":{\"58\":1}}],[\"换句话说就是\",{\"1\":{\"56\":1}}],[\"围绕\",{\"1\":{\"56\":1}}],[\"条消息存入\",{\"1\":{\"56\":1}}],[\"由\",{\"1\":{\"77\":1,\"110\":1}}],[\"由从切主\",{\"1\":{\"69\":1}}],[\"由上述代码我们可以得出一个结论\",{\"1\":{\"67\":1}}],[\"由此我们可以知道顺序消费时\",{\"1\":{\"56\":1}}],[\"由于后两者的数据均来自\",{\"1\":{\"119\":1}}],[\"由于多了字段\",{\"1\":{\"117\":1}}],[\"由于消费进度变化很快\",{\"1\":{\"72\":1}}],[\"由于本文跳过了关于\",{\"1\":{\"67\":1}}],[\"由于高可用的相关逻辑也跟注册耦合在一起\",{\"1\":{\"40\":1}}],[\"由于\",{\"1\":{\"40\":1,\"58\":1,\"89\":1,\"110\":1}}],[\"由于完全不懂\",{\"1\":{\"3\":1}}],[\"退出循环的条件就是\",{\"1\":{\"56\":1}}],[\"略\",{\"1\":{\"56\":1,\"57\":2,\"58\":1,\"85\":1}}],[\"平时消息是存储于\",{\"1\":{\"56\":1}}],[\"平时说\",{\"1\":{\"23\":1}}],[\"锁过期\",{\"1\":{\"56\":1}}],[\"且\",{\"1\":{\"56\":2,\"57\":1}}],[\"当然综合来看其实差别不大\",{\"1\":{\"110\":1}}],[\"当然不是所有的\",{\"1\":{\"41\":1}}],[\"当需要检索消息时\",{\"1\":{\"108\":1}}],[\"当消息存入\",{\"1\":{\"108\":1}}],[\"当检测的\",{\"1\":{\"80\":1}}],[\"当你写错\",{\"1\":{\"77\":1}}],[\"当前的\",{\"1\":{\"68\":1}}],[\"当前时间\",{\"1\":{\"56\":1}}],[\"当\",{\"1\":{\"61\":1,\"67\":1,\"108\":1}}],[\"当队列数\",{\"1\":{\"58\":1}}],[\"当成前指针即可\",{\"1\":{\"112\":1}}],[\"当成\",{\"1\":{\"56\":1}}],[\"暂且就简单理解为待消费的消息队列\",{\"1\":{\"56\":1}}],[\"暂时\",{\"1\":{\"4\":1}}],[\"时从\",{\"1\":{\"119\":1}}],[\"时讲过的\",{\"1\":{\"116\":1}}],[\"时的信息\",{\"1\":{\"112\":1}}],[\"时发现自己的长度\",{\"1\":{\"110\":1}}],[\"时具体展开\",{\"1\":{\"101\":1}}],[\"时我们自定义的\",{\"1\":{\"98\":1}}],[\"时没有自定义\",{\"1\":{\"98\":1}}],[\"时为从节点\",{\"1\":{\"87\":1}}],[\"时由主切从\",{\"1\":{\"69\":1}}],[\"时会设置\",{\"1\":{\"64\":1}}],[\"时不提交消费状态\",{\"1\":{\"58\":1}}],[\"时\",{\"1\":{\"56\":1,\"61\":2,\"62\":1,\"84\":1,\"98\":1,\"101\":2}}],[\"要恢复的文件自然就是\",{\"1\":{\"119\":1}}],[\"要么用关系型数据库\",{\"1\":{\"107\":1}}],[\"要么使用各类\",{\"1\":{\"107\":1}}],[\"要么你直接使用文件系统进行数据存储\",{\"1\":{\"107\":1}}],[\"要么是读固定长度\",{\"1\":{\"67\":1}}],[\"要先去\",{\"1\":{\"91\":1}}],[\"要请求的\",{\"1\":{\"68\":1}}],[\"要区分开\",{\"1\":{\"64\":1}}],[\"要同步到\",{\"1\":{\"62\":1}}],[\"要看一下\",{\"1\":{\"57\":1}}],[\"要注意创建\",{\"1\":{\"56\":1}}],[\"要添加到源码库的\",{\"1\":{\"5\":1}}],[\"代替了该\",{\"1\":{\"89\":1}}],[\"代码就不贴了\",{\"1\":{\"119\":1}}],[\"代码可读性迅速降低\",{\"1\":{\"84\":1}}],[\"代码如下\",{\"1\":{\"84\":1}}],[\"代码\",{\"1\":{\"67\":1}}],[\"代码略\",{\"1\":{\"57\":1}}],[\"代码太长还是大量省略\",{\"1\":{\"56\":1}}],[\"代表文件写满了\",{\"1\":{\"115\":1}}],[\"代表写入成功\",{\"1\":{\"115\":1}}],[\"代表\",{\"1\":{\"103\":1}}],[\"代表按照\",{\"1\":{\"68\":1}}],[\"代表拉取还未开始\",{\"1\":{\"68\":1}}],[\"代表远程\",{\"1\":{\"57\":1}}],[\"代表异步计算的返回结果\",{\"1\":{\"23\":1}}],[\"载入消费位点\",{\"1\":{\"55\":1}}],[\"第四步\",{\"1\":{\"55\":1}}],[\"第三步\",{\"1\":{\"55\":1}}],[\"第二步\",{\"1\":{\"55\":1}}],[\"第一步的实现已经看完了\",{\"1\":{\"64\":1}}],[\"第一步\",{\"1\":{\"55\":1}}],[\"重置为一个空\",{\"1\":{\"115\":1}}],[\"重启\",{\"1\":{\"107\":1}}],[\"重试逻辑\",{\"1\":{\"101\":1}}],[\"重试的响应码\",{\"1\":{\"96\":1}}],[\"重试组和\",{\"1\":{\"55\":1}}],[\"重复就会抛下面的异常\",{\"1\":{\"98\":1}}],[\"重复以上流程\",{\"1\":{\"66\":1}}],[\"重复消费是有可能发生的\",{\"1\":{\"58\":1}}],[\"重新计算它现在要负载消费哪个队列\",{\"1\":{\"58\":1}}],[\"重新计算消费位点并重拉消息\",{\"1\":{\"58\":1}}],[\"重新计算并更新偏移量\",{\"1\":{\"57\":1}}],[\"重新\",{\"1\":{\"57\":1}}],[\"重要重写\",{\"1\":{\"57\":1}}],[\"重点看\",{\"1\":{\"55\":1}}],[\"避免消费卡住\",{\"1\":{\"55\":1}}],[\"秒\",{\"1\":{\"112\":1}}],[\"秒扫一次它维护的\",{\"1\":{\"84\":1}}],[\"秒扫描一次\",{\"1\":{\"84\":1}}],[\"秒调用\",{\"1\":{\"55\":1}}],[\"秒会重新注册一次\",{\"1\":{\"40\":1}}],[\"每当\",{\"1\":{\"115\":1}}],[\"每当消息的\",{\"1\":{\"112\":1}}],[\"每当消息送达\",{\"1\":{\"62\":1}}],[\"每个文件大小固定\",{\"1\":{\"110\":1}}],[\"每个队列仅被一个消费者消费\",{\"1\":{\"58\":1}}],[\"每隔30秒向\",{\"1\":{\"89\":1}}],[\"每次\",{\"1\":{\"88\":1}}],[\"每\",{\"1\":{\"55\":2,\"71\":1,\"77\":1,\"84\":2}}],[\"啥也不干\",{\"1\":{\"55\":1}}],[\"啥的有兴趣自己去看\",{\"1\":{\"102\":1}}],[\"啥的就不更啦\",{\"1\":{\"73\":1}}],[\"啥的\",{\"1\":{\"28\":1}}],[\"序列化为\",{\"1\":{\"55\":1}}],[\"根据预期的\",{\"1\":{\"116\":1}}],[\"根据结果更新\",{\"1\":{\"116\":1}}],[\"根据以上说明你可以发现每个\",{\"1\":{\"112\":1}}],[\"根据路由信息找到用哪个\",{\"1\":{\"101\":1}}],[\"根据角色设置\",{\"1\":{\"64\":1}}],[\"根据请求返回消息给\",{\"1\":{\"63\":1}}],[\"根据消费结果状态的不同\",{\"1\":{\"59\":1}}],[\"根据消费模式判定\",{\"1\":{\"55\":1}}],[\"根据\",{\"1\":{\"58\":1,\"66\":1,\"69\":2,\"84\":2,\"103\":1,\"112\":1,\"116\":1}}],[\"根据不同策略来分配\",{\"1\":{\"58\":1}}],[\"根据默认的初始消费位点\",{\"1\":{\"57\":1}}],[\"根据参数提供的俩\",{\"1\":{\"56\":1}}],[\"根据我解决问题过程中搜索到的内容来看\",{\"1\":{\"6\":1}}],[\"装配\",{\"1\":{\"55\":1}}],[\"装入\",{\"1\":{\"40\":1}}],[\"校验消息合法性\",{\"1\":{\"102\":1}}],[\"校验结束\",{\"1\":{\"98\":1}}],[\"校验开始\",{\"1\":{\"98\":1}}],[\"校验\",{\"1\":{\"55\":2,\"100\":1,\"101\":2}}],[\"省略日志\",{\"1\":{\"55\":1}}],[\"命名空间的包装也会在这里进行\",{\"1\":{\"55\":1}}],[\"命令\",{\"0\":{\"9\":1}}],[\"开启\",{\"1\":{\"115\":1}}],[\"开头的就是最新消息\",{\"1\":{\"112\":1}}],[\"开头的就是\",{\"1\":{\"112\":1}}],[\"开头的都是官方维护的插件\",{\"1\":{\"7\":1}}],[\"开展的\",{\"1\":{\"77\":1}}],[\"开始判定\",{\"1\":{\"119\":1}}],[\"开始阅读前可以先对比以下\",{\"1\":{\"116\":1}}],[\"开始遍历\",{\"1\":{\"84\":1}}],[\"开始\",{\"1\":{\"54\":1}}],[\"客户端启动后发出首次心跳\",{\"1\":{\"98\":1}}],[\"客户端发送请求时候将请求类型+请求参数一起通过编码器\",{\"1\":{\"89\":1}}],[\"客户端从\",{\"1\":{\"76\":1}}],[\"客户端配置\",{\"1\":{\"55\":1}}],[\"客户端\",{\"1\":{\"54\":1,\"55\":1,\"98\":4}}],[\"跟异步刷盘那个线程一致\",{\"1\":{\"115\":1}}],[\"跟自身\",{\"1\":{\"110\":1}}],[\"跟传统硬盘比\",{\"1\":{\"110\":1}}],[\"跟普通硬盘磁盘式的写入方式不同\",{\"1\":{\"110\":1}}],[\"跟前面区别不大\",{\"1\":{\"84\":1}}],[\"跟前面一样\",{\"1\":{\"56\":1}}],[\"跟\",{\"1\":{\"54\":1,\"55\":1,\"57\":1,\"101\":1}}],[\"跟没看懂没差别\",{\"1\":{\"3\":1}}],[\"介绍\",{\"1\":{\"53\":1}}],[\"入手\",{\"1\":{\"53\":1}}],[\"订阅的\",{\"1\":{\"52\":1}}],[\"订阅关系一致\",{\"0\":{\"52\":1},\"1\":{\"52\":2}}],[\"订阅关系\",{\"0\":{\"52\":1}}],[\"初始启动延迟3秒\",{\"1\":{\"98\":1}}],[\"初始化\",{\"1\":{\"98\":1}}],[\"初始化时启动的定时任务之一\",{\"1\":{\"84\":1}}],[\"初始化并启动\",{\"1\":{\"55\":1}}],[\"初始化和组装\",{\"1\":{\"55\":1}}],[\"初始消费位点的值存储于\",{\"1\":{\"51\":1}}],[\"初步印证了之前\",{\"1\":{\"42\":1}}],[\"默认情况下\",{\"1\":{\"120\":1}}],[\"默认情况下会为每个\",{\"1\":{\"87\":1,\"96\":1}}],[\"默认情况\",{\"1\":{\"115\":1}}],[\"默认是\",{\"1\":{\"84\":1,\"115\":1}}],[\"默认只访问\",{\"1\":{\"69\":1}}],[\"默认值\",{\"1\":{\"68\":1,\"110\":1}}],[\"默认值是\",{\"1\":{\"64\":1}}],[\"默认值虽然是\",{\"1\":{\"64\":1}}],[\"默认的是\",{\"1\":{\"58\":1}}],[\"默认\",{\"1\":{\"57\":2,\"115\":2}}],[\"默认为同步的方式\",{\"1\":{\"101\":1}}],[\"默认为\",{\"1\":{\"50\":1,\"56\":2,\"57\":1,\"101\":1,\"110\":1,\"115\":1}}],[\"默认10秒一次\",{\"1\":{\"39\":1}}],[\"次\",{\"1\":{\"49\":1}}],[\"次也没找到线上显示错误的原因\",{\"1\":{\"4\":1}}],[\"至少是本文说的\",{\"1\":{\"116\":1}}],[\"至少消费成功\",{\"1\":{\"49\":1}}],[\"至空\",{\"1\":{\"67\":1}}],[\"至此作为消息队列\",{\"1\":{\"110\":1}}],[\"至此\",{\"1\":{\"40\":1,\"56\":1,\"64\":1,\"108\":1}}],[\"广播模式则是把消费组内的\",{\"1\":{\"77\":1}}],[\"广播模式跟负载均衡这个概念其实没啥关系\",{\"1\":{\"58\":1}}],[\"广播模式存在本地\",{\"1\":{\"55\":1}}],[\"广播模式本地存取\",{\"1\":{\"55\":1}}],[\"广播模式下则由\",{\"1\":{\"51\":1}}],[\"广播模式下\",{\"1\":{\"49\":1}}],[\"广播模式\",{\"1\":{\"49\":1,\"77\":1}}],[\"该参数你可以认为是用来强制要求线程提交数据的\",{\"1\":{\"115\":1}}],[\"该方法有两种实现\",{\"1\":{\"115\":1}}],[\"该方法最终是通过调用\",{\"1\":{\"69\":1}}],[\"该循环运行间隔为\",{\"1\":{\"67\":1}}],[\"该消息存入\",{\"1\":{\"112\":1}}],[\"该消息在\",{\"1\":{\"111\":1}}],[\"该消息才被视为已消费\",{\"1\":{\"49\":1}}],[\"该消息就被视为已消费\",{\"1\":{\"49\":1}}],[\"该页面标题就是目录本身\",{\"1\":{\"11\":1}}],[\"任意应用的存储方案常见的基本上就三种\",{\"1\":{\"107\":1}}],[\"任意一条消息\",{\"1\":{\"49\":2}}],[\"任务的提交关闭调用等方法\",{\"1\":{\"30\":1}}],[\"任务就是执行内容\",{\"1\":{\"23\":1}}],[\"任务\",{\"1\":{\"23\":1}}],[\"集合一一映射\",{\"1\":{\"88\":1}}],[\"集合\",{\"1\":{\"58\":1}}],[\"集合更一部分\",{\"1\":{\"13\":1}}],[\"集群发送一次心跳包\",{\"1\":{\"89\":1}}],[\"集群中\",{\"1\":{\"81\":1}}],[\"集群两种实现\",{\"1\":{\"57\":1}}],[\"集群和广播模式下的具体细节等\",{\"1\":{\"53\":1}}],[\"集群模式就是把消费组内的所有\",{\"1\":{\"77\":1}}],[\"集群模式则是先执行\",{\"1\":{\"58\":1}}],[\"集群模式存储在\",{\"1\":{\"55\":1}}],[\"集群模式从\",{\"1\":{\"55\":1}}],[\"集群模式下\",{\"1\":{\"49\":1,\"50\":1,\"51\":1}}],[\"集群模式\",{\"0\":{\"50\":1},\"1\":{\"49\":1,\"55\":1,\"56\":1,\"77\":1}}],[\"集群模式和广播模式\",{\"1\":{\"49\":1}}],[\"提交\",{\"1\":{\"115\":1}}],[\"提交消费位点\",{\"1\":{\"58\":1}}],[\"提交复制消费的执行器执行\",{\"1\":{\"57\":1}}],[\"提交到\",{\"1\":{\"57\":1}}],[\"提交给线程池的重要\",{\"1\":{\"57\":1}}],[\"提交一个周期任务给\",{\"1\":{\"55\":1}}],[\"提示\",{\"1\":{\"49\":1,\"51\":1,\"65\":1,\"108\":1}}],[\"提供的可重入读写锁\",{\"1\":{\"84\":1}}],[\"提供了按照消息属性进行检索的能力\",{\"1\":{\"112\":1}}],[\"提供了六种分配策略\",{\"1\":{\"50\":1}}],[\"提供了两种消费模式\",{\"1\":{\"77\":1}}],[\"提供了两种\",{\"1\":{\"49\":1}}],[\"提供了\",{\"1\":{\"47\":1}}],[\"提供了基于不同时间粒度的操作方法\",{\"1\":{\"28\":1}}],[\"提供服务\",{\"1\":{\"39\":1}}],[\"参考订阅关系\",{\"1\":{\"48\":1}}],[\"参数的类型就是\",{\"1\":{\"69\":1}}],[\"参数可以直接看作\",{\"1\":{\"67\":1}}],[\"参数就没啥用\",{\"1\":{\"57\":1}}],[\"参数仅作用于顺序消费\",{\"1\":{\"57\":1}}],[\"参数\",{\"1\":{\"3\":1,\"84\":2,\"102\":1}}],[\"模式的\",{\"1\":{\"60\":1,\"89\":1}}],[\"模式的默认实现类\",{\"1\":{\"47\":2}}],[\"模式和并发消费的流程\",{\"1\":{\"60\":1}}],[\"模式根据\",{\"1\":{\"58\":1}}],[\"模式为\",{\"1\":{\"58\":1}}],[\"模式为例\",{\"1\":{\"58\":1}}],[\"模式\",{\"1\":{\"55\":1,\"89\":1}}],[\"模式目前默认为\",{\"1\":{\"54\":1}}],[\"模型\",{\"1\":{\"13\":1}}],[\"两次有效提交的最大间隔\",{\"1\":{\"115\":1}}],[\"两种逻辑\",{\"1\":{\"115\":1}}],[\"两种情况下\",{\"1\":{\"90\":1}}],[\"两种方式\",{\"1\":{\"57\":1}}],[\"两个队列交换的时机是\",{\"1\":{\"67\":1}}],[\"两个方法合起来实现了\",{\"1\":{\"67\":1}}],[\"两个方法\",{\"1\":{\"57\":1}}],[\"两个接口以及对应的实现类\",{\"1\":{\"47\":1}}],[\"两类\",{\"1\":{\"13\":1}}],[\"优势是不需要做额外的工作\",{\"1\":{\"46\":1}}],[\"牺牲队列本身的高可用\",{\"1\":{\"46\":1}}],[\"既要避免消息在本地堆积\",{\"1\":{\"46\":1}}],[\"拉数据\",{\"1\":{\"80\":1}}],[\"拉模式\",{\"1\":{\"77\":1}}],[\"拉一次\",{\"1\":{\"77\":1}}],[\"拉回的第一条消息的\",{\"1\":{\"57\":1}}],[\"拉回了新消息\",{\"1\":{\"57\":1}}],[\"拉取\",{\"1\":{\"68\":1}}],[\"拉取间隔默认是0\",{\"1\":{\"57\":1}}],[\"拉取到\",{\"1\":{\"57\":1}}],[\"拉取消息以及消息持久化\",{\"1\":{\"76\":1}}],[\"拉取消息的是\",{\"1\":{\"69\":1}}],[\"拉取消息\",{\"1\":{\"55\":1,\"62\":1}}],[\"拉取消息并存入\",{\"1\":{\"46\":1}}],[\"拉两种模式都支持\",{\"1\":{\"46\":1}}],[\"应该也算是\",{\"1\":{\"116\":1}}],[\"应该自行在配置文件中设置好\",{\"1\":{\"64\":1}}],[\"应该是服务端自动向\",{\"1\":{\"46\":1}}],[\"应用中也可以通过自定义\",{\"1\":{\"41\":1}}],[\"应用而言\",{\"1\":{\"41\":1}}],[\"推模式依然是\",{\"1\":{\"77\":1}}],[\"推模式\",{\"1\":{\"77\":1}}],[\"推送\",{\"1\":{\"76\":1}}],[\"推送消息\",{\"1\":{\"46\":1,\"77\":2}}],[\"推\",{\"1\":{\"46\":1}}],[\"4字节\",{\"1\":{\"110\":2}}],[\"4m\",{\"1\":{\"96\":1}}],[\"4mb\",{\"1\":{\"66\":1}}],[\"4k对齐\",{\"1\":{\"110\":1}}],[\"4k\",{\"1\":{\"96\":1,\"110\":3}}],[\"4个\",{\"1\":{\"87\":2,\"96\":2,\"101\":2}}],[\"40\",{\"1\":{\"61\":1,\"69\":4,\"112\":4}}],[\"404\",{\"1\":{\"6\":1,\"123\":1}}],[\"4\",{\"1\":{\"45\":1,\"52\":1,\"58\":1,\"64\":1,\"66\":1,\"96\":3,\"110\":2,\"111\":1,\"112\":6,\"115\":2,\"122\":1}}],[\"先\",{\"1\":{\"119\":1}}],[\"先上锁\",{\"1\":{\"115\":1}}],[\"先找到消息的\",{\"1\":{\"112\":1}}],[\"先回顾一下\",{\"1\":{\"110\":1}}],[\"先定位磁道\",{\"1\":{\"110\":1}}],[\"先笼统的解释\",{\"1\":{\"106\":1}}],[\"先看属性和构造方法\",{\"1\":{\"103\":1}}],[\"先看他的属性和构造方法\",{\"1\":{\"96\":1}}],[\"先看一下它是什么\",{\"1\":{\"57\":1}}],[\"先创建并启动\",{\"1\":{\"94\":1}}],[\"先确认\",{\"1\":{\"89\":1}}],[\"先判断\",{\"1\":{\"89\":1}}],[\"先通过解码器\",{\"1\":{\"89\":1}}],[\"先尝试主动关闭\",{\"1\":{\"84\":1}}],[\"先根据\",{\"1\":{\"77\":1}}],[\"先来看这个值的初始化\",{\"1\":{\"69\":1}}],[\"先从\",{\"1\":{\"66\":1}}],[\"先对第一个参数\",{\"1\":{\"56\":1}}],[\"先介绍一些它的名词\",{\"1\":{\"44\":1}}],[\"先添加这个\",{\"1\":{\"6\":1}}],[\"尤其是传统机械硬盘上的随机访问是一个非常低效的过程\",{\"1\":{\"110\":1}}],[\"尤其是在消费环节\",{\"1\":{\"44\":1}}],[\"尤其是这项目木有注释\",{\"1\":{\"42\":1}}],[\"面向的场景很多\",{\"1\":{\"44\":1}}],[\"消费端在当前主题的当前队列下的消费进度实际上就是所需\",{\"1\":{\"111\":1}}],[\"消费端可以根据\",{\"1\":{\"111\":1}}],[\"消费端的实现类\",{\"0\":{\"54\":1}}],[\"消费一次\",{\"1\":{\"77\":1}}],[\"消费结果\",{\"1\":{\"59\":1}}],[\"消费中的状态\",{\"1\":{\"57\":1}}],[\"消费进度同步\",{\"0\":{\"72\":1}}],[\"消费进度等信息\",{\"1\":{\"70\":1}}],[\"消费进度\",{\"1\":{\"57\":1,\"111\":1}}],[\"消费的最后一步\",{\"1\":{\"56\":1}}],[\"消费这部分主要关注\",{\"1\":{\"56\":1}}],[\"消费\",{\"1\":{\"55\":1,\"77\":2}}],[\"消费位点部分\",{\"1\":{\"57\":1}}],[\"消费位点要上传\",{\"1\":{\"55\":1}}],[\"消费位点\",{\"0\":{\"51\":1},\"1\":{\"57\":1}}],[\"消费成功\",{\"1\":{\"49\":1}}],[\"消费组的行为并不一致\",{\"1\":{\"77\":1}}],[\"消费组可以订阅多个\",{\"1\":{\"77\":1}}],[\"消费组下的所有\",{\"1\":{\"58\":1}}],[\"消费组由订阅相同\",{\"1\":{\"48\":1}}],[\"消费组\",{\"0\":{\"48\":1},\"1\":{\"70\":1,\"77\":1}}],[\"消费者会再次切换回\",{\"1\":{\"61\":1}}],[\"消费者切换到\",{\"1\":{\"61\":1}}],[\"消费者数发生变化时\",{\"1\":{\"58\":1}}],[\"消费者组订阅\",{\"1\":{\"52\":1}}],[\"消费者\",{\"0\":{\"47\":1}}],[\"消费模式\",{\"0\":{\"46\":1}}],[\"消费消息也是从\",{\"1\":{\"120\":1}}],[\"消费消息是基于消费组\",{\"1\":{\"77\":1}}],[\"消费消息这个行为这一层\",{\"1\":{\"46\":1}}],[\"消费消息\",{\"0\":{\"44\":1},\"1\":{\"77\":1}}],[\"消息结尾位置\",{\"1\":{\"116\":1}}],[\"消息已提交\",{\"1\":{\"116\":1}}],[\"消息已使用的\",{\"1\":{\"112\":1}}],[\"消息格式异常也不会出现在这里\",{\"1\":{\"115\":1}}],[\"消息会顺序写入\",{\"1\":{\"115\":1}}],[\"消息在这个\",{\"1\":{\"116\":1}}],[\"消息在\",{\"1\":{\"112\":1,\"116\":1}}],[\"消息写完\",{\"1\":{\"112\":1}}],[\"消息写入的能力有了\",{\"1\":{\"110\":1}}],[\"消息的\",{\"1\":{\"111\":1,\"112\":1}}],[\"消息的总长度\",{\"1\":{\"111\":1}}],[\"消息本身长度是不可控的\",{\"1\":{\"110\":1}}],[\"消息存储模块的设计概要与分析\",{\"0\":{\"106\":1}}],[\"消息存储的设计\",{\"1\":{\"105\":1}}],[\"消息存储和持久化\",{\"0\":{\"105\":1}}],[\"消息存入的本地\",{\"1\":{\"57\":1}}],[\"消息大小的上限\",{\"1\":{\"96\":1}}],[\"消息轨迹\",{\"1\":{\"73\":1}}],[\"消息确认\",{\"0\":{\"59\":1}}],[\"消息\",{\"1\":{\"56\":1,\"59\":1}}],[\"消息消费就到这里结束啦\",{\"1\":{\"60\":1}}],[\"消息消费的方式类似于\",{\"1\":{\"50\":1}}],[\"消息消费者\",{\"1\":{\"35\":1}}],[\"消息模式为非官方译名\",{\"1\":{\"49\":1}}],[\"消息模式\",{\"0\":{\"49\":1},\"1\":{\"46\":1}}],[\"消息路由信息的生成\",{\"1\":{\"36\":1}}],[\"消息队列\",{\"0\":{\"16\":1}}],[\"对不上的话\",{\"1\":{\"116\":1}}],[\"对应到存储模块的目录结构中\",{\"1\":{\"110\":1}}],[\"对应\",{\"1\":{\"84\":2}}],[\"对应的旧\",{\"1\":{\"89\":1}}],[\"对应的信息\",{\"1\":{\"84\":1}}],[\"对应的\",{\"1\":{\"58\":1,\"84\":1,\"89\":3,\"98\":1}}],[\"对应不同\",{\"1\":{\"55\":1}}],[\"对远程\",{\"1\":{\"58\":1}}],[\"对远程队列上锁\",{\"1\":{\"55\":1}}],[\"对从\",{\"1\":{\"57\":1}}],[\"对象啦\",{\"1\":{\"83\":1}}],[\"对象中并返回\",{\"1\":{\"69\":1}}],[\"对象\",{\"1\":{\"55\":1,\"67\":1,\"89\":1}}],[\"对\",{\"1\":{\"49\":2,\"57\":1,\"67\":1,\"69\":1,\"82\":1,\"114\":1}}],[\"对消息进行持久化\",{\"1\":{\"42\":1}}],[\"对于文件编程\",{\"1\":{\"110\":1}}],[\"对于\",{\"1\":{\"41\":2,\"47\":1}}],[\"对于对\",{\"1\":{\"6\":1}}],[\"会先完成刷盘\",{\"1\":{\"119\":1}}],[\"会根据\",{\"1\":{\"116\":1}}],[\"会\",{\"1\":{\"115\":1}}],[\"会在后面分析具体机制时讲解\",{\"1\":{\"110\":1}}],[\"会被异步转发至\",{\"1\":{\"108\":1}}],[\"会为\",{\"1\":{\"101\":1}}],[\"会默认你的\",{\"1\":{\"98\":1}}],[\"会发生主从交换\",{\"1\":{\"89\":1}}],[\"会每隔10秒扫描一次整个\",{\"1\":{\"89\":1}}],[\"会自动创建一个\",{\"1\":{\"77\":1}}],[\"会自动生成一个目录页面\",{\"1\":{\"11\":1}}],[\"会进入\",{\"1\":{\"115\":1}}],[\"会进入这里\",{\"1\":{\"57\":1}}],[\"会进行不一样的处理\",{\"1\":{\"59\":1}}],[\"会从\",{\"1\":{\"56\":1,\"77\":1}}],[\"会导致消费错乱和消息丢失\",{\"1\":{\"52\":1}}],[\"会把消费位点提交给\",{\"1\":{\"51\":1}}],[\"会调用\",{\"1\":{\"42\":1}}],[\"直接跳过\",{\"1\":{\"116\":1}}],[\"直接看\",{\"1\":{\"115\":1}}],[\"直接去看它的\",{\"1\":{\"65\":1}}],[\"直接拒绝\",{\"1\":{\"42\":1}}],[\"直接在目录页面的\",{\"1\":{\"3\":1}}],[\"未来关于\",{\"1\":{\"73\":1}}],[\"未追平时\",{\"1\":{\"67\":1}}],[\"未能和\",{\"1\":{\"66\":1}}],[\"未被锁住\",{\"1\":{\"56\":1}}],[\"未开启事务处理\",{\"1\":{\"42\":1}}],[\"未分类\",{\"1\":{\"13\":1}}],[\"带这个属性就是事务消息\",{\"1\":{\"42\":1}}],[\"批量其实就是给单次发送的处理流程外面加了层循环\",{\"1\":{\"102\":1}}],[\"批量消息就是数据解码的时候批量解码然后遍历处理\",{\"1\":{\"42\":1}}],[\"批量发送消息\",{\"1\":{\"101\":1}}],[\"批量发送\",{\"1\":{\"41\":1}}],[\"建立\",{\"1\":{\"65\":1}}],[\"建立连接\",{\"1\":{\"65\":1}}],[\"建立链接\",{\"1\":{\"63\":1,\"66\":1}}],[\"建立对应关系\",{\"1\":{\"42\":1}}],[\"建议使用方式\",{\"1\":{\"2\":1}}],[\"那说明有新的\",{\"1\":{\"89\":1}}],[\"那样\",{\"1\":{\"89\":1}}],[\"那它就是主broker\",{\"1\":{\"88\":1}}],[\"那个方法会从\",{\"1\":{\"119\":1}}],[\"那个\",{\"1\":{\"84\":1,\"102\":1}}],[\"那就注册到所有到\",{\"1\":{\"80\":1}}],[\"那就是为消费端提供高效的根据\",{\"1\":{\"111\":1}}],[\"那就是\",{\"1\":{\"67\":1}}],[\"那么先写空结点占位\",{\"1\":{\"116\":1}}],[\"那么我们去\",{\"1\":{\"69\":1}}],[\"那么大概率他是要在某个数据表里作为\",{\"1\":{\"57\":1}}],[\"那么\",{\"1\":{\"56\":1,\"69\":1,\"111\":1}}],[\"那么创建\",{\"1\":{\"55\":1}}],[\"那么还会启动\",{\"1\":{\"55\":1}}],[\"那么回顾发送消息的底层代码\",{\"1\":{\"41\":1}}],[\"那一步中包含\",{\"1\":{\"42\":1}}],[\"办法很多\",{\"1\":{\"41\":1}}],[\"到此\",{\"1\":{\"101\":1}}],[\"到\",{\"1\":{\"65\":1,\"66\":1,\"116\":1}}],[\"到队列中\",{\"1\":{\"57\":1}}],[\"到这里启动就完成了\",{\"1\":{\"55\":1}}],[\"到这一步就随你喜好了\",{\"1\":{\"41\":1}}],[\"到期就给你自动失灵\",{\"1\":{\"3\":1}}],[\"里很多处理逻辑跟\",{\"1\":{\"116\":1}}],[\"里的请求全部执行完后\",{\"1\":{\"115\":1}}],[\"里读取刷盘请求\",{\"1\":{\"115\":1}}],[\"里读取了\",{\"1\":{\"115\":1}}],[\"里维护了两个\",{\"1\":{\"115\":1}}],[\"里\",{\"1\":{\"115\":1}}],[\"里取消息了\",{\"1\":{\"112\":1}}],[\"里链表的尾指针就好\",{\"1\":{\"112\":1}}],[\"里就能看到熟悉的\",{\"1\":{\"103\":1}}],[\"里添加一组\",{\"1\":{\"102\":1}}],[\"里完成的\",{\"1\":{\"101\":1}}],[\"里保存了\",{\"1\":{\"101\":1}}],[\"里提过\",{\"1\":{\"96\":1}}],[\"里连\",{\"1\":{\"89\":1}}],[\"里存的是\",{\"1\":{\"84\":1}}],[\"里会先创建一个\",{\"1\":{\"83\":1}}],[\"里会定义\",{\"1\":{\"41\":1}}],[\"里一个个取\",{\"1\":{\"60\":1}}],[\"里面有一部分属性是有英文注释\",{\"1\":{\"115\":1}}],[\"里面有同步刷盘\",{\"1\":{\"115\":1}}],[\"里面应用了一个读写分离的小技巧\",{\"1\":{\"115\":1}}],[\"里面一样\",{\"1\":{\"112\":1}}],[\"里面的数据是\",{\"1\":{\"112\":1}}],[\"里面提过\",{\"1\":{\"103\":1}}],[\"里面那行校验是一样的是\",{\"1\":{\"101\":1}}],[\"里面那样直接调用\",{\"1\":{\"84\":1}}],[\"里面塞消息\",{\"1\":{\"91\":1}}],[\"里面先自定义一个协议\",{\"1\":{\"89\":1}}],[\"里面存储的都是加密\",{\"1\":{\"67\":1}}],[\"里面\",{\"1\":{\"56\":1}}],[\"里面混杂了一部分内部消息对象的组装\",{\"1\":{\"42\":1}}],[\"里面我们了解了消息是如何发给\",{\"1\":{\"41\":1}}],[\"里找\",{\"1\":{\"41\":1}}],[\"再下面一层就是\",{\"1\":{\"103\":1}}],[\"再下一层的代码不明白的可以去看一眼\",{\"1\":{\"101\":1}}],[\"再回来看毕竟好懂\",{\"1\":{\"101\":1}}],[\"再次去\",{\"1\":{\"103\":1}}],[\"再次判断是否为首次注册\",{\"1\":{\"89\":1}}],[\"再次\",{\"1\":{\"56\":1}}],[\"再比如\",{\"1\":{\"41\":1,\"116\":1}}],[\"再结合大家都基于\",{\"1\":{\"41\":1}}],[\"习惯把\",{\"1\":{\"41\":1}}],[\"之间通过\",{\"1\":{\"87\":1}}],[\"之间并不会相互通信\",{\"1\":{\"81\":1}}],[\"之间保持长连接\",{\"1\":{\"80\":1}}],[\"之间传递消息有两种方式\",{\"1\":{\"77\":1}}],[\"之间不进行通信\",{\"1\":{\"76\":1}}],[\"之前的消息绝对有效\",{\"1\":{\"119\":1}}],[\"之前不建议使用分布式\",{\"1\":{\"115\":1}}],[\"之前说了写入方式就是顺序写入\",{\"1\":{\"110\":1}}],[\"之前\",{\"1\":{\"41\":1,\"103\":2}}],[\"之后再异步刷盘\",{\"1\":{\"120\":1}}],[\"之后定长计算得到\",{\"1\":{\"112\":1}}],[\"之后会结合源码来详解具体机制的实现\",{\"1\":{\"105\":1}}],[\"之后\",{\"1\":{\"103\":1}}],[\"之后累加计算所有\",{\"1\":{\"102\":1}}],[\"之后的\",{\"1\":{\"102\":1}}],[\"之后批量\",{\"1\":{\"102\":1}}],[\"之后一秒执行一次\",{\"1\":{\"98\":1}}],[\"之后消费环节的\",{\"1\":{\"98\":1}}],[\"之后代码运行到这里就抛异常了\",{\"1\":{\"98\":1}}],[\"之后接下来就启动它\",{\"1\":{\"83\":1}}],[\"之后以同步\",{\"1\":{\"76\":1}}],[\"之后在\",{\"1\":{\"69\":1}}],[\"之后就是\",{\"1\":{\"55\":1}}],[\"之后刷盘\",{\"1\":{\"42\":1}}],[\"之后则是通用处理\",{\"1\":{\"40\":1}}],[\"之后直接开始强制同步到从库\",{\"1\":{\"21\":1}}],[\"后会转发给\",{\"1\":{\"116\":1}}],[\"后会转发\",{\"1\":{\"112\":1}}],[\"后简称p\",{\"1\":{\"81\":1}}],[\"后续在消息消费章节再进行说明\",{\"1\":{\"121\":1}}],[\"后续中展开细说\",{\"1\":{\"77\":1}}],[\"后续会重新调整一下\",{\"1\":{\"73\":1}}],[\"后的数据\",{\"1\":{\"67\":1}}],[\"后重试\",{\"1\":{\"66\":1}}],[\"后重新提交一个\",{\"1\":{\"56\":2}}],[\"后面流程就跟正常恢复一样了\",{\"1\":{\"119\":1}}],[\"后面的对象就是任务\",{\"1\":{\"116\":1}}],[\"后面的篇幅会进一步省略一些与主线逻辑关系不大的代码片段\",{\"1\":{\"104\":1}}],[\"后面再详细说明\",{\"1\":{\"115\":1}}],[\"后面再说\",{\"1\":{\"55\":1}}],[\"后面提到的\",{\"1\":{\"112\":1}}],[\"后面就叫他存储模块\",{\"1\":{\"108\":1}}],[\"后面都是异常的处理啥的\",{\"1\":{\"101\":1}}],[\"后面看\",{\"1\":{\"101\":1}}],[\"后面细说\",{\"1\":{\"96\":1}}],[\"后面还要根据这个标记来判断是否要删除对应的\",{\"1\":{\"84\":1}}],[\"后面要用\",{\"1\":{\"84\":1}}],[\"后面全部略\",{\"1\":{\"56\":1}}],[\"后面单独来看这俩\",{\"1\":{\"55\":1}}],[\"后面单独去讲\",{\"1\":{\"43\":1}}],[\"后\",{\"1\":{\"41\":1,\"108\":1,\"111\":1,\"112\":1}}],[\"后启动\",{\"1\":{\"39\":1}}],[\"需要注意的是\",{\"1\":{\"111\":1}}],[\"需要创建\",{\"1\":{\"89\":1}}],[\"需要计算几次就迭代几次\",{\"1\":{\"57\":1}}],[\"需要接收两个队列作为参数\",{\"1\":{\"56\":1}}],[\"需要被消费组内所有\",{\"1\":{\"49\":1}}],[\"需要返回值的发送\",{\"1\":{\"41\":1}}],[\"需要的时候记得去开就好\",{\"1\":{\"4\":1}}],[\"自身的需求实现\",{\"1\":{\"98\":1}}],[\"自身也是一个服务线程\",{\"1\":{\"57\":1}}],[\"自然要有单独的逻辑\",{\"1\":{\"117\":1}}],[\"自然秒懂\",{\"1\":{\"89\":1}}],[\"自然属于数据输入\",{\"1\":{\"41\":1}}],[\"自己去\",{\"1\":{\"77\":1}}],[\"自定义的请求协议封装好\",{\"1\":{\"59\":1}}],[\"自行保存\",{\"1\":{\"51\":1}}],[\"自动删除\",{\"1\":{\"90\":1}}],[\"自动创建\",{\"1\":{\"115\":1}}],[\"自动创建主题机制就是如果启用了该机制\",{\"1\":{\"77\":1}}],[\"自动创建readme\",{\"1\":{\"11\":1}}],[\"自动同步元数据\",{\"0\":{\"71\":1}}],[\"自动侧边栏显示文件路径而非\",{\"1\":{\"3\":1}}],[\"定长\",{\"1\":{\"111\":1}}],[\"定位文件\",{\"1\":{\"116\":1}}],[\"定位到文件后只需要msg\",{\"1\":{\"110\":1}}],[\"定位消息在文件中的具体位置\",{\"1\":{\"108\":1}}],[\"定位代码\",{\"1\":{\"41\":1}}],[\"定时任务的\",{\"1\":{\"103\":1}}],[\"定义的监控去调用\",{\"1\":{\"84\":1}}],[\"定义的\",{\"1\":{\"84\":1}}],[\"定义了一个异步任务执行框架\",{\"1\":{\"30\":1}}],[\"涉及持久化的部分略过\",{\"1\":{\"41\":1}}],[\"因为有前一个参数在\",{\"1\":{\"115\":1}}],[\"因为是记录时间戳\",{\"1\":{\"113\":1}}],[\"因为消息只写不删\",{\"1\":{\"110\":1}}],[\"因为磁盘寻道更少\",{\"1\":{\"110\":1}}],[\"因为他要给\",{\"1\":{\"90\":1}}],[\"因为这部分是顺序写\",{\"1\":{\"112\":1}}],[\"因为这时候\",{\"1\":{\"89\":1}}],[\"因为这里\",{\"1\":{\"26\":1}}],[\"因为当\",{\"1\":{\"89\":1}}],[\"因为\",{\"1\":{\"46\":1,\"116\":1}}],[\"因此恢复时基本以\",{\"1\":{\"119\":1}}],[\"因此对于普通硬盘而言连续\",{\"1\":{\"110\":1}}],[\"因此处理逻辑只需要先删除掉原来的\",{\"1\":{\"89\":1}}],[\"因此要区分不同\",{\"1\":{\"89\":1}}],[\"因此要在\",{\"1\":{\"67\":1}}],[\"因此会有短暂的路由信息不一致\",{\"1\":{\"81\":1}}],[\"因此还有另外一种方式\",{\"1\":{\"72\":1}}],[\"因此都略过啦\",{\"1\":{\"66\":1}}],[\"因此也可以认为是\",{\"1\":{\"57\":1}}],[\"因此我们去找\",{\"1\":{\"41\":1}}],[\"因此\",{\"1\":{\"40\":1,\"110\":1,\"111\":1}}],[\"上篇中我们提到了接收消息时会发起异步调用进行刷盘\",{\"1\":{\"115\":1}}],[\"上次收到心跳包的时间\",{\"1\":{\"84\":2}}],[\"上同步路由信息\",{\"1\":{\"76\":1}}],[\"上同步的\",{\"1\":{\"67\":1}}],[\"上新消息的起始位置\",{\"1\":{\"67\":1}}],[\"上报\",{\"1\":{\"66\":1}}],[\"上的积压消息小于\",{\"1\":{\"61\":1}}],[\"上进行消费\",{\"1\":{\"61\":1,\"70\":1}}],[\"上都是一致的\",{\"1\":{\"58\":1}}],[\"上锁\",{\"1\":{\"56\":2,\"58\":1}}],[\"上拉数据\",{\"1\":{\"103\":1}}],[\"上拉取消息\",{\"1\":{\"61\":1}}],[\"上拉回来的消息进行解码过滤等处理\",{\"1\":{\"57\":1}}],[\"上拉消息回来\",{\"1\":{\"57\":1}}],[\"上拉\",{\"1\":{\"55\":1}}],[\"上把消息拉回本地再进行处理\",{\"1\":{\"55\":1}}],[\"上\",{\"1\":{\"40\":1,\"80\":1}}],[\"上数据变化会写入二进制文件\",{\"1\":{\"19\":1}}],[\"如下\",{\"1\":{\"69\":1}}],[\"如何封装\",{\"1\":{\"103\":1}}],[\"如何生成\",{\"1\":{\"69\":1}}],[\"如何找到具体的\",{\"1\":{\"69\":1}}],[\"如何注册的坑就填完了\",{\"1\":{\"40\":1}}],[\"如果大于\",{\"1\":{\"119\":1}}],[\"如果大于0了自然就是等会儿再去拉取\",{\"1\":{\"57\":1}}],[\"如果这个存储时间小于\",{\"1\":{\"119\":1}}],[\"如果还是没有刷盘任务\",{\"1\":{\"115\":1}}],[\"如果还是对\",{\"1\":{\"25\":1}}],[\"如果发起注册请求的\",{\"1\":{\"89\":1}}],[\"如果发现过期的\",{\"1\":{\"84\":1}}],[\"如果不存在则创建\",{\"1\":{\"89\":1}}],[\"如果不存在就添加集群\",{\"1\":{\"89\":1}}],[\"如果不成功\",{\"1\":{\"56\":1}}],[\"如果任意\",{\"1\":{\"89\":1}}],[\"如果一个消息来写\",{\"1\":{\"110\":1}}],[\"如果一个\",{\"1\":{\"88\":1}}],[\"如果实际场景有要求\",{\"1\":{\"81\":1}}],[\"如果没查到\",{\"1\":{\"77\":1}}],[\"如果其中包含的消费进度的信息\",{\"1\":{\"72\":1}}],[\"如果有其他逻辑则执行\",{\"1\":{\"68\":1}}],[\"如果前面哪个循环中没有追平\",{\"1\":{\"67\":1}}],[\"如果你配置多个\",{\"1\":{\"65\":1}}],[\"如果你的\",{\"1\":{\"55\":1}}],[\"如果正常会后面会设置为\",{\"1\":{\"57\":1}}],[\"如果\",{\"1\":{\"56\":1,\"98\":1,\"103\":1}}],[\"如果成功\",{\"1\":{\"56\":1}}],[\"如果开启消息追踪\",{\"1\":{\"55\":1}}],[\"如果开启了\",{\"1\":{\"40\":1}}],[\"如果订阅关系不一致\",{\"1\":{\"52\":1}}],[\"如果是集群模式\",{\"1\":{\"56\":1}}],[\"如果是广播模式\",{\"1\":{\"56\":1}}],[\"如果是\",{\"1\":{\"11\":1,\"55\":1,\"57\":1,\"80\":1}}],[\"则寻找上一个文件\",{\"1\":{\"119\":1}}],[\"则继续停\",{\"1\":{\"115\":1}}],[\"则创建新文件\",{\"1\":{\"115\":1}}],[\"则通过\",{\"1\":{\"108\":1}}],[\"则直接返回\",{\"1\":{\"103\":1}}],[\"则直接使用\",{\"1\":{\"84\":1}}],[\"则为主节点\",{\"1\":{\"87\":1}}],[\"则删除\",{\"1\":{\"84\":1}}],[\"则是为快速检索\",{\"1\":{\"108\":1}}],[\"则是定期上报各种路由信息给\",{\"1\":{\"76\":1}}],[\"则是对拉回来的消息进行处理\",{\"1\":{\"57\":1}}],[\"则返回\",{\"1\":{\"67\":1}}],[\"则认为链接无效\",{\"1\":{\"66\":1}}],[\"则尝试与\",{\"1\":{\"65\":1}}],[\"则尝试重新上锁并重新消费\",{\"1\":{\"56\":1}}],[\"则不会执行\",{\"1\":{\"57\":1}}],[\"则\",{\"1\":{\"56\":2,\"66\":1,\"115\":1}}],[\"则开始进行循环\",{\"1\":{\"56\":1}}],[\"则取出返回结果列表中第一条数据进行高可用模式的后续处理\",{\"1\":{\"40\":1}}],[\"则生成\",{\"1\":{\"11\":1}}],[\"请求类型\",{\"1\":{\"89\":1}}],[\"请求类型为\",{\"1\":{\"40\":1}}],[\"请求行为会直接放弃\",{\"1\":{\"68\":1}}],[\"请求码为\",{\"1\":{\"59\":1}}],[\"请求前\",{\"1\":{\"57\":1}}],[\"请求的队列\",{\"1\":{\"57\":1}}],[\"请求的方法\",{\"1\":{\"57\":1}}],[\"请求\",{\"1\":{\"50\":1,\"56\":2,\"72\":1,\"89\":3}}],[\"请重新阅读之前关于\",{\"1\":{\"25\":1}}],[\"信息发生变化\",{\"1\":{\"89\":1}}],[\"信息\",{\"0\":{\"89\":1,\"90\":1},\"1\":{\"84\":2,\"89\":2,\"100\":1}}],[\"信息的\",{\"1\":{\"84\":1}}],[\"信息同时注册到所有\",{\"1\":{\"40\":1}}],[\"信息装入\",{\"1\":{\"40\":1}}],[\"信号量\",{\"1\":{\"23\":1}}],[\"首个的消息在\",{\"1\":{\"112\":1}}],[\"首个消息\",{\"1\":{\"112\":1}}],[\"首次注册\",{\"1\":{\"89\":1}}],[\"首次\",{\"1\":{\"57\":1}}],[\"首先单个文件大小固定\",{\"1\":{\"110\":1}}],[\"首先内存编程直接操作内存非常简单\",{\"1\":{\"108\":1}}],[\"首先对\",{\"1\":{\"102\":1}}],[\"首先这里的入参不用管\",{\"1\":{\"89\":1}}],[\"首先来看\",{\"1\":{\"69\":1}}],[\"首先是它内部创建了俩队列\",{\"1\":{\"67\":1}}],[\"首先是\",{\"1\":{\"64\":1,\"67\":1}}],[\"首先检查\",{\"1\":{\"56\":1,\"115\":1}}],[\"首先他要对\",{\"1\":{\"41\":1}}],[\"首先会判断是否为高可用模式\",{\"1\":{\"40\":1}}],[\"首先组装\",{\"1\":{\"40\":1}}],[\"首页设计\",{\"1\":{\"3\":1}}],[\"向前面应该有数据的空的cq结点中写入\",{\"1\":{\"116\":1}}],[\"向上追踪了\",{\"1\":{\"56\":1}}],[\"向\",{\"1\":{\"40\":2,\"63\":1,\"66\":1,\"68\":1,\"71\":1,\"77\":1,\"84\":1}}],[\"发消息时的整个路由流程\",{\"1\":{\"101\":1}}],[\"发出注销请求\",{\"1\":{\"90\":1}}],[\"发来心跳包的时间戳\",{\"1\":{\"89\":1}}],[\"发来的注册请求\",{\"1\":{\"89\":1}}],[\"发来的心跳包\",{\"1\":{\"90\":1}}],[\"发来的心跳包后都会根据\",{\"1\":{\"88\":1}}],[\"发来的心跳包就认为这个\",{\"1\":{\"84\":1}}],[\"发来的\",{\"1\":{\"72\":1}}],[\"发布机制\",{\"1\":{\"87\":1}}],[\"发布消息\",{\"1\":{\"77\":1}}],[\"发一次心跳包\",{\"1\":{\"84\":1}}],[\"发生在\",{\"1\":{\"67\":1}}],[\"发请求\",{\"1\":{\"59\":1}}],[\"发起拉消息的请求\",{\"1\":{\"57\":1}}],[\"发起拉取消息请求\",{\"1\":{\"57\":1}}],[\"发起异步请求成功时用的\",{\"1\":{\"57\":1}}],[\"发送次数\",{\"1\":{\"101\":1}}],[\"发送首次心跳请求\",{\"1\":{\"98\":1}}],[\"发送心跳包\",{\"1\":{\"89\":1}}],[\"发送拉取消息的请求\",{\"1\":{\"77\":1}}],[\"发送\",{\"1\":{\"75\":1}}],[\"发送待拉取消息的\",{\"1\":{\"63\":1}}],[\"发送请求的\",{\"1\":{\"89\":1}}],[\"发送请求\",{\"1\":{\"59\":1}}],[\"发送远程请求\",{\"1\":{\"55\":1}}],[\"发送消息背后的整体逻辑和流程\",{\"1\":{\"104\":1}}],[\"发送消息这里还有一个可以看一下\",{\"1\":{\"101\":1}}],[\"发送消息支持三种模式\",{\"1\":{\"101\":1}}],[\"发送消息支持三种方式\",{\"1\":{\"91\":1}}],[\"发送消息并拿到返回结果\",{\"1\":{\"101\":1}}],[\"发送消息失败会重试两次\",{\"1\":{\"96\":1}}],[\"发送消息的各种细节\",{\"1\":{\"91\":1}}],[\"发送消息时会根据这个表进行负载均衡\",{\"1\":{\"88\":1}}],[\"发送消息时会去\",{\"1\":{\"80\":1}}],[\"发送消息\",{\"0\":{\"91\":1},\"1\":{\"42\":1,\"77\":2,\"80\":1,\"94\":1}}],[\"发注册请求\",{\"1\":{\"39\":1,\"40\":1}}],[\"发现\",{\"1\":{\"13\":1}}],[\"给看不懂的小伙伴简单解释下\",{\"1\":{\"67\":1}}],[\"给外部包装类初始化\",{\"1\":{\"55\":1}}],[\"给\",{\"1\":{\"39\":1,\"59\":1}}],[\"单个\",{\"1\":{\"111\":1}}],[\"单向发送不需要返回结果\",{\"1\":{\"101\":1}}],[\"单向自然就是一次\",{\"1\":{\"101\":1}}],[\"单向由该参数决定\",{\"1\":{\"101\":1}}],[\"单向则不关心结果\",{\"1\":{\"94\":1}}],[\"单向\",{\"1\":{\"91\":1,\"101\":1}}],[\"单线程\",{\"1\":{\"55\":2,\"57\":1}}],[\"单线程定时任务\",{\"1\":{\"39\":2}}],[\"单独发布到子域名下\",{\"1\":{\"1\":1}}],[\"绑定的\",{\"1\":{\"39\":1}}],[\"==\",{\"1\":{\"55\":2,\"56\":1,\"57\":9,\"58\":2,\"65\":1,\"69\":2,\"71\":1,\"84\":3,\"89\":6,\"101\":2,\"103\":1,\"115\":5,\"116\":2}}],[\"=\",{\"1\":{\"39\":10,\"42\":3,\"55\":15,\"56\":8,\"57\":39,\"58\":18,\"64\":1,\"65\":9,\"66\":3,\"67\":8,\"69\":7,\"71\":3,\"83\":1,\"84\":34,\"87\":1,\"89\":34,\"94\":4,\"96\":13,\"97\":1,\"98\":5,\"101\":37,\"102\":6,\"103\":27,\"110\":1,\"112\":4,\"115\":18,\"116\":15,\"119\":5}}],[\"接下来要找到需要的\",{\"1\":{\"111\":1}}],[\"接下来详细介绍一下这三种文件的具体信息\",{\"1\":{\"108\":1}}],[\"接下来进入\",{\"1\":{\"94\":1,\"97\":1}}],[\"接下来分别看一下这五个数据表\",{\"1\":{\"87\":1}}],[\"接下来我们来看看\",{\"1\":{\"103\":1}}],[\"接下来我们来看\",{\"1\":{\"99\":1}}],[\"接下来我们就根据这个流程来看\",{\"1\":{\"63\":1}}],[\"接下来我们会回到\",{\"1\":{\"60\":1}}],[\"接下来我们要来看消息是怎么从\",{\"1\":{\"56\":1}}],[\"接下来看代码\",{\"1\":{\"62\":1}}],[\"接下来看\",{\"1\":{\"39\":1}}],[\"接收到的是生产者的请求还是消费者的请求\",{\"1\":{\"42\":1}}],[\"接收到\",{\"1\":{\"41\":1}}],[\"接收客户端发来的消息\",{\"1\":{\"41\":1}}],[\"接收消息\",{\"0\":{\"41\":1}}],[\"接口进一步扩展出了延迟任务和周期任务的执行\",{\"1\":{\"30\":1}}],[\"接口\",{\"1\":{\"30\":1}}],[\"项目里\",{\"1\":{\"41\":1}}],[\"项目找启动类最偷懒的办法就是搜索\",{\"1\":{\"38\":1}}],[\"项目无法正常\",{\"1\":{\"6\":1}}],[\"知道大体逻辑就好了\",{\"1\":{\"119\":1}}],[\"知道它包含持久化功能\",{\"1\":{\"37\":1}}],[\"知识库内容\",{\"0\":{\"13\":1}}],[\"我忘记保存了\",{\"1\":{\"107\":1}}],[\"我这里改成了\",{\"1\":{\"84\":1}}],[\"我们不难发现该文件的设计核心就是在强调写入效率的最大化\",{\"1\":{\"110\":1}}],[\"我们这里要关注的是\",{\"1\":{\"89\":1}}],[\"我们要找到俩方法都在这里了\",{\"1\":{\"69\":1}}],[\"我们挨个来看\",{\"1\":{\"67\":1}}],[\"我们就不从\",{\"1\":{\"56\":1}}],[\"我们来看线程池要执行的任务\",{\"1\":{\"56\":1}}],[\"我们从\",{\"1\":{\"54\":1}}],[\"我们接着往下看最后的返回\",{\"1\":{\"42\":1}}],[\"我们可以对存储模块有个大致的认识\",{\"1\":{\"108\":1}}],[\"我们可以轻松发现这里的数据输入基本就是三种\",{\"1\":{\"41\":1}}],[\"我们可以知道\",{\"1\":{\"37\":1}}],[\"我自己打开开发者工具也没找到\",{\"1\":{\"3\":1}}],[\"懒得一个个点开看\",{\"1\":{\"37\":1}}],[\"注销\",{\"0\":{\"90\":1},\"1\":{\"90\":1}}],[\"注意该方法已标记\",{\"1\":{\"119\":1}}],[\"注意前面是循环写\",{\"1\":{\"116\":1}}],[\"注意跟线程间隔区分\",{\"1\":{\"115\":1}}],[\"注意跟后面的\",{\"1\":{\"46\":1,\"102\":1}}],[\"注意同名方法\",{\"1\":{\"115\":1}}],[\"注意哈希冲突\",{\"1\":{\"111\":1}}],[\"注意这里说的客户端\",{\"1\":{\"98\":1}}],[\"注意这里的\",{\"1\":{\"84\":1}}],[\"注意这里都是\",{\"1\":{\"58\":1}}],[\"注意\",{\"1\":{\"56\":1,\"64\":1,\"65\":1,\"81\":1}}],[\"注册的思路在\",{\"1\":{\"90\":1}}],[\"注册进来\",{\"1\":{\"89\":1}}],[\"注册过程中\",{\"1\":{\"89\":1}}],[\"注册中心\",{\"1\":{\"76\":1}}],[\"注册\",{\"0\":{\"89\":1},\"1\":{\"65\":1}}],[\"注册并实现的\",{\"1\":{\"56\":1}}],[\"注册失败直接关闭\",{\"1\":{\"55\":1}}],[\"注册路由信息\",{\"1\":{\"40\":1}}],[\"注册到其内部维护的\",{\"1\":{\"98\":1}}],[\"注册到\",{\"0\":{\"40\":1},\"1\":{\"55\":1,\"84\":1,\"98\":1}}],[\"注\",{\"1\":{\"37\":1,\"41\":1,\"46\":1,\"70\":1,\"79\":1,\"81\":1,\"84\":1,\"87\":1,\"89\":1}}],[\"注解\",{\"1\":{\"13\":1}}],[\"记不住就分别写上注释\",{\"1\":{\"37\":1}}],[\"让读者对\",{\"1\":{\"35\":1}}],[\"持久化消费位点的流程处理消息\",{\"1\":{\"58\":1}}],[\"持久化涉及到从文件系统恢复消息和消息写入文件系统等\",{\"1\":{\"39\":1}}],[\"持久化\",{\"1\":{\"35\":1,\"36\":1}}],[\"作为一款分布式\",{\"1\":{\"108\":1}}],[\"作为数据库并开启持久化\",{\"1\":{\"107\":1}}],[\"作为消息队列的核心\",{\"1\":{\"35\":1}}],[\"作为标题\",{\"1\":{\"11\":1}}],[\"源码\",{\"1\":{\"113\":1}}],[\"源码注释里写了\",{\"1\":{\"96\":1}}],[\"源码中这部分是有注释的\",{\"1\":{\"96\":1}}],[\"源码里也就这么一处是直接调用\",{\"1\":{\"84\":1}}],[\"源码位置\",{\"1\":{\"62\":1,\"110\":1,\"111\":1,\"112\":1,\"115\":1,\"116\":1}}],[\"源码略过\",{\"1\":{\"40\":1}}],[\"源码分析\",{\"0\":{\"35\":1,\"44\":1,\"53\":1,\"61\":1,\"74\":1,\"79\":1,\"82\":1,\"91\":1,\"93\":1,\"105\":1}}],[\"源码库\",{\"1\":{\"5\":1}}],[\"具体细节在后面会详细展开\",{\"1\":{\"110\":2}}],[\"具体细节下面展开说\",{\"1\":{\"102\":1}}],[\"具体同步哪些数据可以可根据代码自行查看\",{\"1\":{\"71\":1}}],[\"具体点说就是\",{\"1\":{\"66\":1}}],[\"具体来说就是\",{\"1\":{\"59\":1}}],[\"具体实现\",{\"0\":{\"31\":1}}],[\"具体的key值\",{\"1\":{\"102\":1}}],[\"具体的说是更新上一次收到该\",{\"1\":{\"89\":1}}],[\"具体的\",{\"1\":{\"30\":1}}],[\"更新完本地路由信息表后重新取出\",{\"1\":{\"103\":1}}],[\"更新本地路由信息表以及一系列相关信息\",{\"1\":{\"103\":1}}],[\"更新与该\",{\"1\":{\"90\":1}}],[\"更新该\",{\"1\":{\"89\":1}}],[\"更新\",{\"0\":{\"89\":1},\"1\":{\"57\":1,\"66\":1,\"67\":2,\"89\":1,\"103\":1}}],[\"更新路由信息\",{\"1\":{\"55\":1}}],[\"更新为\",{\"1\":{\"40\":1}}],[\"更新计划列表\",{\"0\":{\"12\":1}}],[\"更进一步\",{\"1\":{\"30\":1}}],[\"顺便补充一些背景知识方便读者理解机制的实现\",{\"1\":{\"105\":1}}],[\"顺便自行探索为什么文档和最佳实践都建议消费者数量要比队列数量少\",{\"1\":{\"58\":1}}],[\"顺便同步维护\",{\"1\":{\"57\":1}}],[\"顺便提一句\",{\"1\":{\"57\":1}}],[\"顺便加入一些操作系统的知识点\",{\"1\":{\"13\":1}}],[\"顺便加一篇前置内容\",{\"1\":{\"13\":1}}],[\"顺带打印\",{\"1\":{\"55\":1}}],[\"顺序读写\",{\"1\":{\"110\":1}}],[\"顺序消费是\",{\"1\":{\"55\":1}}],[\"顺序消费是在同一个队列上有序\",{\"1\":{\"46\":1}}],[\"顺序消费仅适用于集群模式\",{\"1\":{\"46\":1}}],[\"顺序消费\",{\"1\":{\"46\":1,\"55\":1,\"56\":1,\"57\":2}}],[\"顺序执行\",{\"1\":{\"30\":1}}],[\"方法去写文件\",{\"1\":{\"116\":1}}],[\"方法即可\",{\"1\":{\"115\":1}}],[\"方法返回的是所有\",{\"1\":{\"112\":1}}],[\"方法继续往下看\",{\"1\":{\"103\":1}}],[\"方法就是遍历前面的任务列表\",{\"1\":{\"116\":1}}],[\"方法就是\",{\"1\":{\"101\":1}}],[\"方法就是把刚创建的这个\",{\"1\":{\"98\":1}}],[\"方法就是给客户端返回响应的方法\",{\"1\":{\"42\":1}}],[\"方法加个\",{\"1\":{\"84\":1}}],[\"方法的逻辑就是把所有\",{\"1\":{\"102\":1}}],[\"方法的逻辑是\",{\"1\":{\"98\":1}}],[\"方法的功能就是根据\",{\"1\":{\"69\":1}}],[\"方法的入参\",{\"1\":{\"68\":1}}],[\"方法的调用\",{\"1\":{\"56\":1,\"103\":1}}],[\"方法为例\",{\"1\":{\"67\":1}}],[\"方法逻辑为每\",{\"1\":{\"67\":1}}],[\"方法处理请求\",{\"1\":{\"57\":1}}],[\"方法外\",{\"1\":{\"56\":1}}],[\"方法里面通过\",{\"1\":{\"89\":1}}],[\"方法里\",{\"1\":{\"55\":1,\"64\":1}}],[\"方法比较长\",{\"1\":{\"42\":1}}],[\"方法中就可以看出来\",{\"1\":{\"56\":1}}],[\"方法中\",{\"1\":{\"42\":1}}],[\"方法\",{\"1\":{\"30\":1,\"38\":1,\"39\":1,\"42\":1,\"55\":1,\"56\":1,\"57\":3,\"59\":1,\"65\":1,\"66\":1,\"67\":3,\"69\":1,\"71\":1,\"89\":1,\"94\":1,\"101\":2,\"103\":2,\"116\":2}}],[\"方法论\",{\"1\":{\"13\":1}}],[\"实例\",{\"1\":{\"98\":1}}],[\"实际代码中的交换流程好像是直接\",{\"1\":{\"115\":1}}],[\"实际调用的是\",{\"1\":{\"115\":1}}],[\"实际它是\",{\"1\":{\"110\":1}}],[\"实际就是检查\",{\"1\":{\"98\":1}}],[\"实际就是启动一个\",{\"1\":{\"83\":1}}],[\"实际实现启动的是\",{\"1\":{\"97\":1}}],[\"实际实现方式是\",{\"1\":{\"58\":1}}],[\"实际值算出来也是\",{\"1\":{\"64\":1}}],[\"实际处理\",{\"1\":{\"57\":1}}],[\"实际上它突然加个\",{\"1\":{\"116\":1}}],[\"实际上有\",{\"1\":{\"116\":1}}],[\"实际上就三种状态\",{\"1\":{\"115\":1}}],[\"实际上就是一个\",{\"1\":{\"112\":1}}],[\"实际上就是说每个\",{\"1\":{\"110\":1}}],[\"实际上就是创建了一个自定义的\",{\"1\":{\"98\":1}}],[\"实际上就是把\",{\"1\":{\"42\":1,\"57\":1}}],[\"实际上是有的\",{\"1\":{\"116\":1}}],[\"实际上是\",{\"1\":{\"112\":1}}],[\"实际上你想想看就知道\",{\"1\":{\"110\":1}}],[\"实际上交换不太准确\",{\"1\":{\"89\":1}}],[\"实际上前面几篇中\",{\"1\":{\"67\":1}}],[\"实际上也并不会真正对请求进行处理\",{\"1\":{\"57\":1}}],[\"实际上真正去存放消息的是\",{\"1\":{\"42\":1}}],[\"实际上\",{\"1\":{\"41\":1,\"58\":1,\"112\":1}}],[\"实现方式就是通过定时任务\",{\"1\":{\"71\":1}}],[\"实现方案通常为主从机制\",{\"1\":{\"61\":1}}],[\"实现的\",{\"1\":{\"66\":1}}],[\"实现\",{\"1\":{\"60\":1}}],[\"实现类有两个\",{\"1\":{\"55\":1}}],[\"实现类\",{\"1\":{\"55\":1,\"58\":1}}],[\"实现可以是正在创建\",{\"1\":{\"30\":1}}],[\"实践\",{\"1\":{\"13\":1}}],[\"异步刷盘\",{\"1\":{\"115\":1}}],[\"异步调用\",{\"1\":{\"115\":1}}],[\"异步发送时用的\",{\"1\":{\"103\":1}}],[\"异步获取结果是利用\",{\"1\":{\"101\":1}}],[\"异步其实是可以重试的\",{\"1\":{\"101\":1}}],[\"异步消息失败的重试机制可能会造成消息重复发送\",{\"1\":{\"96\":1}}],[\"异步则是通过\",{\"1\":{\"94\":1}}],[\"异步的方式刷盘写入\",{\"1\":{\"76\":1}}],[\"异步\",{\"1\":{\"30\":1,\"41\":1,\"91\":1,\"101\":2,\"103\":1,\"115\":1}}],[\"异步io\",{\"1\":{\"30\":1}}],[\"异常关闭则进入\",{\"1\":{\"119\":1}}],[\"异常退出\",{\"1\":{\"119\":1}}],[\"异常时会为\",{\"1\":{\"57\":1}}],[\"异常\",{\"1\":{\"13\":1,\"57\":1}}],[\"详细说明可以看它的注释\",{\"1\":{\"67\":1}}],[\"详见\",{\"1\":{\"119\":1}}],[\"详见持久化篇\",{\"1\":{\"66\":1}}],[\"详见官方文档\",{\"1\":{\"52\":1}}],[\"详见文档\",{\"1\":{\"25\":1}}],[\"详情看文档\",{\"1\":{\"29\":1}}],[\"非批量发送也有这一步\",{\"1\":{\"102\":2}}],[\"非同步模式就是单向和异步\",{\"1\":{\"101\":1}}],[\"非同步模式为1次\",{\"1\":{\"101\":1}}],[\"非空则\",{\"1\":{\"69\":1}}],[\"非常简单\",{\"1\":{\"56\":1}}],[\"非常少见\",{\"1\":{\"21\":1}}],[\"非\",{\"1\":{\"39\":1}}],[\"非阻塞的各种线程安全队列\",{\"1\":{\"29\":1}}],[\"withoutnamespace\",{\"1\":{\"103\":1}}],[\"with\",{\"1\":{\"101\":1}}],[\"withnamespace\",{\"1\":{\"97\":1,\"100\":1,\"101\":1,\"102\":2}}],[\"world\",{\"1\":{\"94\":1}}],[\"workqueue\",{\"1\":{\"56\":1,\"103\":3}}],[\"warmmappedfile\",{\"1\":{\"115\":1}}],[\"warn\",{\"1\":{\"57\":5,\"58\":3,\"66\":3,\"67\":1,\"84\":1,\"97\":1,\"101\":10,\"115\":1,\"116\":4}}],[\"wakeup\",{\"1\":{\"115\":3}}],[\"wakeupcustomer\",{\"1\":{\"67\":1}}],[\"was\",{\"1\":{\"103\":1}}],[\"waituntilwhen\",{\"1\":{\"67\":2}}],[\"waitinterval\",{\"1\":{\"58\":1}}],[\"waitforrunning\",{\"1\":{\"58\":1,\"66\":2,\"67\":2}}],[\"wait\",{\"1\":{\"28\":1}}],[\"which\",{\"1\":{\"110\":1}}],[\"while\",{\"1\":{\"56\":1,\"57\":1,\"58\":1,\"66\":1,\"67\":1,\"84\":7,\"89\":1}}],[\"when\",{\"1\":{\"57\":3}}],[\"whale\",{\"1\":{\"7\":1}}],[\"write\",{\"1\":{\"110\":1,\"115\":2,\"116\":1}}],[\"writequeuenums\",{\"1\":{\"88\":1}}],[\"writequeue\",{\"1\":{\"87\":1,\"96\":1,\"101\":1}}],[\"writelock\",{\"1\":{\"84\":2,\"89\":2}}],[\"writesocketservice\",{\"1\":{\"68\":2}}],[\"writeandflush\",{\"1\":{\"42\":1,\"101\":1,\"103\":1}}],[\"wrong\",{\"1\":{\"57\":1}}],[\"wrapper\",{\"1\":{\"55\":1}}],[\"web\",{\"1\":{\"41\":1,\"42\":1}}],[\"well\",{\"1\":{\"31\":1}}],[\"所谓根据属性查找消息\",{\"1\":{\"112\":1}}],[\"所属集群是否存在\",{\"1\":{\"89\":1}}],[\"所有的\",{\"1\":{\"89\":1}}],[\"所有的主从逻辑基本上都是把数据从主服务器同步到从服务器\",{\"1\":{\"19\":1}}],[\"所有错误\",{\"1\":{\"77\":1}}],[\"所以处理逻辑跟\",{\"1\":{\"116\":1}}],[\"所以真的看到消息错误的异常时要小心\",{\"1\":{\"115\":1}}],[\"所以都是占\",{\"1\":{\"113\":1}}],[\"所以直接\",{\"1\":{\"112\":1}}],[\"所以直接消费就可以了\",{\"1\":{\"60\":1}}],[\"所以接下来我们就来看看专门为消息消费服务的\",{\"1\":{\"110\":1}}],[\"所以初始化为0\",{\"1\":{\"102\":1}}],[\"所以我们的\",{\"1\":{\"98\":1}}],[\"所以修改前一定要加锁防止并发问题\",{\"1\":{\"89\":1}}],[\"所以你看\",{\"1\":{\"112\":1}}],[\"所以你看defaultrequestprocessor就是转发了一下注册请求\",{\"1\":{\"89\":1}}],[\"所以你搜\",{\"1\":{\"89\":1}}],[\"所以有了上面的基础知识我们就知道去哪里找\",{\"1\":{\"89\":1}}],[\"所以这里要从\",{\"1\":{\"55\":1}}],[\"所以在消息被消费之前可以加一层负载均衡来分配消息\",{\"1\":{\"50\":1}}],[\"所以\",{\"1\":{\"41\":1,\"55\":1,\"57\":1,\"67\":1,\"115\":1}}],[\"所以可以去\",{\"1\":{\"41\":1}}],[\"所以实际上\",{\"1\":{\"39\":1}}],[\"所以要先启动持久化\",{\"1\":{\"39\":1}}],[\"所以阅读这部分源码or文档时需要注意\",{\"1\":{\"26\":1}}],[\"可全部跳过\",{\"1\":{\"57\":1}}],[\"可能是因为\",{\"1\":{\"57\":1}}],[\"可控数量线程并发写入\",{\"1\":{\"26\":1}}],[\"可以参考\",{\"1\":{\"115\":1}}],[\"可以是\",{\"1\":{\"115\":1}}],[\"可以是集群\",{\"1\":{\"40\":1}}],[\"可以准确读出消息的全部数据\",{\"1\":{\"111\":1}}],[\"可以暂且看作是一个\",{\"1\":{\"110\":1}}],[\"可以自己看一下\",{\"1\":{\"101\":1}}],[\"可以自己观察一下\",{\"1\":{\"96\":1}}],[\"可以自己去看一下\",{\"1\":{\"57\":1}}],[\"可以先自己过一遍源码\",{\"1\":{\"96\":1}}],[\"可以先大概浏览一遍\",{\"1\":{\"89\":1}}],[\"可以组成一个主从集群\",{\"1\":{\"87\":1}}],[\"可以拥有多个\",{\"1\":{\"87\":1}}],[\"可以帮助理解\",{\"1\":{\"87\":1}}],[\"可以把\",{\"1\":{\"70\":1}}],[\"可以简单看作负责处理请求的类\",{\"1\":{\"69\":1}}],[\"可以找到\",{\"1\":{\"65\":1}}],[\"可以从\",{\"1\":{\"62\":1,\"111\":1}}],[\"可以从消息队列中消费消息的\",{\"1\":{\"47\":1}}],[\"可以\",{\"1\":{\"37\":1}}],[\"可以直接打印依赖树去看\",{\"1\":{\"37\":1}}],[\"可以直接开启开发者模式禁用缓存\",{\"1\":{\"4\":1}}],[\"可以通过修改\",{\"1\":{\"110\":1}}],[\"可以通过\",{\"1\":{\"30\":1}}],[\"可以看出来\",{\"1\":{\"96\":1}}],[\"可以看出\",{\"1\":{\"58\":1}}],[\"可以看到我们直接\",{\"1\":{\"101\":1}}],[\"可以看到它提供了两个注册方法\",{\"1\":{\"89\":1}}],[\"可以看到广播模式就是直接执行\",{\"1\":{\"58\":1}}],[\"可以看到\",{\"1\":{\"42\":1,\"43\":1,\"81\":1}}],[\"可以看到注册流程是\",{\"1\":{\"40\":1}}],[\"可以看到作为消息队列的核心模块\",{\"1\":{\"37\":1}}],[\"可以看成是同步版本的\",{\"1\":{\"26\":1}}],[\"可以看作是工具包\",{\"1\":{\"23\":1}}],[\"而不是消息写入位置\",{\"1\":{\"116\":1}}],[\"而不应该像\",{\"1\":{\"84\":1}}],[\"而刷盘线程从\",{\"1\":{\"115\":1}}],[\"而同一个\",{\"1\":{\"111\":1}}],[\"而消费并没有实现\",{\"1\":{\"110\":1}}],[\"而写入全是顺序写\",{\"1\":{\"110\":1}}],[\"而文件编程需要访问硬盘进行读写\",{\"1\":{\"108\":1}}],[\"而文件编程则是对磁盘上的数据\",{\"1\":{\"108\":1}}],[\"而单向跟同步一个逻辑\",{\"1\":{\"101\":1}}],[\"而无论是\",{\"1\":{\"98\":1}}],[\"而实际上呢\",{\"1\":{\"91\":1}}],[\"而对于\",{\"1\":{\"89\":1}}],[\"而当你要切换到写状态时\",{\"1\":{\"67\":1}}],[\"而前面提到的另一个方法\",{\"1\":{\"67\":1}}],[\"而且这个\",{\"1\":{\"116\":1}}],[\"而且是数量级的快\",{\"1\":{\"108\":1}}],[\"而且同一个\",{\"1\":{\"65\":1}}],[\"而且提供了消息粒度的负载均衡\",{\"1\":{\"58\":1}}],[\"而且要和\",{\"1\":{\"48\":1}}],[\"而负载均衡器则利用分配策略为\",{\"1\":{\"58\":1}}],[\"而\",{\"1\":{\"42\":1,\"110\":2,\"111\":3,\"115\":1,\"119\":1,\"120\":1}}],[\"而是直接传入\",{\"1\":{\"42\":1}}],[\"而这个方法里第一步就是根据\",{\"1\":{\"69\":1}}],[\"而这个\",{\"1\":{\"42\":1}}],[\"而言\",{\"1\":{\"41\":1,\"49\":2}}],[\"而并发集合类\",{\"1\":{\"26\":1}}],[\"而执行机制\",{\"1\":{\"23\":1}}],[\"本消息的起始位置为止\",{\"1\":{\"116\":1}}],[\"本文跳过了消息消费相关的一部分内容\",{\"1\":{\"121\":1}}],[\"本文会先从概念上介绍\",{\"1\":{\"105\":1}}],[\"本文会以自顶向下的方式来介绍\",{\"1\":{\"79\":1}}],[\"本文以跟随\",{\"1\":{\"104\":1}}],[\"本身是个基于\",{\"1\":{\"81\":1}}],[\"本章节目录结构来自\",{\"1\":{\"70\":1}}],[\"本地路由信息表\",{\"1\":{\"103\":1}}],[\"本地路由表不为空\",{\"1\":{\"101\":1}}],[\"本地是有缓存\",{\"1\":{\"103\":1}}],[\"本地没有就带着\",{\"1\":{\"77\":1}}],[\"本地缓存消息\",{\"1\":{\"57\":1}}],[\"本地缓存消息数量\",{\"1\":{\"57\":1}}],[\"本地\",{\"1\":{\"57\":2}}],[\"本地队列\",{\"1\":{\"46\":1}}],[\"本质就是\",{\"1\":{\"59\":1}}],[\"本质就是一个\",{\"1\":{\"43\":1}}],[\"本质上就是\",{\"1\":{\"98\":1}}],[\"本质上差别不大\",{\"1\":{\"46\":1}}],[\"本质上同一时间只有一个线程访问它并没有并发concurrent\",{\"1\":{\"26\":1}}],[\"本质是个\",{\"1\":{\"39\":1,\"81\":1}}],[\"本篇只简单介绍什么是\",{\"1\":{\"35\":1}}],[\"本站调试记录\",{\"0\":{\"2\":1}}],[\"来将前面\",{\"1\":{\"102\":1}}],[\"来判断该\",{\"1\":{\"89\":1}}],[\"来判断请求类型\",{\"1\":{\"89\":1}}],[\"来组装\",{\"1\":{\"89\":1}}],[\"来重新注册而已\",{\"1\":{\"89\":1}}],[\"来进行网络通信的\",{\"1\":{\"89\":1}}],[\"来更新对应的\",{\"1\":{\"88\":1}}],[\"来自定义存储目录\",{\"1\":{\"110\":1}}],[\"来自\",{\"1\":{\"84\":1}}],[\"来完成消息拉取的\",{\"1\":{\"69\":1}}],[\"来说\",{\"1\":{\"89\":1}}],[\"来说就是\",{\"1\":{\"67\":1}}],[\"来说其实没啥区别\",{\"1\":{\"42\":1}}],[\"来看看\",{\"1\":{\"60\":1}}],[\"来创建一个\",{\"1\":{\"56\":1}}],[\"来处理\",{\"1\":{\"42\":1,\"57\":1}}],[\"来实现类似的功能\",{\"1\":{\"41\":1}}],[\"来保证\",{\"1\":{\"26\":1,\"76\":1}}],[\"来记录调试工作\",{\"1\":{\"3\":1}}],[\"访问\",{\"1\":{\"26\":1}}],[\"原则和一些例子\",{\"1\":{\"25\":1}}],[\"原子类\",{\"1\":{\"23\":1}}],[\"内的数据就被写入硬盘\",{\"1\":{\"115\":1}}],[\"内存\",{\"1\":{\"114\":1}}],[\"内存的数据传输速读天然比硬盘要快\",{\"1\":{\"108\":1}}],[\"内存一致性属性\",{\"1\":{\"25\":1}}],[\"内部结构为\",{\"1\":{\"111\":1}}],[\"内部结构就是\",{\"1\":{\"102\":1}}],[\"内部逻辑就是\",{\"1\":{\"84\":1}}],[\"内部自定义的抽象类\",{\"1\":{\"57\":1}}],[\"内维护一个单线程执行器\",{\"1\":{\"57\":1}}],[\"内容是倒序的\",{\"1\":{\"2\":1}}],[\"为准\",{\"1\":{\"119\":1}}],[\"为避免翻译带来的歧义\",{\"1\":{\"110\":1}}],[\"为0的话\",{\"1\":{\"89\":1}}],[\"为了满足定长设计\",{\"1\":{\"111\":1}}],[\"为了满足不同使用场景\",{\"1\":{\"77\":1}}],[\"为了提供持久化能力\",{\"1\":{\"108\":1}}],[\"为了达成设计目标实现了哪些机制\",{\"1\":{\"105\":1}}],[\"为了方便阅读\",{\"1\":{\"84\":1}}],[\"为了方便理解\",{\"1\":{\"56\":1}}],[\"为了避免消息被多个消费者重复消费\",{\"1\":{\"58\":1}}],[\"为空则创建\",{\"1\":{\"69\":1}}],[\"为空\",{\"1\":{\"57\":1,\"65\":1,\"67\":1,\"115\":1}}],[\"为\",{\"1\":{\"57\":2,\"64\":2,\"67\":1,\"69\":2,\"84\":1,\"88\":1,\"89\":1,\"98\":2}}],[\"为并发编程提供的标准化可扩展的框架\",{\"1\":{\"24\":1}}],[\"为主线\",{\"1\":{\"104\":1}}],[\"为主\",{\"1\":{\"13\":1}}],[\"是先写页缓存\",{\"1\":{\"120\":1}}],[\"是不加\",{\"1\":{\"116\":1}}],[\"是不是超过4m最大小限制等等\",{\"1\":{\"101\":1}}],[\"是不是为空啊\",{\"1\":{\"101\":1}}],[\"是不是\",{\"1\":{\"101\":1}}],[\"是不是默认的\",{\"1\":{\"98\":1}}],[\"是损坏的\",{\"1\":{\"116\":1}}],[\"是有可能拿着一部分的数据一直不提交的\",{\"1\":{\"115\":1}}],[\"是有消息的\",{\"1\":{\"112\":1}}],[\"是会返回\",{\"1\":{\"115\":1}}],[\"是分开的\",{\"1\":{\"114\":1}}],[\"是每次有消息进来就自增+1\",{\"1\":{\"112\":1}}],[\"是用来支持消息过滤功能的\",{\"1\":{\"111\":1}}],[\"是用户自己在配置文件里指定的\",{\"1\":{\"65\":1}}],[\"是为了提升消费效率的设计\",{\"1\":{\"108\":1}}],[\"是源码里的\",{\"1\":{\"102\":1}}],[\"是啥\",{\"1\":{\"95\":1}}],[\"是已经存在于\",{\"1\":{\"89\":1}}],[\"是基于\",{\"1\":{\"89\":1}}],[\"是前面说的\",{\"1\":{\"84\":1}}],[\"是启动类\",{\"1\":{\"83\":1}}],[\"是向\",{\"1\":{\"77\":1}}],[\"是切回\",{\"1\":{\"69\":1}}],[\"是切换\",{\"1\":{\"69\":1}}],[\"是由哪个\",{\"1\":{\"91\":1}}],[\"是由\",{\"1\":{\"69\":1}}],[\"是从\",{\"1\":{\"67\":1,\"77\":1}}],[\"是服务线程\",{\"1\":{\"65\":1}}],[\"是单独一个线程每\",{\"1\":{\"58\":1}}],[\"是个啥\",{\"1\":{\"98\":1}}],[\"是个服务线程\",{\"1\":{\"67\":1}}],[\"是个抽象类\",{\"1\":{\"58\":1}}],[\"是个非常简单的标准化接口\",{\"1\":{\"30\":1}}],[\"是否缓存页繁忙\",{\"1\":{\"115\":1}}],[\"是否为可写状态\",{\"1\":{\"115\":1}}],[\"是否为\",{\"1\":{\"115\":2}}],[\"是否为顺序消息模式\",{\"1\":{\"40\":1}}],[\"是否存在\",{\"1\":{\"89\":1,\"98\":1}}],[\"是否存活的逻辑\",{\"1\":{\"84\":1}}],[\"是否存活\",{\"1\":{\"80\":1}}],[\"是否接收返回信息以及用什么方式处理返回信息取决于采取的是哪种发送方式\",{\"1\":{\"77\":1}}],[\"是否切换另外的\",{\"1\":{\"96\":1}}],[\"是否切换\",{\"1\":{\"69\":1}}],[\"是否每次\",{\"1\":{\"57\":1}}],[\"是变量\",{\"1\":{\"57\":1}}],[\"是迭代次数\",{\"1\":{\"57\":1}}],[\"是就是负责把消息从\",{\"1\":{\"57\":1}}],[\"是如何提交给\",{\"1\":{\"56\":1}}],[\"是如何处理消息的\",{\"1\":{\"41\":1}}],[\"是则\",{\"1\":{\"56\":1}}],[\"是一个分布式的消息队列\",{\"1\":{\"80\":1}}],[\"是一个基于主题的发布与订阅模式的消息队列中间价\",{\"1\":{\"75\":1}}],[\"是一个集群模式下的\",{\"1\":{\"58\":1}}],[\"是一个包含\",{\"1\":{\"56\":1}}],[\"是一个跟\",{\"1\":{\"39\":1}}],[\"是默认值\",{\"1\":{\"55\":1}}],[\"是集群模式\",{\"1\":{\"55\":1}}],[\"是事务消息的标记\",{\"1\":{\"42\":1}}],[\"是并发的\",{\"1\":{\"26\":1}}],[\"是同步的\",{\"1\":{\"26\":1}}],[\"是\",{\"1\":{\"24\":1,\"36\":1,\"56\":1,\"67\":1,\"69\":1,\"84\":3,\"95\":1,\"116\":1}}],[\"简单介绍一下\",{\"1\":{\"114\":1}}],[\"简单总结\",{\"1\":{\"110\":1}}],[\"简单总结一下\",{\"1\":{\"98\":1}}],[\"简单总结一下启动流程\",{\"1\":{\"55\":1}}],[\"简单的说就是可以直接从内核空间映射到用户空间\",{\"1\":{\"114\":1}}],[\"简单的说就是可以对任意位置直接进行读写\",{\"1\":{\"110\":1}}],[\"简单的说就是拉取消息的请求\",{\"1\":{\"57\":1}}],[\"简单了解一下\",{\"1\":{\"87\":1}}],[\"简单粗暴\",{\"1\":{\"41\":1}}],[\"简称juc\",{\"1\":{\"24\":1}}],[\"简介\",{\"0\":{\"6\":1,\"23\":1}}],[\"类里还有一个线程叫做\",{\"1\":{\"115\":1}}],[\"类里的\",{\"1\":{\"112\":1}}],[\"类提供的各种具体实现\",{\"1\":{\"103\":1}}],[\"类加载的\",{\"1\":{\"102\":1}}],[\"类似\",{\"1\":{\"112\":1}}],[\"类似晋升\",{\"1\":{\"89\":1}}],[\"类似前面给\",{\"1\":{\"84\":1}}],[\"类似前几篇里我写的消费进度的概念\",{\"1\":{\"51\":1}}],[\"类\",{\"1\":{\"28\":1,\"97\":1}}],[\"类的工厂和工具方法的合集\",{\"1\":{\"23\":1}}],[\"类型\",{\"1\":{\"13\":1,\"57\":1,\"115\":1}}],[\"它采用的方式你可以理解为空间换时间\",{\"1\":{\"120\":1}}],[\"它采用的是自研文件系统的方案\",{\"1\":{\"108\":1}}],[\"它代码里叫\",{\"1\":{\"116\":1}}],[\"它代表客户端目前消费到队列中哪个位置\",{\"1\":{\"51\":1}}],[\"它起始位置是判断不出来的\",{\"1\":{\"116\":1}}],[\"它这里管理着很多线程\",{\"1\":{\"116\":1}}],[\"它刷盘的方式跟前面都不一样\",{\"1\":{\"115\":1}}],[\"它为\",{\"1\":{\"112\":1}}],[\"它内部数据就是系统写入的消息\",{\"1\":{\"110\":1}}],[\"它内部还维护一个\",{\"1\":{\"67\":1}}],[\"它不需要寻道\",{\"1\":{\"110\":1}}],[\"它不需要保证顺序\",{\"1\":{\"60\":1}}],[\"它最小可读单元是\",{\"1\":{\"110\":1}}],[\"它会先拼接生成\",{\"1\":{\"112\":1}}],[\"它会存入\",{\"1\":{\"108\":1}}],[\"它会提交一个周期任务给\",{\"1\":{\"55\":1}}],[\"它可以是生产者也可以是消费者\",{\"1\":{\"98\":1}}],[\"它可以用来定义线程池\",{\"1\":{\"30\":1}}],[\"它维护了五个数据表\",{\"1\":{\"87\":1}}],[\"它单独起个线程\",{\"1\":{\"84\":1}}],[\"它主要负责处理各种业务逻辑\",{\"1\":{\"67\":1}}],[\"它有三个内部类\",{\"1\":{\"67\":1}}],[\"它有主从同步但是没有主从切换\",{\"1\":{\"61\":1}}],[\"它有顺序消费和并发消费两个实现类\",{\"1\":{\"56\":1}}],[\"它跟\",{\"1\":{\"60\":1}}],[\"它把队列和消费者进行了一对一映射\",{\"1\":{\"58\":1}}],[\"它是一种通过系统调用将文件映射到内存的技术\",{\"1\":{\"114\":1}}],[\"它是最基础也是最核心的数据文件\",{\"1\":{\"108\":1}}],[\"它是给\",{\"1\":{\"57\":1}}],[\"它是执行消费行为的线程\",{\"1\":{\"56\":1}}],[\"它里面维护一个\",{\"1\":{\"115\":1}}],[\"它里面存储的就是异步转发来的数据\",{\"1\":{\"111\":1}}],[\"它里面存储的是\",{\"1\":{\"108\":1}}],[\"它里面只存储\",{\"1\":{\"57\":1}}],[\"它里面的数据来自\",{\"1\":{\"119\":1}}],[\"它里面的\",{\"1\":{\"57\":1}}],[\"它只是选择一个\",{\"1\":{\"57\":1}}],[\"它提供\",{\"1\":{\"43\":1}}],[\"它并没有对\",{\"1\":{\"42\":1}}],[\"它还包含\",{\"1\":{\"37\":1}}],[\"它负责消息的传递\",{\"1\":{\"36\":1}}],[\"它通过继承\",{\"1\":{\"30\":1}}],[\"它的数据也来自\",{\"1\":{\"112\":1}}],[\"它的每个元素都是一个\",{\"1\":{\"111\":1}}],[\"它的真实类型是\",{\"1\":{\"110\":1,\"115\":1}}],[\"它的各个节点之间并不会互相通信\",{\"1\":{\"80\":1}}],[\"它的主要工作就是监听\",{\"1\":{\"67\":1}}],[\"它的工作就是\",{\"1\":{\"58\":1}}],[\"它的\",{\"1\":{\"57\":1}}],[\"它的职责很多\",{\"1\":{\"35\":1}}],[\"它的含义不仅仅是线程安全\",{\"1\":{\"26\":1}}],[\"它的基本逻辑是从线程池里获取线程\",{\"1\":{\"23\":1}}],[\"它自动生成一个标题为\",{\"1\":{\"11\":1}}],[\"也在这里完成真正的初始化\",{\"1\":{\"101\":1}}],[\"也会进入这个方法\",{\"1\":{\"67\":1}}],[\"也会初始化\",{\"1\":{\"58\":1}}],[\"也是为了实现相同的目标\",{\"1\":{\"110\":1}}],[\"也是提醒你要自定义\",{\"1\":{\"98\":1}}],[\"也是服务线程\",{\"1\":{\"68\":1}}],[\"也是同理\",{\"1\":{\"60\":1}}],[\"也是\",{\"1\":{\"56\":1,\"98\":1,\"111\":1}}],[\"也是基于\",{\"1\":{\"37\":1}}],[\"也可以理解为内存的读写分离\",{\"1\":{\"120\":1}}],[\"也可以是\",{\"1\":{\"115\":1}}],[\"也可以直接给消息加上全局自增的唯一id的方式自行实现全局有序\",{\"1\":{\"46\":1}}],[\"也可以在\",{\"1\":{\"41\":1}}],[\"也就是读操作\",{\"1\":{\"120\":1}}],[\"也就是去\",{\"1\":{\"111\":1}}],[\"也就是代码中的end\",{\"1\":{\"110\":1}}],[\"也就是内存\",{\"1\":{\"102\":1}}],[\"也就是不止一次\",{\"1\":{\"101\":1}}],[\"也就是发送消息的流程\",{\"1\":{\"99\":1}}],[\"也就是前面的\",{\"1\":{\"116\":1}}],[\"也就是前面说的\",{\"1\":{\"98\":1}}],[\"也就是前文讲的\",{\"1\":{\"57\":1}}],[\"也就是提供了哪些方法\",{\"1\":{\"96\":1}}],[\"也就是下标\",{\"1\":{\"67\":1}}],[\"也就是一个负载均衡器远程上锁的周期\",{\"1\":{\"58\":1}}],[\"也就是说内存中所有数据都保存在文件中了\",{\"1\":{\"119\":1}}],[\"也就是说\",{\"1\":{\"48\":1,\"69\":1}}],[\"也就是\",{\"1\":{\"42\":1,\"57\":1,\"66\":1,\"69\":1,\"77\":1,\"83\":1,\"84\":1,\"101\":1,\"102\":1,\"115\":1,\"119\":1}}],[\"也就是常说的刷盘\",{\"1\":{\"42\":1}}],[\"也就是单向发送\",{\"1\":{\"41\":1}}],[\"也就是高可用模式\",{\"1\":{\"39\":1}}],[\"也就是进入\",{\"1\":{\"39\":1}}],[\"也就是具体如何执行\",{\"1\":{\"23\":1}}],[\"也一样\",{\"1\":{\"19\":1}}],[\"厨房\",{\"1\":{\"23\":1}}],[\"赛车\",{\"1\":{\"23\":1}}],[\"包下面\",{\"1\":{\"89\":1}}],[\"包下的\",{\"1\":{\"42\":1}}],[\"包\",{\"1\":{\"62\":1}}],[\"包里是各种事件的\",{\"1\":{\"81\":1}}],[\"包里找\",{\"1\":{\"41\":1}}],[\"包里\",{\"1\":{\"41\":1}}],[\"包内的例子来理解上面的定义\",{\"1\":{\"30\":1}}],[\"包中的很多类都带有\",{\"1\":{\"26\":1}}],[\"包中如何实践\",{\"1\":{\"25\":1}}],[\"包含的\",{\"1\":{\"84\":1}}],[\"包含\",{\"1\":{\"23\":1}}],[\"包括首次注册\",{\"1\":{\"89\":1}}],[\"包括消息的生产者和消费者\",{\"1\":{\"76\":1}}],[\"包括粘包处理等\",{\"1\":{\"68\":1}}],[\"包括同步\",{\"1\":{\"41\":1}}],[\"包括介绍\",{\"1\":{\"13\":1}}],[\"包括\",{\"1\":{\"2\":1,\"115\":1}}],[\"通常就是你用户目录\",{\"1\":{\"110\":1}}],[\"通常的做法是发送数据的时候额外携带\",{\"1\":{\"89\":1}}],[\"通常会循环5次\",{\"1\":{\"67\":1}}],[\"通常是消费组内的\",{\"1\":{\"58\":1}}],[\"通常都会有好几个队列\",{\"1\":{\"46\":1}}],[\"通常默认为以下三个包的统称\",{\"1\":{\"23\":1}}],[\"通过详细介绍\",{\"1\":{\"110\":1}}],[\"通过对源码进行跟踪来了解\",{\"1\":{\"104\":1}}],[\"通过代码可以看出batch\",{\"1\":{\"102\":1}}],[\"通过\",{\"1\":{\"89\":1,\"102\":1,\"111\":1}}],[\"通过消费篇我们知道\",{\"1\":{\"69\":1}}],[\"通过调用\",{\"1\":{\"57\":1}}],[\"通过同步调用invokesync的方式发起请求\",{\"1\":{\"40\":1}}],[\"通过阅读\",{\"1\":{\"37\":1}}],[\"通过提供线程状态方法\",{\"1\":{\"30\":1}}],[\"通过导航跳转\",{\"1\":{\"1\":1}}],[\"返回注销成功的\",{\"1\":{\"90\":1}}],[\"返回响应\",{\"1\":{\"67\":1}}],[\"返回响应的服务端\",{\"1\":{\"43\":1}}],[\"返回的是\",{\"1\":{\"98\":2}}],[\"返回的待同步消息\",{\"1\":{\"66\":1}}],[\"返回的确认消息就认为本次写操作成功\",{\"1\":{\"22\":1}}],[\"返回消息\",{\"1\":{\"66\":1}}],[\"返回所有注册结果registerbrokerresultlist\",{\"1\":{\"40\":1}}],[\"返回给客户端\",{\"1\":{\"22\":1}}],[\"只贴\",{\"1\":{\"103\":1}}],[\"只不过是在\",{\"1\":{\"116\":1}}],[\"只不过返回值被无视了\",{\"1\":{\"101\":1}}],[\"只不过他监听的\",{\"1\":{\"81\":1}}],[\"只不过因为大部分都是\",{\"1\":{\"67\":1}}],[\"只靠\",{\"1\":{\"72\":1}}],[\"只会是\",{\"1\":{\"71\":1}}],[\"只是为了恢复文件的时候跟\",{\"1\":{\"116\":1}}],[\"只是唤醒逻辑\",{\"1\":{\"67\":1}}],[\"只是通过排它锁\",{\"1\":{\"26\":1}}],[\"只看数据写入的话\",{\"1\":{\"110\":1}}],[\"只看这一个就行\",{\"1\":{\"96\":1}}],[\"只看它连接\",{\"1\":{\"65\":1}}],[\"只看设置监听端口部分\",{\"1\":{\"64\":1}}],[\"只看主要逻辑\",{\"1\":{\"57\":1}}],[\"只看代码会很蒙\",{\"1\":{\"42\":1}}],[\"只有三个字段\",{\"1\":{\"117\":1}}],[\"只有结尾大小不一样\",{\"1\":{\"116\":1}}],[\"只有积压消息超过\",{\"1\":{\"61\":1}}],[\"只有顺序消费时才取出对应数量消息写入\",{\"1\":{\"56\":1}}],[\"只有一个方法\",{\"1\":{\"30\":1}}],[\"只对应一个\",{\"1\":{\"98\":1}}],[\"只对\",{\"1\":{\"42\":1}}],[\"只要成功就直接\",{\"1\":{\"116\":1}}],[\"只要需要创建文件的时候就会生成一个创建请求\",{\"1\":{\"115\":1}}],[\"只要给出任意一个消息的偏移量\",{\"1\":{\"110\":1}}],[\"只要满足条件就建立链接\",{\"1\":{\"67\":1}}],[\"只要对\",{\"1\":{\"58\":1}}],[\"只要\",{\"1\":{\"57\":1,\"66\":1,\"98\":1}}],[\"只要被消费组内任意\",{\"1\":{\"49\":1}}],[\"只要返回列表不为空就取出第一条结果\",{\"1\":{\"40\":1}}],[\"只要收到任意一个从库\",{\"1\":{\"22\":1}}],[\"只显示文档关系路径\",{\"1\":{\"3\":1}}],[\"半同步跟全同步的区别是\",{\"1\":{\"22\":1}}],[\"半同步模式\",{\"0\":{\"22\":1}}],[\"性能较差\",{\"1\":{\"21\":1}}],[\"同\",{\"1\":{\"118\":1}}],[\"同样是顺序写\",{\"1\":{\"111\":1}}],[\"同样是启动一个单线程定时任务\",{\"1\":{\"39\":1}}],[\"同理可参考之前提到的\",{\"1\":{\"110\":1}}],[\"同理\",{\"1\":{\"98\":1}}],[\"同一个\",{\"1\":{\"77\":1}}],[\"同一个消费者组下所有\",{\"1\":{\"52\":1}}],[\"同时兼顾了高效的根据\",{\"1\":{\"110\":1}}],[\"同时异步转发给\",{\"1\":{\"108\":1}}],[\"同时关闭\",{\"1\":{\"89\":1}}],[\"同时还要让数据库尽可能的具备更大的抗压能力\",{\"1\":{\"107\":1}}],[\"同时还有一个线程不断从\",{\"1\":{\"77\":1}}],[\"同时还保证线程安全\",{\"1\":{\"26\":1}}],[\"同时要注意消费间隔不能太长\",{\"1\":{\"46\":1}}],[\"同时也明确了\",{\"1\":{\"40\":1}}],[\"同时启动一系列定时任务\",{\"1\":{\"39\":1}}],[\"同时\",{\"1\":{\"39\":1,\"57\":1,\"89\":1}}],[\"同时按需初始化一堆东西\",{\"1\":{\"39\":1}}],[\"同时附带了一堆时间转换的方法以及时间单位的定义\",{\"1\":{\"28\":1}}],[\"同时使用前注意插件支持哪个\",{\"1\":{\"7\":1}}],[\"同步发送消息\",{\"1\":{\"103\":1}}],[\"同步和异步的区别主要是入参的不同以及异步需要\",{\"1\":{\"101\":1}}],[\"同步标记\",{\"1\":{\"88\":1}}],[\"同步\",{\"1\":{\"71\":1,\"91\":1,\"101\":2,\"115\":1}}],[\"同步一次数据\",{\"1\":{\"71\":1}}],[\"同步数据\",{\"1\":{\"71\":1}}],[\"同步消息\",{\"1\":{\"63\":1,\"66\":1}}],[\"同步版本的\",{\"1\":{\"26\":1}}],[\"同步辅助类\",{\"1\":{\"23\":1}}],[\"同步模式下\",{\"1\":{\"101\":1}}],[\"同步模式\",{\"0\":{\"20\":1}}],[\"语境都是不同的\",{\"1\":{\"89\":1}}],[\"语境\",{\"1\":{\"47\":1,\"65\":1,\"81\":1}}],[\"语境下其实就是周期性的自动从\",{\"1\":{\"46\":1}}],[\"语境就是一种\",{\"1\":{\"41\":1}}],[\"语句\",{\"1\":{\"19\":1}}],[\"语言\",{\"1\":{\"13\":1}}],[\"并取出该消息的\",{\"1\":{\"119\":1}}],[\"并写入消息\",{\"1\":{\"110\":1}}],[\"并写入从库的中继日志中\",{\"1\":{\"19\":1}}],[\"并开启定时任务这个流程\",{\"1\":{\"98\":1}}],[\"并不会\",{\"1\":{\"80\":1}}],[\"并不是在\",{\"1\":{\"46\":1}}],[\"并尝试发送和消费消息\",{\"1\":{\"78\":1}}],[\"并在本地进行缓存\",{\"1\":{\"76\":1}}],[\"并销毁线程\",{\"1\":{\"68\":1}}],[\"并同时为该\",{\"1\":{\"68\":1}}],[\"并再次上报\",{\"1\":{\"66\":1}}],[\"并再一复制订阅关系\",{\"1\":{\"55\":1}}],[\"并\",{\"1\":{\"66\":1}}],[\"并提交给\",{\"1\":{\"57\":1}}],[\"并执行\",{\"1\":{\"57\":1,\"98\":1}}],[\"并将消息封装成\",{\"1\":{\"57\":1}}],[\"并进行批量消费\",{\"1\":{\"56\":1}}],[\"并行消费是\",{\"1\":{\"55\":1}}],[\"并存入\",{\"1\":{\"55\":1,\"67\":1}}],[\"并返回\",{\"1\":{\"42\":1}}],[\"并且可以自行决定在什么时间点将修改刷盘\",{\"1\":{\"114\":1}}],[\"并且数据的修改和数据写入硬件\",{\"1\":{\"114\":1}}],[\"并且还要满足使用中可以通过多种方式查找消息的要求\",{\"1\":{\"108\":1}}],[\"并且初始化其对应的\",{\"1\":{\"98\":1}}],[\"并且初始化该\",{\"1\":{\"98\":1}}],[\"并且该\",{\"1\":{\"89\":1}}],[\"并且通过前面的代码我们知道会有一个线程定期扫描并剔除无效\",{\"1\":{\"89\":1}}],[\"并且异步转发给\",{\"1\":{\"76\":1}}],[\"并且复制接收\",{\"1\":{\"76\":1}}],[\"并且创建一个\",{\"1\":{\"67\":1}}],[\"并且要注意\",{\"1\":{\"58\":1}}],[\"并且要获取到haserveraddr\",{\"1\":{\"40\":1}}],[\"并且默认每\",{\"1\":{\"40\":1}}],[\"并且与消息生产者\",{\"1\":{\"35\":1}}],[\"并发版本的也一样\",{\"1\":{\"56\":1}}],[\"并发消费无所谓顺序\",{\"1\":{\"57\":1}}],[\"并发消费控流\",{\"1\":{\"57\":1}}],[\"并发消费\",{\"1\":{\"46\":1,\"55\":1,\"57\":1}}],[\"并发\",{\"1\":{\"26\":1}}],[\"并发集合\",{\"1\":{\"23\":1}}],[\"并发集合类\",{\"1\":{\"13\":1,\"26\":1}}],[\"负责初始化\",{\"1\":{\"81\":1}}],[\"负责从\",{\"1\":{\"69\":1}}],[\"负责从主服务器上读取\",{\"1\":{\"19\":1}}],[\"负责执行负载均衡任务的是\",{\"1\":{\"58\":1}}],[\"负责定期把\",{\"1\":{\"57\":1}}],[\"负责读取中继日志并重放其中的\",{\"1\":{\"19\":1}}],[\"负责将主库上的数据更改写入\",{\"1\":{\"19\":1}}],[\"负载均衡策略\",{\"1\":{\"58\":1}}],[\"负载均衡操作\",{\"1\":{\"58\":1}}],[\"负载均衡的实现和\",{\"1\":{\"58\":1}}],[\"负载均衡器内部维护如下三个数据表\",{\"1\":{\"58\":1}}],[\"负载均衡器每隔\",{\"1\":{\"58\":1}}],[\"负载均衡\",{\"0\":{\"50\":1,\"58\":1},\"1\":{\"13\":1}}],[\"out\",{\"1\":{\"94\":1}}],[\"oldaddr\",{\"1\":{\"89\":4}}],[\"obj\",{\"1\":{\"57\":5}}],[\"objlock\",{\"1\":{\"56\":2}}],[\"object\",{\"1\":{\"56\":1,\"57\":1}}],[\"ok\",{\"1\":{\"55\":4,\"66\":2,\"67\":3,\"98\":3,\"101\":2,\"103\":2,\"115\":5}}],[\"override\",{\"1\":{\"39\":1,\"57\":7,\"71\":1,\"103\":1,\"115\":1}}],[\"only\",{\"1\":{\"89\":1}}],[\"onchannelclose\",{\"1\":{\"84\":1}}],[\"onchanneldestroy方法主要功能就是前面注释里说的从\",{\"1\":{\"84\":1}}],[\"onchanneldestroy\",{\"1\":{\"84\":5}}],[\"once\",{\"1\":{\"55\":1,\"84\":1,\"98\":1,\"101\":3}}],[\"onwaitend\",{\"1\":{\"67\":1}}],[\"oneway\",{\"1\":{\"101\":1,\"103\":1}}],[\"one\",{\"1\":{\"58\":1,\"89\":1,\"102\":1}}],[\"onexception\",{\"1\":{\"57\":1}}],[\"onsuccess\",{\"1\":{\"57\":2}}],[\"on\",{\"1\":{\"31\":1,\"115\":1}}],[\"other\",{\"1\":{\"31\":1,\"57\":5}}],[\"offsettable\",{\"1\":{\"55\":1}}],[\"offsets\",{\"1\":{\"55\":2}}],[\"offsetstore\",{\"1\":{\"55\":9,\"57\":3}}],[\"offset\",{\"1\":{\"51\":2,\"57\":18,\"63\":1,\"66\":2,\"67\":7,\"68\":1,\"108\":1,\"110\":4,\"111\":4,\"112\":12,\"116\":12,\"119\":1}}],[\"of\",{\"1\":{\"31\":4,\"101\":1,\"110\":1,\"115\":1}}],[\"origin\",{\"1\":{\"103\":1}}],[\"orderid188\",{\"1\":{\"94\":1}}],[\"order\",{\"1\":{\"89\":1}}],[\"ordinal\",{\"1\":{\"89\":2}}],[\"org\",{\"1\":{\"62\":1,\"89\":2,\"110\":1,\"111\":1,\"112\":1,\"116\":1}}],[\"oracle\",{\"1\":{\"32\":1}}],[\"or\",{\"1\":{\"26\":1,\"30\":1,\"55\":2,\"57\":2,\"67\":1,\"110\":1,\"112\":1,\"115\":2,\"116\":1}}],[\"o\",{\"1\":{\"19\":2,\"108\":1}}],[\"op\",{\"1\":{\"65\":2}}],[\"openssl\",{\"1\":{\"6\":2}}],[\"options=\",{\"1\":{\"6\":2}}],[\"options\",{\"1\":{\"3\":1}}],[\"线程的间隔\",{\"1\":{\"115\":1}}],[\"线程的设计把执行机制和执行内容分开\",{\"1\":{\"23\":1}}],[\"线程去完成刷盘操作\",{\"1\":{\"115\":1}}],[\"线程安全\",{\"1\":{\"26\":1}}],[\"线程从并发集合类中访问\",{\"1\":{\"25\":1}}],[\"线程必须事先将元素放入并发集合类中\",{\"1\":{\"25\":1}}],[\"线程任务的执行\",{\"1\":{\"23\":1}}],[\"线程执行和管理\",{\"1\":{\"23\":1}}],[\"线程和\",{\"1\":{\"19\":1}}],[\"线程\",{\"1\":{\"19\":5}}],[\"线程池有了\",{\"1\":{\"56\":1}}],[\"线程池版executor\",{\"1\":{\"23\":1}}],[\"线程池\",{\"1\":{\"13\":1,\"42\":1,\"56\":1}}],[\"主节点\",{\"1\":{\"89\":1}}],[\"主动向\",{\"1\":{\"77\":2}}],[\"主动同步回\",{\"1\":{\"70\":1}}],[\"主动与上一步的\",{\"1\":{\"63\":1}}],[\"主动从服务端的消息队列中拉取消息\",{\"1\":{\"46\":1}}],[\"主从\",{\"1\":{\"87\":1}}],[\"主从集群信息\",{\"1\":{\"88\":1}}],[\"主从集群为空的话\",{\"1\":{\"84\":1}}],[\"主从集群的迭代器\",{\"1\":{\"84\":1}}],[\"主从集群的信息\",{\"1\":{\"84\":1}}],[\"主从是否要切换就取决于\",{\"1\":{\"69\":1}}],[\"主从切换\",{\"0\":{\"69\":1},\"1\":{\"69\":1}}],[\"主从机制的基本流程如下\",{\"1\":{\"63\":1}}],[\"主从同步\",{\"0\":{\"62\":1}}],[\"主线逻辑是从\",{\"1\":{\"53\":1}}],[\"主要面对消息消费\",{\"1\":{\"120\":1}}],[\"主要由三个部分组成\",{\"1\":{\"112\":1}}],[\"主要包括三种文件\",{\"1\":{\"108\":1}}],[\"主要基于订阅\",{\"1\":{\"87\":1}}],[\"主要针对集群消费模式\",{\"1\":{\"58\":1}}],[\"主要功能就是把拉回来的数据解码为\",{\"1\":{\"57\":1}}],[\"主要职责就是负责消费消息\",{\"1\":{\"56\":1}}],[\"主要是定期执行\",{\"1\":{\"55\":1}}],[\"主要是五个常见场景的同步器\",{\"1\":{\"27\":1}}],[\"主要看集群模式\",{\"1\":{\"58\":1}}],[\"主要看\",{\"1\":{\"57\":1,\"69\":1,\"101\":1}}],[\"主要看这个方法\",{\"1\":{\"55\":1}}],[\"主要看方法最后那段即可\",{\"1\":{\"42\":1}}],[\"主要工作就是等前面的异步调用都完成之后对\",{\"1\":{\"42\":1}}],[\"主要就是维护以下五个数据表\",{\"1\":{\"81\":1}}],[\"主要就是\",{\"1\":{\"28\":1}}],[\"主要组件包括以下部分\",{\"1\":{\"24\":1}}],[\"主要用来支持对变量进行非阻塞的线程安全编程\",{\"1\":{\"23\":1}}],[\"主要涉及三个线程\",{\"1\":{\"19\":1}}],[\"主库在写入\",{\"1\":{\"21\":1}}],[\"主库\",{\"1\":{\"19\":1,\"22\":1}}],[\"主题颜色影响各种高亮位置\",{\"1\":{\"10\":1}}],[\"主题颜色覆盖src\",{\"1\":{\"10\":1}}],[\"主题自带创建项目的脚手架\",{\"1\":{\"8\":1}}],[\"主题\",{\"0\":{\"8\":1}}],[\"主题推荐使用vuepress\",{\"1\":{\"7\":1}}],[\"主题提供的一些插件功能不太正常\",{\"1\":{\"3\":1}}],[\"文章最后稍微再补充一些关于\",{\"1\":{\"101\":1}}],[\"文档\",{\"1\":{\"122\":1}}],[\"文档动手写一遍文档里所有的\",{\"1\":{\"67\":1}}],[\"文档中这部分实际上就是介绍了一下\",{\"1\":{\"25\":1}}],[\"文档翻译\",{\"0\":{\"24\":1}}],[\"文档目录\",{\"0\":{\"17\":1,\"34\":1}}],[\"文件开始恢复\",{\"1\":{\"119\":1}}],[\"文件恢复是\",{\"1\":{\"119\":1}}],[\"文件恢复\",{\"0\":{\"119\":1}}],[\"文件是一样的\",{\"1\":{\"116\":1}}],[\"文件里就变成逻辑位置了\",{\"1\":{\"116\":1}}],[\"文件进行比较\",{\"1\":{\"116\":1}}],[\"文件才叫物理偏移量\",{\"1\":{\"116\":1}}],[\"文件可写标记\",{\"1\":{\"116\":1}}],[\"文件时的timestamp\",{\"1\":{\"112\":1}}],[\"文件头实际上当成临时变量存储区域就好了\",{\"1\":{\"112\":1}}],[\"文件头\",{\"1\":{\"112\":3}}],[\"文件也是定长设计\",{\"1\":{\"112\":1}}],[\"文件一致\",{\"1\":{\"111\":1}}],[\"文件命名的方式与\",{\"1\":{\"111\":1}}],[\"文件默认包含\",{\"1\":{\"111\":1}}],[\"文件剩余的空闲空间\",{\"1\":{\"110\":1}}],[\"文件至少会有\",{\"1\":{\"110\":1}}],[\"文件系统的随机访问\",{\"1\":{\"110\":1}}],[\"文件系统操作效率最高\",{\"1\":{\"107\":1}}],[\"文件的物理偏移量都叫\",{\"1\":{\"116\":1}}],[\"文件的引入则可以看作是产品功能增强\",{\"1\":{\"112\":1}}],[\"文件的固定大小为\",{\"1\":{\"111\":1}}],[\"文件的剩余空间时\",{\"1\":{\"110\":1}}],[\"文件的命名方式\",{\"1\":{\"110\":1}}],[\"文件的设计\",{\"1\":{\"110\":1,\"111\":1}}],[\"文件内部的结构大致为\",{\"1\":{\"110\":1}}],[\"文件大小的配置\",{\"1\":{\"110\":1}}],[\"文件名格式为\",{\"1\":{\"110\":1}}],[\"文件名长度固定为\",{\"1\":{\"110\":1}}],[\"文件名必须大写\",{\"1\":{\"3\":1}}],[\"文件采用顺序写的方式用于存储所有消息数据\",{\"1\":{\"108\":1}}],[\"文件\",{\"1\":{\"77\":1,\"108\":1,\"110\":3,\"111\":3,\"115\":2,\"116\":2,\"119\":1}}],[\"文件方便以\",{\"1\":{\"76\":1}}],[\"文件中读出来的\",{\"1\":{\"119\":1}}],[\"文件中记录的三个时间戳\",{\"1\":{\"119\":1}}],[\"文件中的最小刷盘时间\",{\"1\":{\"119\":1}}],[\"文件中的物理偏移量都叫\",{\"1\":{\"116\":1}}],[\"文件中的分布基本上可以认为是不连续和随机的\",{\"1\":{\"111\":1}}],[\"文件中收到的第一个消息的信息\",{\"1\":{\"112\":1}}],[\"文件中最小的数据单元\",{\"1\":{\"111\":1}}],[\"文件中\",{\"1\":{\"66\":1,\"110\":1}}],[\"文件绑定\",{\"1\":{\"6\":1}}],[\"文件正文写\",{\"1\":{\"3\":1}}],[\"从倒数第三个\",{\"1\":{\"119\":1}}],[\"从中取出\",{\"1\":{\"112\":1}}],[\"从前文的目录结构中就可以清楚的看到\",{\"1\":{\"111\":1}}],[\"从前面的代码中我们可以发现\",{\"1\":{\"101\":1}}],[\"从本地路由信息表里\",{\"1\":{\"103\":1}}],[\"从发送消息开始\",{\"0\":{\"94\":1}}],[\"从使用者的角度\",{\"1\":{\"91\":1}}],[\"从使用者的角度去看\",{\"1\":{\"77\":1}}],[\"从这里我们就可以看出\",{\"1\":{\"98\":1}}],[\"从这里开始跳过\",{\"1\":{\"89\":1}}],[\"从这一段可以看出\",{\"1\":{\"42\":1}}],[\"从主从集群里删除无效\",{\"1\":{\"84\":1}}],[\"从五个数据表\",{\"1\":{\"84\":1}}],[\"从方法命名看应该是\",{\"1\":{\"84\":1}}],[\"从而导致消费发送存在少量的不均匀\",{\"1\":{\"81\":1}}],[\"从而延迟消费\",{\"1\":{\"59\":1}}],[\"从数据流动角度看\",{\"1\":{\"77\":1}}],[\"从代码中我们可以看出\",{\"1\":{\"69\":1}}],[\"从\",{\"1\":{\"55\":2,\"56\":1,\"57\":4,\"58\":1,\"65\":1,\"84\":4,\"103\":1}}],[\"从源码可以看到\",{\"1\":{\"54\":1}}],[\"从开发工具到\",{\"1\":{\"13\":1}}],[\"从颜色调整到布局设置啥的很全\",{\"1\":{\"10\":1}}],[\"网关\",{\"1\":{\"13\":1}}],[\"网络的内容也考虑放这里\",{\"1\":{\"13\":1}}],[\"微服务\",{\"1\":{\"13\":1}}],[\"你叫物理位置\",{\"1\":{\"116\":1}}],[\"你能看到如下代码\",{\"1\":{\"116\":1}}],[\"你肯定是要把数据从头开始写\",{\"1\":{\"67\":1}}],[\"你就把它理解为网络io事件的读事件\",{\"1\":{\"65\":1}}],[\"你知道他是个消费行为之前的负载均衡器即可\",{\"1\":{\"55\":1}}],[\"你可以使用修改内存的方式修改文件数据\",{\"1\":{\"114\":1}}],[\"你可以理解为~\",{\"1\":{\"110\":1}}],[\"你可以暂且认为它就是那个\",{\"1\":{\"110\":1}}],[\"你可以把他想成一个长度未知的一维数组\",{\"1\":{\"67\":1}}],[\"你可以通过设置\",{\"1\":{\"46\":1}}],[\"你可以在另外一个端口额外启动一个当说明书看\",{\"1\":{\"8\":1}}],[\"你把它当成\",{\"1\":{\"112\":1}}],[\"你把\",{\"1\":{\"46\":1}}],[\"你也可以直接利用\",{\"1\":{\"41\":1}}],[\"你既可以把它看成数据库也可以用作缓存\",{\"1\":{\"13\":1}}],[\"调用链结尾是\",{\"1\":{\"115\":1}}],[\"调用链太长了\",{\"1\":{\"115\":1}}],[\"调试工具\",{\"1\":{\"13\":1}}],[\"调整首页按钮跳转和文档结构\",{\"1\":{\"3\":1}}],[\"generatefromlist\",{\"1\":{\"102\":2}}],[\"getfilename\",{\"1\":{\"116\":1}}],[\"getflushdisktype\",{\"1\":{\"115\":2}}],[\"getqueueid\",{\"1\":{\"116\":1}}],[\"getqueueoffset\",{\"1\":{\"57\":1}}],[\"getwroteposition\",{\"1\":{\"116\":2}}],[\"getwrotebytes\",{\"1\":{\"115\":1}}],[\"getwroteoffset\",{\"1\":{\"115\":1}}],[\"getwhichbrokerwhenconsumeslowly\",{\"1\":{\"69\":1}}],[\"getkvlistbynamespace\",{\"1\":{\"89\":1}}],[\"getkvconfigmanager\",{\"1\":{\"89\":1}}],[\"getkeys\",{\"1\":{\"112\":1}}],[\"getkey\",{\"1\":{\"58\":1,\"84\":6,\"89\":1}}],[\"gethaserveraddr\",{\"1\":{\"89\":3}}],[\"gethahousekeepinginterval\",{\"1\":{\"66\":1}}],[\"getdataversion\",{\"1\":{\"89\":4}}],[\"getdefaultmessagestore\",{\"1\":{\"66\":2}}],[\"getdefaultmqproducerimpl\",{\"1\":{\"55\":1}}],[\"getbytes\",{\"1\":{\"94\":1}}],[\"getbody\",{\"1\":{\"89\":2,\"115\":1}}],[\"getbrokerid\",{\"1\":{\"89\":1}}],[\"getbrokerip1\",{\"1\":{\"42\":1}}],[\"getbrokeraddr\",{\"1\":{\"89\":1}}],[\"getbrokeraddrs\",{\"1\":{\"84\":2,\"89\":3}}],[\"getbrokername\",{\"1\":{\"69\":2,\"84\":3,\"89\":1,\"101\":7,\"103\":2}}],[\"getbrokerconfig\",{\"1\":{\"42\":2}}],[\"getbrokerrole\",{\"1\":{\"39\":2,\"64\":2,\"69\":1,\"116\":1}}],[\"getversion\",{\"1\":{\"89\":1}}],[\"getvalue\",{\"1\":{\"84\":8,\"89\":3}}],[\"getrunningflags\",{\"1\":{\"116\":2}}],[\"getruntime\",{\"1\":{\"103\":2}}],[\"getrouteinfomanager\",{\"1\":{\"84\":1,\"89\":1}}],[\"getresponsecode\",{\"1\":{\"101\":2}}],[\"getresult\",{\"1\":{\"69\":1}}],[\"getretrytimeswhensendasyncfailed\",{\"1\":{\"103\":1}}],[\"getretrytimeswhensendfailed\",{\"1\":{\"101\":1}}],[\"getretryresponsecodes\",{\"1\":{\"101\":1}}],[\"getregisternameserverperiod\",{\"1\":{\"39\":1}}],[\"getlastmappedfile\",{\"1\":{\"115\":3,\"116\":1}}],[\"getlastupdatetimestamp\",{\"1\":{\"84\":1}}],[\"getlistenport\",{\"1\":{\"64\":1}}],[\"getaccesschannel\",{\"1\":{\"97\":1}}],[\"getaccessmessageinmemorymaxratio\",{\"1\":{\"69\":2}}],[\"getallocatemessagequeuestrategy\",{\"1\":{\"55\":1,\"58\":1}}],[\"getexpressiontype\",{\"1\":{\"57\":1}}],[\"gettagscode\",{\"1\":{\"116\":1}}],[\"gettransactionvalue\",{\"1\":{\"116\":1}}],[\"gettransactionalmessageservice\",{\"1\":{\"42\":1}}],[\"gettopicname\",{\"1\":{\"89\":1}}],[\"gettopicconfigtable\",{\"1\":{\"89\":1}}],[\"gettopic\",{\"1\":{\"57\":1,\"100\":1,\"101\":4,\"102\":2,\"103\":1,\"116\":1}}],[\"getstoretimestamp\",{\"1\":{\"116\":2}}],[\"getstorecheckpoint\",{\"1\":{\"116\":2}}],[\"getstatus\",{\"1\":{\"115\":1}}],[\"getsendstatus\",{\"1\":{\"101\":1}}],[\"getsendmsgtimeout\",{\"1\":{\"101\":1}}],[\"getservicename\",{\"1\":{\"57\":2,\"66\":3}}],[\"getsuggestwhichbrokerid\",{\"1\":{\"69\":1}}],[\"getsubversion\",{\"1\":{\"57\":1}}],[\"getsubstring\",{\"1\":{\"57\":1}}],[\"getsubscriptioninner\",{\"1\":{\"57\":1,\"58\":1}}],[\"getsysflag\",{\"1\":{\"116\":1}}],[\"getsystemclock\",{\"1\":{\"66\":1,\"67\":2,\"115\":2}}],[\"getsyncflushtimeout\",{\"1\":{\"67\":1,\"115\":1}}],[\"getnamespace\",{\"1\":{\"103\":1}}],[\"getnamesrvaddr\",{\"1\":{\"55\":1,\"97\":1}}],[\"getname\",{\"1\":{\"58\":2}}],[\"getnextbeginoffset\",{\"1\":{\"57\":5}}],[\"getnextoffset\",{\"1\":{\"57\":4,\"67\":4}}],[\"getputmessagefailedtimes\",{\"1\":{\"115\":1}}],[\"getpullbatchsize\",{\"1\":{\"57\":1}}],[\"getpullinterval\",{\"1\":{\"57\":2}}],[\"getpullstatus\",{\"1\":{\"57\":1}}],[\"getpullthresholdsizeforqueue\",{\"1\":{\"57\":1}}],[\"getpullthresholdforqueue\",{\"1\":{\"57\":1}}],[\"getproducergroup\",{\"1\":{\"98\":4}}],[\"getproperty\",{\"1\":{\"58\":1,\"103\":1}}],[\"getprocessqueue\",{\"1\":{\"57\":2}}],[\"getmintimestamp\",{\"1\":{\"119\":2}}],[\"getmintimestampindex\",{\"1\":{\"119\":3}}],[\"getmqclientapiimpl\",{\"1\":{\"103\":3}}],[\"getmasteraddr\",{\"1\":{\"89\":1}}],[\"getmaxphyoffset\",{\"1\":{\"65\":1}}],[\"getmaxspan\",{\"1\":{\"57\":1}}],[\"getmsgsize\",{\"1\":{\"116\":1}}],[\"getmsgfoundlist\",{\"1\":{\"57\":5}}],[\"getmsgcount\",{\"1\":{\"57\":1}}],[\"getmessageresult\",{\"1\":{\"69\":1}}],[\"getmessage\",{\"1\":{\"69\":2}}],[\"getmessagequeue\",{\"1\":{\"57\":9}}],[\"getmessagelistenerinner\",{\"1\":{\"55\":4}}],[\"getmessagemodel\",{\"1\":{\"55\":3,\"57\":1,\"58\":1}}],[\"getmessagestoreconfig\",{\"1\":{\"66\":1,\"67\":1,\"115\":5,\"116\":2}}],[\"getmessagestore\",{\"1\":{\"42\":1,\"115\":1}}],[\"get\",{\"1\":{\"57\":3,\"58\":2,\"65\":1,\"67\":4,\"69\":3,\"89\":4,\"103\":3}}],[\"getcreatetopickey\",{\"1\":{\"98\":1}}],[\"getcommitlogoffset\",{\"1\":{\"116\":1}}],[\"getcode\",{\"1\":{\"89\":1}}],[\"getconsumequeueoffset\",{\"1\":{\"116\":1}}],[\"getconsumeconcurrentlymaxspan\",{\"1\":{\"57\":1}}],[\"getconsumethreadmax\",{\"1\":{\"56\":1}}],[\"getconsumethreadmin\",{\"1\":{\"56\":1}}],[\"getconsumergroup\",{\"1\":{\"55\":6,\"57\":1,\"58\":1}}],[\"getchannel\",{\"1\":{\"84\":3}}],[\"getclustername\",{\"1\":{\"89\":1}}],[\"getclientid\",{\"1\":{\"58\":2}}],[\"getclass\",{\"1\":{\"57\":2}}],[\"getoffsetstore\",{\"1\":{\"55\":2}}],[\"getorcreatemqclientinstance\",{\"1\":{\"55\":1,\"98\":3}}],[\"getinstance\",{\"1\":{\"55\":1,\"98\":2}}],[\"groupcommit\",{\"1\":{\"115\":3}}],[\"groupcommitservice里面有一个\",{\"1\":{\"115\":1}}],[\"groupcommitservice\",{\"1\":{\"115\":6}}],[\"groupcommitrequest\",{\"1\":{\"67\":1,\"115\":3}}],[\"grouptable\",{\"1\":{\"98\":1}}],[\"grouptransferservice\",{\"1\":{\"64\":1,\"67\":8}}],[\"group=\",{\"1\":{\"58\":1}}],[\"group\",{\"1\":{\"58\":2,\"98\":5}}],[\"groupname\",{\"1\":{\"55\":1}}],[\"groups\",{\"1\":{\"31\":1}}],[\"guide\",{\"0\":{\"14\":1}}],[\"gc\",{\"1\":{\"13\":1}}],[\"github\",{\"1\":{\"3\":3,\"4\":1,\"103\":1}}],[\"部分是顺序写\",{\"1\":{\"112\":1}}],[\"部分都是用\",{\"1\":{\"67\":1}}],[\"部分都不在讲解范围内\",{\"1\":{\"66\":1}}],[\"部分的代码\",{\"1\":{\"67\":1}}],[\"部分\",{\"1\":{\"13\":1}}],[\"部署库的方式自动部署的几个需要注意的地方\",{\"1\":{\"5\":1}}],[\"部署\",{\"0\":{\"5\":1}}],[\"部署中的警告\",{\"1\":{\"3\":1}}],[\"工具类\",{\"1\":{\"13\":1,\"23\":1}}],[\"泛型\",{\"1\":{\"13\":1}}],[\"框架部分则只更新\",{\"1\":{\"13\":1}}],[\"基于文件编程\",{\"1\":{\"108\":1}}],[\"基于队列和消费者数量的负载均衡\",{\"1\":{\"58\":1}}],[\"基本架构\",{\"0\":{\"76\":1}}],[\"基本流程都是先\",{\"1\":{\"68\":1}}],[\"基本组成\",{\"1\":{\"58\":1}}],[\"基本上也是基于以下公式\",{\"1\":{\"57\":1}}],[\"基本围绕着\",{\"1\":{\"10\":1}}],[\"基础概念\",{\"0\":{\"45\":1},\"1\":{\"44\":1}}],[\"基础上进行扩展\",{\"1\":{\"30\":1}}],[\"基础逻辑\",{\"0\":{\"19\":1}}],[\"基础\",{\"1\":{\"13\":1}}],[\"基础部分只更新重要的基础知识点\",{\"1\":{\"13\":1}}],[\"以下四种状态均为异常\",{\"1\":{\"115\":1}}],[\"以便为发送消息的\",{\"1\":{\"67\":1}}],[\"以便消费\",{\"1\":{\"57\":1}}],[\"以便用户可以快速创建\",{\"1\":{\"47\":1}}],[\"以上这个查找流程相当于轻松实现了一套基于文件系统的高效随机访问\",{\"1\":{\"110\":1}}],[\"以上都不用看\",{\"1\":{\"89\":1}}],[\"以上的四个\",{\"1\":{\"56\":1}}],[\"以上几个例子只是抛砖引玉\",{\"1\":{\"41\":1}}],[\"以异步任务执行框架为例\",{\"1\":{\"30\":1}}],[\"以阻塞同步的方式来保证了线程安全\",{\"1\":{\"26\":1}}],[\"以及后续判断请求类型这些在\",{\"1\":{\"89\":1}}],[\"以及这个\",{\"1\":{\"84\":1}}],[\"以及启动各种定时任务\",{\"1\":{\"81\":1}}],[\"以及对应的路由信息\",{\"1\":{\"77\":1}}],[\"以及纠错等等\",{\"1\":{\"73\":1}}],[\"以及\",{\"1\":{\"25\":1,\"42\":1,\"66\":1}}],[\"以及基于\",{\"1\":{\"23\":1}}],[\"以及主题\",{\"1\":{\"2\":1}}],[\"以\",{\"1\":{\"13\":1,\"57\":1,\"58\":1,\"67\":1}}],[\"最小的来进行辅助判定\",{\"1\":{\"119\":1}}],[\"最新消息的\",{\"1\":{\"116\":1}}],[\"最新消息的偏移量\",{\"1\":{\"112\":1}}],[\"最新消息的存储时间\",{\"1\":{\"112\":1}}],[\"最快的方式就是顺序写\",{\"1\":{\"110\":1}}],[\"最多3次\",{\"1\":{\"101\":1}}],[\"最终执行的方法是\",{\"1\":{\"115\":1}}],[\"最终你应该能找到对\",{\"1\":{\"103\":1}}],[\"最终需要多大的\",{\"1\":{\"102\":1}}],[\"最终具体实现都是\",{\"1\":{\"101\":1}}],[\"最终可以看出\",{\"1\":{\"98\":1}}],[\"最终释放各种资源\",{\"1\":{\"68\":1}}],[\"最终\",{\"1\":{\"42\":1}}],[\"最终返回\",{\"1\":{\"42\":1}}],[\"最后负责创建\",{\"1\":{\"115\":1}}],[\"最后来看看他是如何删除\",{\"1\":{\"84\":1}}],[\"最后释放锁\",{\"1\":{\"58\":1}}],[\"最后\",{\"1\":{\"57\":1,\"77\":1,\"110\":1}}],[\"最后是第三部分\",{\"1\":{\"57\":1}}],[\"最后调用\",{\"1\":{\"57\":1}}],[\"最后如何被提交给\",{\"1\":{\"56\":1}}],[\"最后启动\",{\"1\":{\"55\":1}}],[\"最后跟着源码去看\",{\"1\":{\"44\":1}}],[\"最后则是进行\",{\"1\":{\"40\":1}}],[\"最后执行\",{\"1\":{\"39\":1}}],[\"最后通过手动添加依赖解决了\",{\"1\":{\"3\":1}}],[\"最近在整理积攒下的笔记和草稿\",{\"1\":{\"12\":1}}],[\"投奔\",{\"1\":{\"12\":1}}],[\"just\",{\"1\":{\"55\":1,\"98\":4,\"103\":1}}],[\"juc\",{\"0\":{\"33\":1},\"1\":{\"13\":2,\"23\":1,\"25\":1,\"30\":1,\"84\":1}}],[\"join\",{\"1\":{\"28\":1}}],[\"jvm\",{\"1\":{\"13\":2}}],[\"java8\",{\"1\":{\"32\":1}}],[\"java\",{\"0\":{\"23\":1,\"124\":1},\"1\":{\"13\":4,\"23\":3,\"24\":2,\"38\":1,\"47\":1,\"65\":1,\"66\":1,\"84\":1,\"89\":1}}],[\"jekyll\",{\"1\":{\"12\":1}}],[\"js中添加插件并配置\",{\"1\":{\"7\":1}}],[\"jsonvalue\",{\"1\":{\"89\":2}}],[\"json\",{\"1\":{\"6\":2,\"55\":2,\"109\":9}}],[\"js\",{\"1\":{\"3\":3}}],[\"近几年技术文章写的越来越多\",{\"1\":{\"12\":1}}],[\"下文以同步为例进行分析\",{\"1\":{\"91\":1}}],[\"下方源码\",{\"1\":{\"84\":1}}],[\"下一节将从发送消息入手进行源码分析\",{\"1\":{\"78\":1}}],[\"下面就是创建\",{\"1\":{\"103\":1}}],[\"下面是发送流程\",{\"1\":{\"101\":1}}],[\"下面是设置监听端口\",{\"1\":{\"64\":1}}],[\"下面贴了一段简单的发送消息的代码\",{\"1\":{\"94\":1}}],[\"下面来看这部分代码\",{\"1\":{\"89\":1}}],[\"下面三个都是服务线程\",{\"1\":{\"64\":1}}],[\"下面控流这一段可以不看\",{\"1\":{\"57\":1}}],[\"下的一级目录名就是主题\",{\"1\":{\"111\":1}}],[\"下的消息很可能分布在不同的\",{\"1\":{\"110\":1}}],[\"下的同一条消息只能被其中一个\",{\"1\":{\"77\":1}}],[\"下的\",{\"1\":{\"58\":1}}],[\"下的哪个队列\",{\"1\":{\"57\":1}}],[\"下只有一个队列来达成全局有序\",{\"1\":{\"46\":1}}],[\"下全局有序\",{\"1\":{\"46\":1}}],[\"下没有手动创建readme\",{\"1\":{\"11\":1}}],[\"下了就下了吧\",{\"1\":{\"3\":1}}],[\"功能\",{\"0\":{\"11\":1},\"1\":{\"37\":1}}],[\"隐藏打印按钮\",{\"1\":{\"10\":1}}],[\"样式配置部分\",{\"1\":{\"10\":1}}],[\"样式相关\",{\"0\":{\"10\":1}}],[\"3\",{\"1\":{\"71\":1,\"89\":1,\"109\":1,\"111\":1,\"115\":1,\"119\":2}}],[\"30w\",{\"1\":{\"111\":1}}],[\"300000\",{\"1\":{\"111\":1}}],[\"3000\",{\"1\":{\"96\":1}}],[\"3000ms\",{\"1\":{\"57\":1}}],[\"30s\",{\"1\":{\"77\":1,\"84\":1}}],[\"30\",{\"1\":{\"61\":1,\"69\":3,\"116\":1}}],[\"3rd\",{\"1\":{\"57\":1}}],[\"31\",{\"1\":{\"57\":3}}],[\"3s\",{\"1\":{\"56\":1}}],[\"343f3e\",{\"1\":{\"10\":1}}],[\"3个还是四个小时后会自动恢复到正常模式\",{\"1\":{\"4\":1}}],[\"$home\",{\"1\":{\"111\":1}}],[\"$\",{\"1\":{\"110\":2}}],[\"$bg\",{\"1\":{\"10\":1}}],[\"$theme\",{\"1\":{\"10\":1}}],[\"其最小数据单元\",{\"1\":{\"111\":1}}],[\"其内容就是\",{\"1\":{\"89\":1}}],[\"其高可用通过部署多个\",{\"1\":{\"76\":1}}],[\"其基本架构由客户端\",{\"1\":{\"76\":1}}],[\"其设计核心追求高性能\",{\"1\":{\"75\":1}}],[\"其余情况就是按它的真实值拉取\",{\"1\":{\"68\":1}}],[\"其余均省略\",{\"1\":{\"64\":1}}],[\"其实也是顺序写\",{\"1\":{\"116\":1}}],[\"其实\",{\"1\":{\"112\":1}}],[\"其实仔细思考一下你会发现由于全是定长设计\",{\"1\":{\"111\":1}}],[\"其实还是有很多细节没讲\",{\"1\":{\"110\":1}}],[\"其实主要是对消息集合进行过滤\",{\"1\":{\"102\":1}}],[\"其实差不多\",{\"1\":{\"98\":1}}],[\"其实这部分如果熟悉\",{\"1\":{\"89\":1}}],[\"其实这一步可以放进\",{\"1\":{\"55\":1}}],[\"其实就是初始化这个表里的数据\",{\"1\":{\"119\":1}}],[\"其实就是1级目录\",{\"1\":{\"116\":1}}],[\"其实就是最新的\",{\"1\":{\"115\":1}}],[\"其实就是根据\",{\"1\":{\"112\":1}}],[\"其实就是冲突时前一个结点的\",{\"1\":{\"112\":1}}],[\"其实就是启动\",{\"1\":{\"98\":1}}],[\"其实就是对\",{\"1\":{\"96\":1}}],[\"其实就是自定义的\",{\"1\":{\"83\":1}}],[\"其实就是把\",{\"1\":{\"68\":1}}],[\"其他就是消息格式异常和未知错误\",{\"1\":{\"115\":1}}],[\"其他的什么消费组\",{\"1\":{\"77\":1}}],[\"其他的请求直接进入\",{\"1\":{\"42\":1}}],[\"其他几乎都一样\",{\"1\":{\"60\":1}}],[\"其他情况则返回\",{\"1\":{\"57\":1}}],[\"其他\",{\"1\":{\"40\":1}}],[\"其他组件\",{\"1\":{\"39\":1}}],[\"其他语言等\",{\"1\":{\"13\":1}}],[\"其他更多可以参考该主题的说明文档\",{\"1\":{\"10\":1}}],[\"其他细节参考警告中给的链接\",{\"1\":{\"3\":1}}],[\"其中文件头固定\",{\"1\":{\"112\":1}}],[\"其中\",{\"1\":{\"10\":1,\"108\":1}}],[\"清除缓存并启动开发服务器\",{\"1\":{\"9\":1}}],[\"启动定时任务\",{\"1\":{\"98\":1}}],[\"启动定时任务等等\",{\"1\":{\"83\":1}}],[\"启动失败\",{\"1\":{\"98\":1}}],[\"启动该对象\",{\"1\":{\"83\":1}}],[\"启动前执行\",{\"1\":{\"67\":1}}],[\"启动并主动连接\",{\"1\":{\"63\":1,\"65\":1}}],[\"启动并监听端口\",{\"1\":{\"63\":1,\"64\":1}}],[\"启动阶段初始化\",{\"1\":{\"58\":1}}],[\"启动时\",{\"1\":{\"119\":1}}],[\"启动时也会发送一次\",{\"1\":{\"89\":1}}],[\"启动时会把自身注册到\",{\"1\":{\"80\":1}}],[\"启动时会监听\",{\"1\":{\"63\":1,\"64\":1}}],[\"启动时有三种初始消费位点的选择\",{\"1\":{\"51\":1}}],[\"启动时具体做了什么\",{\"1\":{\"39\":1}}],[\"启动一个单线程定时任务\",{\"1\":{\"39\":1}}],[\"启动一个\",{\"1\":{\"39\":1}}],[\"启动一个守护线程\",{\"1\":{\"39\":2}}],[\"启动\",{\"1\":{\"39\":2,\"55\":1,\"94\":1,\"119\":1}}],[\"启动持久化\",{\"1\":{\"39\":1}}],[\"启动流程就省略了\",{\"1\":{\"65\":1}}],[\"启动流程中没有详细展开的\",{\"1\":{\"64\":1}}],[\"启动流程如果有认真看源码的话\",{\"1\":{\"42\":1}}],[\"启动流程\",{\"0\":{\"39\":1,\"55\":1,\"83\":1}}],[\"启动类\",{\"0\":{\"38\":1}}],[\"启动开发服务器\",{\"1\":{\"9\":1}}],[\"启用该机制后\",{\"1\":{\"120\":1}}],[\"启用\",{\"1\":{\"3\":1}}],[\"使用了\",{\"1\":{\"57\":1}}],[\"使用了线程池配合\",{\"1\":{\"40\":1}}],[\"使用的是\",{\"1\":{\"42\":1}}],[\"使用\",{\"1\":{\"9\":1}}],[\"使用方式通用流程\",{\"1\":{\"7\":1}}],[\"创建一个新文件重新\",{\"1\":{\"115\":1}}],[\"创建一个\",{\"1\":{\"102\":1}}],[\"创建多个\",{\"1\":{\"101\":1}}],[\"创建线程池\",{\"1\":{\"83\":1}}],[\"创建好了\",{\"1\":{\"98\":1}}],[\"创建好\",{\"1\":{\"83\":1}}],[\"创建读写两个线程\",{\"1\":{\"68\":1}}],[\"创建并装配\",{\"1\":{\"56\":1}}],[\"创建\",{\"1\":{\"9\":1,\"55\":1,\"57\":1,\"83\":2,\"87\":1,\"94\":1,\"96\":1,\"98\":3}}],[\"创建出的项目还自带文档\",{\"1\":{\"8\":1}}],[\"点点看\",{\"1\":{\"7\":1}}],[\"右下角会自动出现一个向上的箭头\",{\"1\":{\"7\":1}}],[\"分别执行任务的\",{\"1\":{\"116\":1}}],[\"分配内存\",{\"1\":{\"102\":1}}],[\"分配他应该消费哪些消息\",{\"1\":{\"58\":1}}],[\"分两种情况\",{\"1\":{\"90\":1}}],[\"分析一个类就跟我们自己写一个类的流程差不多\",{\"1\":{\"96\":1}}],[\"分析读写线程的业务逻辑就比较简单了\",{\"1\":{\"68\":1}}],[\"分析源码的笔记测试了一下\",{\"1\":{\"7\":1}}],[\"分布式系统自然需要一个模块来负责\",{\"1\":{\"80\":1}}],[\"分布式\",{\"1\":{\"64\":1,\"116\":1}}],[\"分顺序\",{\"1\":{\"57\":1}}],[\"分钟清理一次过期消息\",{\"1\":{\"55\":1}}],[\"分支判断\",{\"1\":{\"56\":1}}],[\"分支中也只区分了是否为批量发送\",{\"1\":{\"42\":1}}],[\"分支\",{\"1\":{\"42\":1,\"98\":1}}],[\"分开发布\",{\"1\":{\"1\":1}}],[\"拖了个以前写的\",{\"1\":{\"7\":1}}],[\"似乎没有自己的\",{\"1\":{\"116\":1}}],[\"似乎是300行以上触发\",{\"1\":{\"7\":1}}],[\"似乎不好使\",{\"1\":{\"3\":1}}],[\"官方\",{\"1\":{\"45\":1}}],[\"官方没写说明也没写配置\",{\"1\":{\"7\":1}}],[\"官方文档里就有\",{\"1\":{\"5\":1}}],[\"xxxlogicoffset\",{\"1\":{\"116\":1}}],[\"xxx\",{\"1\":{\"116\":2}}],[\"xxservice\",{\"1\":{\"115\":1}}],[\"xml\",{\"0\":{\"37\":1},\"1\":{\"37\":1}}],[\"x\",{\"1\":{\"7\":2,\"45\":1,\"52\":1,\"58\":2,\"64\":1,\"122\":1}}],[\"xdir\",{\"1\":{\"6\":2}}],[\"在它的构造方法里\",{\"1\":{\"116\":1}}],[\"在文件中的起始位置就是下标\",{\"1\":{\"111\":1}}],[\"在这里是逻辑位置\",{\"1\":{\"116\":1}}],[\"在这里相当于是\",{\"1\":{\"111\":1}}],[\"在这里数据都是加密的数据流的形式\",{\"1\":{\"67\":1}}],[\"在不同的消费模式\",{\"1\":{\"77\":1}}],[\"在创建\",{\"1\":{\"64\":1}}],[\"在循环外\",{\"1\":{\"56\":1}}],[\"在消息队列语境下\",{\"1\":{\"46\":1}}],[\"在asyncputmessage\",{\"1\":{\"42\":1}}],[\"在传统\",{\"1\":{\"41\":1}}],[\"在启动时会把自己的\",{\"1\":{\"40\":1}}],[\"在依赖中引入了相当多的模块\",{\"1\":{\"37\":1}}],[\"在io那一步中继日志写入完成就给主库发个确认消息\",{\"1\":{\"22\":1}}],[\"在\",{\"1\":{\"7\":1,\"30\":1,\"42\":1,\"46\":2,\"58\":2,\"64\":1,\"69\":1,\"102\":1,\"111\":2,\"112\":1,\"115\":1}}],[\"安装插件\",{\"1\":{\"7\":1}}],[\"找出对应的\",{\"1\":{\"116\":1}}],[\"找对应的\",{\"1\":{\"84\":1}}],[\"找\",{\"1\":{\"69\":1,\"84\":1}}],[\"找插件\",{\"1\":{\"7\":1}}],[\"找到最新一条格式正确的消息的记录\",{\"1\":{\"119\":1}}],[\"找到对应的\",{\"1\":{\"69\":1}}],[\"找到哪个\",{\"1\":{\"57\":1}}],[\"找到\",{\"1\":{\"3\":1,\"84\":1,\"91\":1,\"112\":1}}],[\"都做了什么之后\",{\"1\":{\"99\":1}}],[\"都没有\",{\"1\":{\"89\":2}}],[\"都没啥区别\",{\"1\":{\"6\":1}}],[\"都会用到\",{\"1\":{\"67\":1}}],[\"都会有\",{\"1\":{\"59\":1}}],[\"都分散到其他章节里去了\",{\"1\":{\"64\":1}}],[\"都只管从\",{\"1\":{\"58\":1}}],[\"都有了\",{\"1\":{\"56\":1}}],[\"都统一看作是消费者\",{\"1\":{\"47\":1}}],[\"都是线程\",{\"1\":{\"115\":1}}],[\"都是创建请求\",{\"1\":{\"115\":1}}],[\"都是从routeinfomanager\",{\"1\":{\"90\":1}}],[\"都是为了保证当前消息一定要被消费\",{\"1\":{\"56\":1}}],[\"都是单独的模块\",{\"1\":{\"43\":1}}],[\"都是\",{\"1\":{\"42\":1,\"55\":1,\"57\":1,\"89\":2,\"112\":1,\"116\":1}}],[\"都是用\",{\"1\":{\"6\":1}}],[\"都值得单独创建一个类\",{\"1\":{\"41\":1}}],[\"都放在\",{\"1\":{\"41\":1,\"89\":1}}],[\"和属性长度\",{\"1\":{\"115\":1}}],[\"和属于该集群的所有\",{\"1\":{\"88\":1}}],[\"和本地路由信息表\",{\"1\":{\"98\":1}}],[\"和其对应的存活信息\",{\"1\":{\"88\":1}}],[\"和其内部实现类\",{\"1\":{\"54\":1}}],[\"和它对应的\",{\"1\":{\"88\":1}}],[\"和自身所对应的\",{\"1\":{\"88\":1}}],[\"和线程任务\",{\"1\":{\"56\":1}}],[\"和各种\",{\"1\":{\"55\":1}}],[\"和\",{\"1\":{\"6\":1,\"13\":3,\"23\":1,\"26\":1,\"40\":2,\"42\":2,\"47\":1,\"48\":1,\"55\":1,\"56\":2,\"57\":2,\"65\":1,\"67\":3,\"68\":1,\"69\":1,\"87\":1,\"89\":1,\"96\":1,\"98\":3,\"99\":1,\"101\":1,\"103\":3,\"111\":1,\"112\":3,\"115\":1,\"116\":4}}],[\"还不存在\",{\"1\":{\"103\":1}}],[\"还给了用例\",{\"1\":{\"67\":1}}],[\"还在就会进入这里\",{\"1\":{\"66\":1}}],[\"还记得前面启动流程中注释了重点的\",{\"1\":{\"57\":1}}],[\"还支持顺序消费和并发消费\",{\"1\":{\"46\":1}}],[\"还是\",{\"1\":{\"80\":1,\"112\":1,\"115\":1}}],[\"还是先看\",{\"1\":{\"67\":1}}],[\"还是这里的\",{\"1\":{\"66\":1}}],[\"还是老样子\",{\"1\":{\"44\":1}}],[\"还是用\",{\"1\":{\"6\":1}}],[\"还有可能保留一部分数据\",{\"1\":{\"120\":1}}],[\"还有最后一步恢复\",{\"1\":{\"119\":1}}],[\"还有\",{\"1\":{\"42\":1}}],[\"还有一个方法的逻辑要看\",{\"1\":{\"67\":1}}],[\"还有一个\",{\"1\":{\"39\":1}}],[\"还可以\",{\"1\":{\"26\":1}}],[\"还没想好怎么更\",{\"1\":{\"13\":1}}],[\"还挺全的\",{\"1\":{\"5\":1}}],[\"用的\",{\"1\":{\"67\":1,\"98\":1}}],[\"用来存\",{\"1\":{\"102\":1}}],[\"用来算超时的各种时间戳变量\",{\"1\":{\"101\":1}}],[\"用来监听\",{\"1\":{\"67\":1}}],[\"用来与其他服务通信\",{\"1\":{\"39\":1}}],[\"用于供给给消费端进行消费\",{\"1\":{\"108\":1}}],[\"用于清理无效请求\",{\"1\":{\"39\":1}}],[\"用于向外部发送请求\",{\"1\":{\"39\":1}}],[\"用\",{\"1\":{\"6\":1}}],[\"用法跟之前一样\",{\"1\":{\"3\":1}}],[\"elapsed\",{\"1\":{\"115\":1}}],[\"elapsedtime\",{\"1\":{\"115\":4}}],[\"else\",{\"1\":{\"42\":1,\"55\":2,\"57\":7,\"66\":1,\"67\":1,\"69\":2,\"71\":1,\"84\":1,\"89\":3,\"101\":5,\"103\":1,\"115\":4,\"116\":1}}],[\"erase\",{\"1\":{\"110\":1}}],[\"error\",{\"1\":{\"39\":1,\"57\":5,\"58\":1,\"71\":2,\"84\":2,\"89\":2,\"96\":1,\"116\":1}}],[\"every\",{\"1\":{\"110\":1}}],[\"eureka\",{\"1\":{\"80\":1}}],[\"equals\",{\"1\":{\"57\":4,\"84\":2,\"89\":1,\"98\":1}}],[\"encodemessage\",{\"1\":{\"102\":1}}],[\"encodemessages\",{\"1\":{\"102\":2}}],[\"encodedmessages\",{\"1\":{\"102\":4}}],[\"encoder\",{\"1\":{\"89\":2}}],[\"encode\",{\"1\":{\"59\":1,\"67\":2,\"68\":1,\"101\":1,\"102\":8}}],[\"entry<long\",{\"1\":{\"84\":1,\"89\":1}}],[\"entry<string\",{\"1\":{\"58\":1,\"84\":4,\"89\":1}}],[\"entryset\",{\"1\":{\"58\":1,\"84\":6,\"89\":2}}],[\"entry\",{\"1\":{\"58\":2,\"84\":12,\"89\":3}}],[\"endphyoffset\",{\"1\":{\"112\":1}}],[\"endtransactionhooklist\",{\"1\":{\"103\":1}}],[\"endtimestamp\",{\"1\":{\"101\":15,\"112\":1}}],[\"end\",{\"1\":{\"57\":1,\"66\":1,\"110\":1,\"112\":1,\"115\":1}}],[\"env\",{\"1\":{\"6\":3}}],[\"e\",{\"1\":{\"39\":2,\"57\":11,\"58\":4,\"66\":2,\"71\":2,\"84\":4,\"89\":2,\"94\":2,\"97\":2,\"101\":15,\"102\":2,\"116\":2}}],[\"ext\",{\"1\":{\"117\":1}}],[\"externals\",{\"1\":{\"103\":1}}],[\"extensible\",{\"1\":{\"31\":1}}],[\"extends\",{\"1\":{\"30\":1,\"57\":1}}],[\"expectlogicoffset\",{\"1\":{\"116\":7}}],[\"expired\",{\"1\":{\"66\":1,\"84\":5}}],[\"export\",{\"1\":{\"3\":1}}],[\"exist\",{\"1\":{\"58\":1,\"96\":1,\"101\":1}}],[\"exception\",{\"1\":{\"39\":2,\"57\":6,\"58\":2,\"64\":1,\"66\":2,\"84\":4,\"89\":2,\"94\":1,\"101\":20,\"102\":1}}],[\"exchanger\",{\"1\":{\"23\":1,\"27\":1}}],[\"executetasklater\",{\"1\":{\"57\":2}}],[\"executepullrequestlater\",{\"1\":{\"57\":8}}],[\"executepullrequestimmediately\",{\"1\":{\"57\":8}}],[\"execute\",{\"1\":{\"30\":2}}],[\"executers\",{\"1\":{\"23\":1}}],[\"executorcompletionservice\",{\"1\":{\"31\":1}}],[\"executors\",{\"1\":{\"31\":3,\"57\":1,\"84\":1,\"103\":1}}],[\"executorservice\",{\"1\":{\"23\":2,\"30\":3,\"103\":3}}],[\"executor\",{\"0\":{\"30\":1},\"1\":{\"23\":3,\"24\":1,\"30\":5,\"42\":1,\"103\":3}}],[\"yarn\",{\"1\":{\"6\":2}}],[\"yourself\",{\"1\":{\"3\":1}}],[\"you\",{\"1\":{\"3\":1}}],[\"||\",{\"1\":{\"57\":2,\"89\":2,\"103\":2,\"115\":2,\"116\":1}}],[\"|\",{\"1\":{\"6\":1,\"41\":1}}],[\"否则你点击导航会\",{\"1\":{\"6\":1}}],[\"等下次提交\",{\"1\":{\"115\":1}}],[\"等相关知识\",{\"1\":{\"114\":1}}],[\"等信息都由\",{\"1\":{\"81\":1}}],[\"等待\",{\"1\":{\"63\":1,\"64\":1}}],[\"等讲完持久化章节就很容易理解了\",{\"1\":{\"42\":1}}],[\"等等\",{\"1\":{\"23\":1,\"37\":1,\"110\":1}}],[\"等\",{\"1\":{\"23\":1}}],[\"等同于\",{\"1\":{\"6\":1}}],[\"等小马哥有空的\",{\"1\":{\"3\":2}}],[\"与常见的\",{\"1\":{\"80\":1}}],[\"与高可用模式不兼容\",{\"1\":{\"64\":1}}],[\"与此同时\",{\"1\":{\"46\":1}}],[\"与\",{\"1\":{\"6\":1,\"39\":1,\"68\":1,\"71\":1,\"77\":1,\"80\":1,\"88\":1,\"108\":1,\"112\":1}}],[\"有了\",{\"1\":{\"112\":2}}],[\"有了大体认识之后我们来挨个看细节\",{\"1\":{\"82\":1}}],[\"有10个构造方法\",{\"1\":{\"96\":1}}],[\"有兴趣的话可以从\",{\"1\":{\"103\":1}}],[\"有兴趣的话可以按照之前分析\",{\"1\":{\"90\":1}}],[\"有兴趣可以先看一下后面的\",{\"1\":{\"115\":1}}],[\"有兴趣可以在自己的\",{\"1\":{\"89\":1}}],[\"有兴趣可以自己去看\",{\"1\":{\"58\":1,\"66\":2}}],[\"有兴趣可以自己看一下\",{\"1\":{\"103\":1}}],[\"有兴趣可以自己看\",{\"1\":{\"56\":1}}],[\"有三个子类\",{\"1\":{\"58\":1}}],[\"有三种实现方法\",{\"1\":{\"55\":1}}],[\"有图\",{\"1\":{\"45\":1}}],[\"有点儿类似\",{\"1\":{\"42\":1}}],[\"有个大概认识即可\",{\"1\":{\"35\":1}}],[\"有\",{\"1\":{\"6\":1}}],[\"有前端经验很好\",{\"1\":{\"6\":1}}],[\"有开发经验的体验尚可\",{\"1\":{\"6\":1}}],[\"000\",{\"1\":{\"110\":1}}],[\"00000000000000000000\",{\"1\":{\"109\":5}}],[\"0l\",{\"1\":{\"57\":1,\"87\":2,\"88\":1,\"116\":2}}],[\"0\",{\"1\":{\"7\":1,\"57\":6,\"64\":3,\"67\":2,\"68\":1,\"69\":1,\"73\":1,\"84\":1,\"89\":3,\"94\":1,\"101\":2,\"102\":3,\"103\":1,\"109\":1,\"111\":3,\"112\":1,\"115\":3,\"116\":6,\"119\":2}}],[\"0开发经验上手略有门槛\",{\"1\":{\"6\":1}}],[\"09\",{\"1\":{\"3\":1}}],[\"但它完全没有提供根据\",{\"1\":{\"110\":1}}],[\"但它不是\",{\"1\":{\"26\":1}}],[\"但结论一致\",{\"1\":{\"110\":1}}],[\"但可靠性最低\",{\"1\":{\"107\":1}}],[\"但这是可以接受的\",{\"1\":{\"80\":1}}],[\"但这里直接设置成了\",{\"1\":{\"64\":1}}],[\"但实际上只是简单的路由信息的管理模块\",{\"1\":{\"76\":1}}],[\"但实际上\",{\"1\":{\"67\":1,\"77\":1}}],[\"但并不强制\",{\"1\":{\"6\":1}}],[\"但是吧\",{\"1\":{\"116\":1}}],[\"但是要注意\",{\"1\":{\"112\":1}}],[\"但是性能相对前两者最差\",{\"1\":{\"107\":1}}],[\"但是请求参数\",{\"1\":{\"89\":1}}],[\"但是消费短期内是不受影响的\",{\"1\":{\"70\":1}}],[\"但是你指针现在在读的位置\",{\"1\":{\"67\":1}}],[\"但是\",{\"1\":{\"3\":1,\"6\":1,\"80\":1,\"98\":1,\"116\":1}}],[\"但是百度检测不到\",{\"1\":{\"3\":1}}],[\"+1\",{\"1\":{\"112\":1}}],[\"+20\",{\"1\":{\"111\":1}}],[\"+=\",{\"1\":{\"101\":1,\"102\":2}}],[\"+\",{\"1\":{\"5\":1,\"13\":3,\"42\":2,\"52\":1,\"55\":2,\"56\":2,\"57\":8,\"64\":3,\"66\":6,\"67\":2,\"84\":3,\"88\":1,\"98\":6,\"101\":3,\"102\":2,\"103\":2,\"110\":6,\"111\":1,\"112\":7,\"115\":1,\"116\":11}}],[\"白写了\",{\"1\":{\"5\":1}}],[\"权限要够\",{\"1\":{\"5\":1}}],[\"权限是不是不够\",{\"1\":{\"4\":1}}],[\"权限错误检查两个位置\",{\"1\":{\"4\":1}}],[\"绕过缓存\",{\"1\":{\"4\":1}}],[\"前文介绍\",{\"1\":{\"116\":1}}],[\"前文一直说消息写完\",{\"1\":{\"116\":1}}],[\"前文说的\",{\"1\":{\"115\":1}}],[\"前文中反复出现的\",{\"1\":{\"114\":1}}],[\"前文中提到由于\",{\"1\":{\"81\":1}}],[\"前文\",{\"1\":{\"80\":1}}],[\"前文提到了\",{\"1\":{\"69\":1}}],[\"前置要求\",{\"0\":{\"78\":1,\"92\":1}}],[\"前两个大章节介绍了\",{\"1\":{\"70\":1}}],[\"前面提到的线程基本都是它来创建和启动\",{\"1\":{\"116\":1}}],[\"前面那个\",{\"1\":{\"115\":1}}],[\"前面已经提到\",{\"1\":{\"111\":1}}],[\"前面已经看到了\",{\"1\":{\"56\":1}}],[\"前面说的\",{\"1\":{\"110\":1}}],[\"前面说过\",{\"1\":{\"101\":1}}],[\"前面说了\",{\"1\":{\"87\":1,\"98\":1}}],[\"前面看\",{\"1\":{\"101\":1}}],[\"前面\",{\"1\":{\"96\":1,\"115\":1}}],[\"前面在简介里面说了\",{\"1\":{\"91\":1}}],[\"前面在消费篇里提过\",{\"1\":{\"69\":1}}],[\"前面控流的部分可以不看\",{\"1\":{\"57\":1}}],[\"前面发送消息篇\",{\"1\":{\"41\":1}}],[\"前面二者的加强版\",{\"1\":{\"23\":1}}],[\"前缀\",{\"1\":{\"26\":1}}],[\"前期主要更新\",{\"1\":{\"13\":1}}],[\"前后重新发布了\",{\"1\":{\"4\":1}}],[\"前端开发是怎么忍下来的\",{\"1\":{\"3\":1}}],[\"关闭后触发的方法\",{\"1\":{\"84\":1}}],[\"关闭\",{\"1\":{\"66\":2,\"94\":1}}],[\"关闭右侧目录的打印按钮\",{\"1\":{\"3\":1}}],[\"关于\",{\"1\":{\"55\":1,\"73\":1}}],[\"关缓存\",{\"1\":{\"4\":1}}],[\"然鹅这里不知道为何就这么直接调用了\",{\"1\":{\"84\":1}}],[\"然后用异步的方式提交给\",{\"1\":{\"120\":1}}],[\"然后设置\",{\"1\":{\"119\":1}}],[\"然后还没有注释解释原因\",{\"1\":{\"116\":1}}],[\"然后这个\",{\"1\":{\"116\":1}}],[\"然后去和\",{\"1\":{\"115\":1}}],[\"然后放入\",{\"1\":{\"115\":1}}],[\"然后提交给\",{\"1\":{\"115\":1}}],[\"然后来到\",{\"1\":{\"115\":1}}],[\"然后来看它的俩属性\",{\"1\":{\"68\":1}}],[\"然后来看一下\",{\"1\":{\"66\":1,\"67\":1}}],[\"然后来看主角\",{\"1\":{\"64\":1}}],[\"然后来看第二部分\",{\"1\":{\"57\":1}}],[\"然后来看\",{\"1\":{\"42\":1,\"55\":1,\"58\":1,\"69\":1,\"111\":1}}],[\"然后回到\",{\"1\":{\"112\":1}}],[\"然后对\",{\"1\":{\"112\":2}}],[\"然后我们来介绍下\",{\"1\":{\"110\":1}}],[\"然后我们来看代码\",{\"1\":{\"98\":1}}],[\"然后我们来看\",{\"1\":{\"55\":1,\"116\":1}}],[\"然后具体到\",{\"1\":{\"106\":1}}],[\"然后存放到msgbatch\",{\"1\":{\"102\":1}}],[\"然后存入\",{\"1\":{\"57\":1}}],[\"然后开始检查配置\",{\"1\":{\"98\":1}}],[\"然后再关闭\",{\"1\":{\"119\":1}}],[\"然后再去看他的代码\",{\"1\":{\"115\":1}}],[\"然后再去看他的功能\",{\"1\":{\"96\":1}}],[\"然后再执行\",{\"1\":{\"58\":1}}],[\"然后发送消息\",{\"1\":{\"94\":1}}],[\"然后发送请求依然是有同步异步两种方式\",{\"1\":{\"59\":1}}],[\"然后才能确定\",{\"1\":{\"91\":1}}],[\"然后重走一次注册流程即可\",{\"1\":{\"89\":1}}],[\"然后根据请求类型转发给后续处理方法\",{\"1\":{\"89\":1}}],[\"然后根据路由信息找到对应的\",{\"1\":{\"76\":1}}],[\"然后手动实践一下\",{\"1\":{\"89\":1}}],[\"然后就可以判断请求类型了\",{\"1\":{\"89\":1}}],[\"然后就来到了\",{\"1\":{\"57\":1}}],[\"然后你自然会发现\",{\"1\":{\"84\":1}}],[\"然后打印关闭日志\",{\"1\":{\"84\":1}}],[\"然后把\",{\"1\":{\"102\":1}}],[\"然后把相关信息塞进\",{\"1\":{\"69\":1}}],[\"然后把对象的值传给\",{\"1\":{\"55\":1}}],[\"然后调用\",{\"1\":{\"68\":1}}],[\"然后在磁道中读写\",{\"1\":{\"110\":1}}],[\"然后在\",{\"1\":{\"64\":1}}],[\"然后按照\",{\"1\":{\"59\":1}}],[\"然后每个消费者按\",{\"1\":{\"58\":1}}],[\"然后负载均衡器就要给\",{\"1\":{\"58\":1}}],[\"然后直接\",{\"1\":{\"57\":1}}],[\"然后直接提交\",{\"1\":{\"56\":1}}],[\"然后经过了哪些处理\",{\"1\":{\"56\":1}}],[\"然后\",{\"1\":{\"55\":1,\"115\":1,\"116\":1}}],[\"然后介绍消费相关的分类\",{\"1\":{\"44\":1}}],[\"然后判断是否为高可用模式\",{\"1\":{\"40\":1}}],[\"然后使用\",{\"1\":{\"40\":1}}],[\"然后启动该客户端\",{\"1\":{\"98\":1}}],[\"然后启动\",{\"1\":{\"39\":1}}],[\"然后创建\",{\"1\":{\"39\":1}}],[\"然后执行\",{\"1\":{\"23\":1,\"58\":1,\"101\":1}}],[\"然后从库从中继日志中读取并执行其中的\",{\"1\":{\"19\":1}}],[\"然后通过io把\",{\"1\":{\"19\":1}}],[\"然后是访问速读\",{\"1\":{\"108\":1}}],[\"然后是消息的批量处理\",{\"1\":{\"56\":1}}],[\"然后是\",{\"1\":{\"13\":1}}],[\"然后编辑\",{\"1\":{\"6\":1}}],[\"然后添加searchpro\",{\"1\":{\"3\":1}}],[\"然而\",{\"1\":{\"3\":1}}],[\"错误的表面意思倒是挺明确的\",{\"1\":{\"3\":1}}],[\"的异常\",{\"1\":{\"120\":1}}],[\"的最后一个文件\",{\"1\":{\"119\":1}}],[\"的第一件事是先恢复\",{\"1\":{\"119\":1}}],[\"的恢复流程省略\",{\"1\":{\"119\":1}}],[\"的意思大概是\",{\"1\":{\"116\":1}}],[\"的数据都是可以从\",{\"1\":{\"116\":1}}],[\"的数据\",{\"1\":{\"115\":1,\"119\":1}}],[\"的数据包\",{\"1\":{\"89\":1}}],[\"的概念\",{\"1\":{\"115\":1}}],[\"的概念是不区分\",{\"1\":{\"98\":1}}],[\"的线程间隔默认是\",{\"1\":{\"115\":1}}],[\"的线程\",{\"1\":{\"115\":1}}],[\"的一定是\",{\"1\":{\"115\":1}}],[\"的逻辑位置\",{\"1\":{\"112\":1}}],[\"的逻辑值是\",{\"1\":{\"64\":1}}],[\"的总数\",{\"1\":{\"112\":1}}],[\"的存储时间\",{\"1\":{\"112\":1}}],[\"的基础功能基本齐活儿了\",{\"1\":{\"112\":1}}],[\"的基本概念\",{\"1\":{\"87\":1}}],[\"的基本组成介绍\",{\"0\":{\"81\":1}}],[\"的基本要素已经凑齐\",{\"1\":{\"56\":1}}],[\"的基本信息\",{\"1\":{\"40\":1}}],[\"的设计之后我们来看它为消费消息带来了什么变化\",{\"1\":{\"111\":1}}],[\"的设置和更新也是随注册触发\",{\"1\":{\"40\":1}}],[\"的整数倍\",{\"1\":{\"111\":1}}],[\"的定长\",{\"1\":{\"111\":1}}],[\"的做法相当于是给\",{\"1\":{\"111\":1}}],[\"的卖点是基于消息主题\",{\"1\":{\"110\":1}}],[\"的功能\",{\"1\":{\"110\":1}}],[\"的次序顺序写入\",{\"1\":{\"110\":1}}],[\"的另一个特点是读的速读远大于写\",{\"1\":{\"110\":1}}],[\"的优势除了天然比传统机械硬盘更快之外\",{\"1\":{\"110\":1}}],[\"的底层逻辑\",{\"1\":{\"110\":1}}],[\"的关系\",{\"1\":{\"108\":1}}],[\"的自研文件系统\",{\"1\":{\"108\":1}}],[\"的领域\",{\"1\":{\"108\":1}}],[\"的持久化设计\",{\"0\":{\"108\":1}}],[\"的源码是真的很难读\",{\"1\":{\"104\":1}}],[\"的源码分析告一段落\",{\"1\":{\"101\":1}}],[\"的参数\",{\"1\":{\"102\":1}}],[\"的合法性\",{\"1\":{\"101\":1}}],[\"的过程\",{\"1\":{\"98\":1}}],[\"的角色还不明确\",{\"1\":{\"98\":1}}],[\"的角色和功能\",{\"1\":{\"79\":1}}],[\"的形式\",{\"1\":{\"98\":1}}],[\"的状态\",{\"1\":{\"98\":1}}],[\"的构造方法中都没有修改该属性的操作\",{\"1\":{\"98\":1}}],[\"的构造方法其实就是创建一个\",{\"1\":{\"68\":1}}],[\"的大小超过\",{\"1\":{\"96\":1}}],[\"的实例\",{\"1\":{\"95\":1}}],[\"的实现要对应\",{\"1\":{\"58\":1}}],[\"的实现\",{\"1\":{\"53\":1,\"60\":1}}],[\"的处理逻辑是一致的\",{\"1\":{\"90\":1}}],[\"的习惯是把\",{\"1\":{\"89\":1}}],[\"的信息存入本地的\",{\"1\":{\"98\":1}}],[\"的信息是否存在\",{\"1\":{\"89\":1}}],[\"的信息\",{\"1\":{\"89\":1}}],[\"的信息列表\",{\"1\":{\"88\":1}}],[\"的信息注册到\",{\"1\":{\"39\":1}}],[\"的相关信息\",{\"1\":{\"84\":1}}],[\"的不同状态上去调用\",{\"1\":{\"84\":1}}],[\"的对应信息\",{\"1\":{\"84\":2}}],[\"的对象\",{\"1\":{\"83\":2}}],[\"的路由表\",{\"1\":{\"88\":1}}],[\"的路由注册表发生变化时并不会通知消息生产者\",{\"1\":{\"81\":1}}],[\"的路由信息不存在\",{\"1\":{\"103\":1}}],[\"的路由信息的\",{\"1\":{\"103\":1}}],[\"的路由信息\",{\"1\":{\"91\":1,\"98\":1,\"103\":1}}],[\"的路由信息也会自动上报到\",{\"1\":{\"77\":1}}],[\"的路由信息都存在这里\",{\"1\":{\"77\":1}}],[\"的服务端\",{\"1\":{\"81\":1}}],[\"的消息不是第一条消息\",{\"1\":{\"116\":1}}],[\"的消息不均匀\",{\"1\":{\"80\":1}}],[\"的消费者组成\",{\"1\":{\"48\":1}}],[\"的特点之一\",{\"1\":{\"80\":1}}],[\"的哪个\",{\"1\":{\"80\":1}}],[\"的本地部署\",{\"1\":{\"78\":1}}],[\"的时候\",{\"1\":{\"77\":1}}],[\"的时候都更新订阅关系\",{\"1\":{\"57\":1}}],[\"的文章大概就是找个合适的时间把\",{\"1\":{\"73\":1}}],[\"的文章至此也就暂时告一段落啦\",{\"1\":{\"73\":1}}],[\"的文件系统设计\",{\"1\":{\"42\":1}}],[\"的阈值\",{\"1\":{\"69\":2}}],[\"的位置\",{\"1\":{\"67\":1}}],[\"的读写状态切换功能\",{\"1\":{\"67\":1}}],[\"的拉取请求后\",{\"1\":{\"67\":1}}],[\"的其他内容\",{\"1\":{\"67\":1}}],[\"的同步状态\",{\"1\":{\"67\":1}}],[\"的返回\",{\"1\":{\"67\":1}}],[\"的进度\",{\"1\":{\"67\":1}}],[\"的话就挺简单的\",{\"1\":{\"89\":1}}],[\"的话\",{\"1\":{\"65\":1}}],[\"的下篇都没啥可写的了\",{\"1\":{\"64\":1}}],[\"的代码中找到如下方法自行分析\",{\"1\":{\"90\":1}}],[\"的代码\",{\"1\":{\"63\":1}}],[\"的代码分成了三个部分\",{\"1\":{\"57\":1}}],[\"的连接\",{\"1\":{\"63\":1,\"64\":1}}],[\"的主从同步和主从切换\",{\"1\":{\"70\":1}}],[\"的主从同步\",{\"1\":{\"62\":1}}],[\"的主从同步实际上就是\",{\"1\":{\"62\":1}}],[\"的主要工作就是监视\",{\"1\":{\"67\":1}}],[\"的主要工作就是从\",{\"1\":{\"57\":1}}],[\"的主要工作首先是将收到的消息写入\",{\"1\":{\"42\":1}}],[\"的高可用就挺特别\",{\"1\":{\"61\":1}}],[\"的高可用也就是\",{\"1\":{\"60\":1}}],[\"的高可用模式\",{\"1\":{\"40\":1}}],[\"的属性字段\",{\"1\":{\"116\":1}}],[\"的属性\",{\"1\":{\"57\":1}}],[\"的属性和基础方法\",{\"1\":{\"57\":1}}],[\"的工作就是这里处理的\",{\"1\":{\"84\":1}}],[\"的工作就是不停的从\",{\"1\":{\"57\":1}}],[\"的工作队列的呢\",{\"1\":{\"56\":1}}],[\"的值如下\",{\"1\":{\"119\":1}}],[\"的值是哪来的\",{\"1\":{\"69\":1}}],[\"的值来自\",{\"1\":{\"69\":1}}],[\"的值\",{\"1\":{\"56\":1,\"57\":1,\"64\":1,\"67\":1,\"69\":1,\"119\":1}}],[\"的具体类型取决于上面的代码\",{\"1\":{\"55\":1}}],[\"的包装器\",{\"1\":{\"55\":1}}],[\"的方式\",{\"1\":{\"50\":1}}],[\"的组装等等\",{\"1\":{\"42\":1}}],[\"的解码\",{\"1\":{\"42\":1}}],[\"的命名方式\",{\"1\":{\"41\":1}}],[\"的搜索功能直接在\",{\"1\":{\"41\":1}}],[\"的检查和更新\",{\"1\":{\"40\":1}}],[\"的地址\",{\"1\":{\"40\":1,\"84\":1}}],[\"的启动就是读取配置\",{\"1\":{\"39\":1}}],[\"的核心类了\",{\"1\":{\"116\":1}}],[\"的核心功能就是消息的接受\",{\"1\":{\"75\":1}}],[\"的核心方法在前面分析流程的时候已经解释的差不多了\",{\"1\":{\"67\":1}}],[\"的核心\",{\"1\":{\"36\":1}}],[\"的区别就是它是自己主动去拉取消息\",{\"1\":{\"60\":1}}],[\"的区别\",{\"1\":{\"26\":1,\"110\":1,\"111\":1}}],[\"的\",{\"0\":{\"37\":1},\"1\":{\"26\":1,\"37\":1,\"41\":1,\"56\":3,\"57\":3,\"58\":1,\"61\":1,\"62\":1,\"64\":2,\"65\":1,\"66\":1,\"67\":3,\"69\":2,\"84\":1,\"87\":1,\"88\":2,\"89\":2,\"98\":1,\"101\":2,\"103\":1,\"111\":2,\"112\":3,\"116\":1}}],[\"的锁实现\",{\"1\":{\"23\":1}}],[\"的内容放上来\",{\"1\":{\"73\":1}}],[\"的内容\",{\"1\":{\"67\":1,\"101\":1}}],[\"的内容写入从库的中继日志中\",{\"1\":{\"19\":1}}],[\"的内容也单独更新\",{\"1\":{\"13\":1}}],[\"的演进\",{\"1\":{\"13\":1}}],[\"的机会\",{\"1\":{\"12\":1}}],[\"的权限\",{\"1\":{\"4\":1}}],[\"的缓存没关\",{\"1\":{\"4\":1}}],[\"的错误\",{\"1\":{\"3\":1}}],[\"的版本迭代线\",{\"1\":{\"13\":1}}],[\"的版本\",{\"1\":{\"3\":1,\"7\":1}}],[\"nsscheduledthread\",{\"1\":{\"84\":1}}],[\"nacos\",{\"1\":{\"80\":1}}],[\"namespaceutil\",{\"1\":{\"103\":1}}],[\"namespace\",{\"1\":{\"89\":1,\"96\":3,\"101\":1}}],[\"nameserver\",{\"1\":{\"77\":3,\"80\":1,\"103\":1}}],[\"namesrvutil\",{\"1\":{\"89\":1}}],[\"namesrvstartup\",{\"1\":{\"83\":1}}],[\"namesrvcontroller\",{\"1\":{\"81\":1,\"83\":3,\"84\":2,\"89\":2}}],[\"namesrv\",{\"0\":{\"40\":1,\"79\":1,\"81\":1},\"1\":{\"35\":1,\"39\":2,\"40\":5,\"41\":1,\"55\":1,\"76\":6,\"79\":2,\"80\":8,\"81\":4,\"82\":1,\"84\":2,\"86\":1,\"88\":1,\"89\":7,\"90\":5,\"91\":1,\"96\":1}}],[\"name\",{\"1\":{\"55\":1,\"98\":2,\"110\":1,\"112\":3}}],[\"named\",{\"1\":{\"3\":1}}],[\"nio\",{\"1\":{\"64\":1,\"65\":1,\"66\":1,\"84\":1}}],[\"null的\",{\"1\":{\"115\":1}}],[\"null\",{\"1\":{\"39\":10,\"42\":1,\"55\":3,\"57\":12,\"58\":11,\"65\":5,\"69\":2,\"71\":4,\"84\":7,\"89\":15,\"96\":1,\"97\":1,\"98\":2,\"101\":13,\"103\":1,\"115\":4,\"116\":1}}],[\"nextlong\",{\"1\":{\"101\":1}}],[\"next\",{\"1\":{\"84\":13,\"89\":1}}],[\"nextbeginoffset\",{\"1\":{\"57\":1}}],[\"nextoffset\",{\"1\":{\"57\":2}}],[\"newfile\",{\"1\":{\"115\":1}}],[\"newthread\",{\"1\":{\"103\":1}}],[\"newvalue\",{\"1\":{\"67\":1}}],[\"newoffset\",{\"1\":{\"57\":2}}],[\"newsinglethreadscheduledexecutor\",{\"1\":{\"57\":1,\"84\":1,\"103\":1}}],[\"new\",{\"1\":{\"26\":2,\"39\":1,\"55\":6,\"56\":3,\"57\":4,\"58\":5,\"67\":2,\"69\":1,\"71\":1,\"84\":1,\"89\":8,\"94\":2,\"96\":2,\"98\":4,\"101\":5,\"102\":3,\"103\":16,\"110\":1,\"115\":6,\"116\":3}}],[\"nettyremotingabstract\",{\"1\":{\"103\":1}}],[\"netty语境\",{\"1\":{\"89\":1}}],[\"nettyserver\",{\"1\":{\"83\":3,\"89\":1}}],[\"nettyserverconfig\",{\"1\":{\"64\":2}}],[\"netty\",{\"1\":{\"13\":1,\"37\":1,\"39\":8,\"41\":4,\"43\":1,\"54\":1,\"55\":2,\"57\":1,\"59\":2,\"65\":1,\"66\":1,\"67\":3,\"81\":3,\"84\":3,\"89\":10,\"94\":1,\"98\":4,\"101\":3,\"103\":1}}],[\"n\",{\"1\":{\"4\":1,\"52\":1,\"57\":1,\"94\":1}}],[\"noise\",{\"1\":{\"115\":1}}],[\"now\",{\"1\":{\"66\":1,\"67\":2,\"115\":2}}],[\"no\",{\"1\":{\"42\":1,\"57\":3,\"84\":1,\"96\":2,\"101\":2}}],[\"nosql\",{\"1\":{\"13\":1}}],[\"nodejs\",{\"1\":{\"6\":1}}],[\"node\",{\"1\":{\"3\":7,\"6\":4}}],[\"notify\",{\"1\":{\"116\":2}}],[\"notifytransfersome\",{\"1\":{\"67\":5,\"68\":1}}],[\"notifytransferobject\",{\"1\":{\"67\":1}}],[\"notifyme\",{\"1\":{\"57\":1}}],[\"nothing\",{\"1\":{\"58\":1}}],[\"note\",{\"1\":{\"23\":1}}],[\"not\",{\"1\":{\"3\":2,\"55\":3,\"57\":1,\"58\":1,\"66\":1,\"89\":1,\"96\":3,\"98\":2,\"101\":2,\"115\":1,\"116\":2,\"123\":1}}],[\"rt\",{\"1\":{\"101\":4}}],[\"rather\",{\"1\":{\"110\":1}}],[\"ratio\",{\"1\":{\"69\":2}}],[\"random\",{\"1\":{\"101\":1,\"103\":3,\"110\":5}}],[\"r\",{\"1\":{\"57\":2,\"103\":4}}],[\"rpchook\",{\"1\":{\"55\":1,\"96\":3,\"98\":1,\"103\":6}}],[\"runtime\",{\"1\":{\"103\":2}}],[\"running\",{\"1\":{\"55\":3,\"98\":2,\"101\":1}}],[\"runnable\",{\"1\":{\"23\":2,\"30\":1,\"39\":1,\"71\":1,\"103\":1}}],[\"run\",{\"1\":{\"39\":1,\"56\":3,\"57\":3,\"58\":1,\"65\":1,\"66\":3,\"67\":3,\"71\":1,\"115\":1}}],[\"rollback\",{\"1\":{\"116\":1}}],[\"role\",{\"1\":{\"71\":2}}],[\"route\",{\"1\":{\"101\":2}}],[\"routeinfomanager\",{\"0\":{\"86\":1},\"1\":{\"81\":2,\"84\":8,\"86\":1,\"87\":1,\"89\":1}}],[\"router\",{\"1\":{\"3\":3}}],[\"rocket\",{\"1\":{\"11\":1,\"110\":2}}],[\"rocketmq架构设计与实现原理\",{\"1\":{\"122\":1}}],[\"rocketmq技术内幕\",{\"1\":{\"122\":1}}],[\"rocketmq的目录页面\",{\"1\":{\"11\":1}}],[\"rocketmq\",{\"0\":{\"34\":1,\"35\":1,\"44\":1,\"61\":1,\"74\":1,\"75\":1,\"79\":1,\"91\":1,\"105\":1,\"108\":1},\"1\":{\"7\":1,\"11\":2,\"36\":1,\"37\":3,\"41\":3,\"42\":1,\"44\":1,\"46\":1,\"47\":1,\"49\":3,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":2,\"60\":2,\"61\":1,\"62\":3,\"70\":1,\"73\":2,\"75\":1,\"77\":2,\"78\":1,\"80\":2,\"87\":2,\"89\":4,\"91\":1,\"98\":2,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"108\":3,\"110\":3,\"111\":1,\"112\":3,\"116\":2,\"120\":1,\"122\":1}}],[\"refactor\",{\"1\":{\"102\":1}}],[\"reference\",{\"0\":{\"32\":1,\"122\":1}}],[\"recovertopicqueuetable\",{\"1\":{\"119\":1}}],[\"recoverabnormally\",{\"1\":{\"119\":1}}],[\"recovernormally\",{\"1\":{\"119\":1}}],[\"recover\",{\"1\":{\"103\":1,\"119\":3}}],[\"record\",{\"1\":{\"89\":1}}],[\"reconsume\",{\"1\":{\"59\":1}}],[\"recalculatepullfromwhichnode\",{\"1\":{\"69\":4}}],[\"reallocatebytebuffer\",{\"1\":{\"67\":1}}],[\"readcustomheader\",{\"1\":{\"89\":1}}],[\"readqueuenums\",{\"1\":{\"88\":1}}],[\"readqueue\",{\"1\":{\"87\":1,\"96\":1,\"101\":1}}],[\"readlock\",{\"1\":{\"84\":2}}],[\"readsocketservice\",{\"1\":{\"68\":2}}],[\"readevent\",{\"1\":{\"66\":1}}],[\"read\",{\"1\":{\"57\":1,\"65\":2,\"115\":1}}],[\"readoffsettype\",{\"1\":{\"57\":1}}],[\"readoffset\",{\"1\":{\"57\":1}}],[\"readfile\",{\"1\":{\"57\":1}}],[\"readme\",{\"1\":{\"3\":2,\"6\":3}}],[\"req\",{\"1\":{\"67\":7}}],[\"requesttable\",{\"1\":{\"115\":3}}],[\"requesthousekeepingservice\",{\"1\":{\"103\":1}}],[\"requestheader\",{\"1\":{\"40\":1,\"59\":1,\"89\":7,\"103\":2}}],[\"requestfuturetable\",{\"1\":{\"98\":1}}],[\"requestswrite\",{\"1\":{\"67\":1,\"115\":3}}],[\"requestsread\",{\"1\":{\"67\":5,\"115\":4}}],[\"requestmapping\",{\"1\":{\"41\":1,\"42\":1}}],[\"request\",{\"1\":{\"41\":2,\"42\":3,\"55\":1,\"57\":3,\"89\":10,\"90\":1,\"103\":4,\"115\":5,\"116\":12}}],[\"requestcode里面定义了所有的请求类型code\",{\"1\":{\"89\":1}}],[\"requestcode\",{\"1\":{\"40\":1,\"41\":2,\"42\":2,\"55\":1,\"59\":1,\"89\":1}}],[\"requestbody\",{\"1\":{\"40\":1}}],[\"requested\",{\"1\":{\"3\":1}}],[\"repeatedly\",{\"1\":{\"116\":1}}],[\"reputmessageservice\",{\"1\":{\"116\":2}}],[\"replicaresultfuture\",{\"1\":{\"115\":1}}],[\"reply\",{\"1\":{\"41\":2}}],[\"reportslavemaxoffsetplus\",{\"1\":{\"66\":1}}],[\"reportslavemaxoffset\",{\"1\":{\"66\":1}}],[\"reportoffset\",{\"1\":{\"66\":1}}],[\"removed\",{\"1\":{\"84\":2}}],[\"removebrokername\",{\"1\":{\"84\":5}}],[\"remove\",{\"1\":{\"84\":15,\"89\":3}}],[\"removeprocessqueue\",{\"1\":{\"57\":1}}],[\"remoteaddr\",{\"1\":{\"84\":6}}],[\"remote\",{\"1\":{\"56\":1}}],[\"remotebrokeroffsetstore\",{\"1\":{\"55\":3}}],[\"remotingtimeoutexception\",{\"1\":{\"101\":1}}],[\"remotingtoomuchrequestexception\",{\"1\":{\"101\":1,\"103\":2}}],[\"remotingconnectexception\",{\"1\":{\"101\":1}}],[\"remotingcommandexception\",{\"1\":{\"89\":1}}],[\"remotingcommand\",{\"1\":{\"89\":4,\"90\":2}}],[\"remotingexception\",{\"1\":{\"100\":1,\"101\":4}}],[\"remotinghelper\",{\"1\":{\"94\":1}}],[\"remotingutil\",{\"1\":{\"65\":2,\"84\":1}}],[\"remotingserver\",{\"1\":{\"39\":3}}],[\"remoting\",{\"1\":{\"37\":1}}],[\"resend\",{\"1\":{\"101\":4}}],[\"reset\",{\"1\":{\"101\":1,\"103\":1}}],[\"result\",{\"1\":{\"57\":7,\"58\":1,\"66\":2,\"89\":7,\"115\":10,\"116\":2}}],[\"responseheader\",{\"1\":{\"42\":1,\"69\":2,\"89\":3}}],[\"responsecode\",{\"1\":{\"42\":1,\"89\":2,\"96\":6}}],[\"response\",{\"1\":{\"42\":6,\"55\":1,\"66\":1,\"89\":10,\"90\":1,\"103\":1}}],[\"rebalanceresultset=\",{\"1\":{\"58\":1}}],[\"rebalanceresultsize=\",{\"1\":{\"58\":1}}],[\"rebalanced\",{\"1\":{\"58\":1}}],[\"rebalancebytopic\",{\"1\":{\"58\":4}}],[\"rebalancepushimpl\",{\"1\":{\"58\":2}}],[\"rebalancepullimpl\",{\"1\":{\"58\":1}}],[\"rebalancelitepullimpl\",{\"1\":{\"58\":1}}],[\"rebalance\",{\"1\":{\"55\":1,\"58\":4}}],[\"rebalanceimmediately\",{\"1\":{\"55\":1}}],[\"rebalanceimpl\",{\"1\":{\"55\":10,\"57\":4,\"58\":8}}],[\"rebalanceservice\",{\"1\":{\"55\":3,\"58\":2}}],[\"retryanotherbrokerwhennotstoreok\",{\"1\":{\"96\":1}}],[\"retrytimeswhensendasyncfailed\",{\"1\":{\"96\":1}}],[\"retrytimeswhensendfailed\",{\"1\":{\"96\":1}}],[\"retrytopic\",{\"1\":{\"55\":1}}],[\"retryresponsecodes\",{\"1\":{\"96\":1}}],[\"retry\",{\"1\":{\"58\":2}}],[\"return\",{\"1\":{\"42\":2,\"57\":13,\"58\":2,\"65\":1,\"69\":3,\"89\":5,\"100\":1,\"101\":7,\"102\":2,\"103\":3,\"115\":6,\"116\":5,\"119\":2}}],[\"registerproducer\",{\"1\":{\"98\":3}}],[\"registerprocessor\",{\"1\":{\"42\":2}}],[\"registered\",{\"1\":{\"89\":1}}],[\"registerfirst\",{\"1\":{\"89\":5}}],[\"registerfiltermessagehook\",{\"1\":{\"55\":1}}],[\"registerbrokerresult\",{\"1\":{\"89\":4}}],[\"registerbrokerresponseheader\",{\"1\":{\"89\":3}}],[\"registerbrokerrequestheader\",{\"1\":{\"89\":3}}],[\"registerbroker\",{\"1\":{\"89\":7}}],[\"registerbrokerwithfilterserver\",{\"1\":{\"89\":1}}],[\"registerbrokerall\",{\"1\":{\"39\":3,\"40\":1}}],[\"registermessagelistener\",{\"1\":{\"56\":1}}],[\"registerconsumer\",{\"1\":{\"55\":1}}],[\"registerconsumemessagehook\",{\"1\":{\"42\":1}}],[\"registerok\",{\"1\":{\"55\":2,\"98\":2}}],[\"registersendmessagehook\",{\"1\":{\"42\":1}}],[\"register\",{\"1\":{\"40\":1,\"65\":1,\"89\":2}}],[\"reentrantreadwritelock\",{\"1\":{\"23\":1,\"84\":1}}],[\"reentrantlock\",{\"1\":{\"23\":1,\"115\":2}}],[\"redis\",{\"1\":{\"13\":2,\"89\":1,\"107\":2}}],[\"执行成功\",{\"1\":{\"115\":1}}],[\"执行一次\",{\"1\":{\"67\":1}}],[\"执行一次负载均衡\",{\"1\":{\"58\":1}}],[\"执行各种已提交的\",{\"1\":{\"23\":1}}],[\"执行\",{\"1\":{\"3\":1,\"77\":1}}],[\"没有单独贴出来\",{\"1\":{\"67\":1}}],[\"没有特意讲解\",{\"1\":{\"60\":1}}],[\"没有匹配的消息\",{\"1\":{\"57\":1}}],[\"没有新消息\",{\"1\":{\"57\":1}}],[\"没有提供\",{\"1\":{\"3\":1}}],[\"没有问题\",{\"1\":{\"3\":1}}],[\"没有readme\",{\"1\":{\"3\":1}}],[\"失败策略\",{\"1\":{\"103\":1}}],[\"失败\",{\"1\":{\"3\":1,\"6\":1}}],[\"就会把\",{\"1\":{\"115\":1}}],[\"就会把消息发回\",{\"1\":{\"59\":1}}],[\"就会自动从这个表里取出信息然后创建文件\",{\"1\":{\"115\":1}}],[\"就会直接创建一个新的\",{\"1\":{\"110\":1}}],[\"就能得到消息在\",{\"1\":{\"110\":1}}],[\"就可以从这个文件开始恢复\",{\"1\":{\"119\":1}}],[\"就可以去\",{\"1\":{\"112\":1}}],[\"就可以利用二分查找迅速定位这个消息存储在哪个\",{\"1\":{\"110\":1}}],[\"就可以了\",{\"1\":{\"89\":1}}],[\"就通过\",{\"1\":{\"102\":1}}],[\"就改成\",{\"1\":{\"98\":1}}],[\"就不全贴出来了\",{\"1\":{\"96\":1}}],[\"就不分类了\",{\"1\":{\"0\":1}}],[\"就进行压缩\",{\"1\":{\"96\":1}}],[\"就回到了前面第一次标记的情况\",{\"1\":{\"89\":1}}],[\"就像\",{\"1\":{\"89\":1}}],[\"就把各种需要的参数\",{\"1\":{\"83\":1}}],[\"就直接拿来更新本地消费进度\",{\"1\":{\"72\":1}}],[\"就直接搜\",{\"1\":{\"3\":1}}],[\"就在这段代码前调用\",{\"1\":{\"69\":1}}],[\"就取决于\",{\"1\":{\"69\":1}}],[\"就要复杂一些\",{\"1\":{\"67\":1}}],[\"就为\",{\"1\":{\"66\":1}}],[\"就立即拉取\",{\"1\":{\"57\":1}}],[\"就返回\",{\"1\":{\"57\":1}}],[\"就是逻辑文件\",{\"1\":{\"116\":1}}],[\"就是不同类型的刷盘线程\",{\"1\":{\"115\":1}}],[\"就是刷盘方法\",{\"1\":{\"115\":1}}],[\"就是这种技术的应用\",{\"1\":{\"114\":1}}],[\"就是第四条消息的\",{\"1\":{\"111\":1}}],[\"就是存在这里\",{\"1\":{\"103\":1}}],[\"就是存入\",{\"1\":{\"57\":1}}],[\"就是之后\",{\"1\":{\"102\":1}}],[\"就是之前\",{\"1\":{\"57\":1}}],[\"就是调用\",{\"1\":{\"102\":1}}],[\"就是对整个\",{\"1\":{\"102\":1}}],[\"就是创建\",{\"1\":{\"98\":1}}],[\"就是给\",{\"1\":{\"98\":1}}],[\"就是个\",{\"1\":{\"98\":1}}],[\"就是构造\",{\"1\":{\"89\":1}}],[\"就是processrequest\",{\"1\":{\"89\":1}}],[\"就是发个请求\",{\"1\":{\"89\":1}}],[\"就是打印\",{\"1\":{\"85\":1}}],[\"就是要删除的\",{\"1\":{\"84\":1}}],[\"就是负责这部分的模块\",{\"1\":{\"80\":1}}],[\"就是通过\",{\"1\":{\"72\":1}}],[\"就是处理请求的方法\",{\"1\":{\"69\":1}}],[\"就是帮你把下标置换回\",{\"1\":{\"67\":1}}],[\"就是它的\",{\"1\":{\"67\":1}}],[\"就是主从同步是否完成的标记\",{\"1\":{\"67\":1}}],[\"就是为监听端口的准备工作\",{\"1\":{\"67\":1}}],[\"就是高可用的核心实现类\",{\"1\":{\"67\":1}}],[\"就是代表\",{\"1\":{\"57\":1}}],[\"就是定时调用\",{\"1\":{\"57\":1}}],[\"就是\",{\"1\":{\"56\":1,\"58\":1,\"63\":1,\"66\":1,\"67\":1,\"69\":1,\"84\":1,\"89\":1,\"111\":1,\"112\":1,\"115\":2,\"116\":1}}],[\"就是一些后续处理\",{\"1\":{\"56\":1}}],[\"就是待拉取的消息队列\",{\"1\":{\"56\":1}}],[\"就是把消费组和对应的\",{\"1\":{\"55\":1}}],[\"就是从本地文件中取出消费位点\",{\"1\":{\"55\":1}}],[\"就是以并发的方式消费消息\",{\"1\":{\"46\":1}}],[\"就是实现方案比较麻烦\",{\"1\":{\"46\":1}}],[\"就是用前面的\",{\"1\":{\"39\":1}}],[\"就是用于并发环境下的集合类\",{\"1\":{\"26\":1}}],[\"就比如数组\",{\"1\":{\"108\":1}}],[\"就比如无论是\",{\"1\":{\"80\":1}}],[\"就比如\",{\"1\":{\"13\":1,\"115\":1}}],[\"就主要是\",{\"1\":{\"13\":1}}],[\"就差直接页面里面手动记录版本号了\",{\"1\":{\"4\":1}}],[\"就报\",{\"1\":{\"3\":1}}],[\"搜索\",{\"1\":{\"3\":1}}],[\"看成是任务列表\",{\"1\":{\"116\":1}}],[\"看成自动\",{\"1\":{\"46\":1}}],[\"看起来\",{\"1\":{\"116\":1}}],[\"看起来就是00000000000000000321这种样子\",{\"1\":{\"110\":1}}],[\"看起来就是直接往\",{\"1\":{\"91\":1}}],[\"看似平平无奇的设计里隐藏着一个优秀的特性\",{\"1\":{\"110\":1}}],[\"看过\",{\"1\":{\"89\":1}}],[\"看\",{\"1\":{\"69\":1}}],[\"看到\",{\"1\":{\"57\":1}}],[\"看如何处理\",{\"1\":{\"57\":1}}],[\"看这里\",{\"1\":{\"5\":1}}],[\"看见这个就去升级一下对应\",{\"1\":{\"3\":1}}],[\"看能不能去掉无用的目录路径\",{\"1\":{\"3\":1}}],[\"2级目录\",{\"1\":{\"116\":1}}],[\"256\",{\"1\":{\"110\":1}}],[\"2k\",{\"1\":{\"110\":1}}],[\"2分钟没收到过\",{\"1\":{\"84\":1}}],[\"2\",{\"1\":{\"7\":2,\"55\":1,\"89\":1,\"96\":2,\"109\":1,\"111\":3,\"115\":1}}],[\"22\",{\"1\":{\"3\":1}}],[\"200ms\",{\"1\":{\"115\":3}}],[\"2000w\",{\"1\":{\"112\":1}}],[\"2000万个\",{\"1\":{\"112\":1}}],[\"20000\",{\"1\":{\"58\":1}}],[\"2000\",{\"1\":{\"57\":1}}],[\"20的线性关系\",{\"1\":{\"111\":1}}],[\"20s\",{\"1\":{\"58\":4,\"66\":1}}],[\"2023\",{\"1\":{\"3\":1}}],[\"20\",{\"1\":{\"3\":2,\"55\":1,\"56\":3,\"110\":1,\"111\":8,\"112\":3,\"116\":1}}],[\"must\",{\"1\":{\"89\":1}}],[\"ms\",{\"1\":{\"84\":1,\"101\":1,\"115\":1}}],[\"msgcheckstatus\",{\"1\":{\"115\":3}}],[\"msglen\",{\"1\":{\"110\":1}}],[\"msglist\",{\"1\":{\"57\":1}}],[\"msgbody\",{\"1\":{\"103\":1}}],[\"msgbodycompressed\",{\"1\":{\"103\":1}}],[\"msgbatch\",{\"1\":{\"102\":11}}],[\"msgfoundlist\",{\"1\":{\"57\":1}}],[\"msgstore\",{\"1\":{\"115\":3}}],[\"msgs\",{\"1\":{\"56\":4,\"102\":2}}],[\"msgtreemap\",{\"1\":{\"56\":2,\"57\":4}}],[\"msginner\",{\"1\":{\"42\":3,\"115\":1}}],[\"msg\",{\"0\":{\"99\":1,\"100\":1,\"101\":1},\"1\":{\"42\":4,\"57\":2,\"59\":1,\"94\":2,\"100\":6,\"101\":20,\"102\":3,\"103\":8,\"108\":1,\"111\":4,\"112\":2,\"115\":9,\"116\":10}}],[\"mb\",{\"1\":{\"57\":1}}],[\"mmapoperation这里稍微补充说明以下\",{\"1\":{\"115\":1}}],[\"mmapoperation\",{\"1\":{\"115\":1}}],[\"mmap\",{\"1\":{\"42\":1,\"114\":3,\"115\":1}}],[\"mixall\",{\"1\":{\"58\":2,\"64\":1,\"69\":2,\"89\":3,\"98\":1,\"103\":1}}],[\"millis\",{\"1\":{\"57\":2}}],[\"milliseconds\",{\"1\":{\"39\":1,\"56\":1,\"57\":1,\"71\":1,\"103\":1}}],[\"mills\",{\"1\":{\"57\":2,\"58\":1}}],[\"minlogicoffset\",{\"1\":{\"116\":1}}],[\"min\",{\"1\":{\"39\":1,\"110\":2,\"119\":7}}],[\"makelogicsqueueerror\",{\"1\":{\"116\":1}}],[\"makesurestateok\",{\"1\":{\"101\":1}}],[\"may\",{\"1\":{\"115\":1}}],[\"maybe\",{\"1\":{\"55\":1,\"57\":1,\"98\":1,\"116\":1}}],[\"mark\",{\"1\":{\"115\":1}}],[\"magic\",{\"1\":{\"110\":1}}],[\"massage\",{\"1\":{\"103\":1}}],[\"masteraddr\",{\"1\":{\"89\":4}}],[\"masteraddress\",{\"1\":{\"65\":1,\"66\":1,\"67\":1}}],[\"master\",{\"1\":{\"40\":3,\"61\":3,\"62\":2,\"63\":5,\"64\":8,\"65\":6,\"66\":5,\"67\":9,\"68\":2,\"69\":5,\"70\":3,\"71\":2,\"89\":6,\"115\":1}}],[\"mappedbytebuffer\",{\"1\":{\"115\":1}}],[\"mappedfiles\",{\"1\":{\"110\":1,\"119\":1}}],[\"mappedfilequeue\",{\"1\":{\"110\":3,\"111\":3,\"115\":2,\"116\":3}}],[\"mappedfile\",{\"1\":{\"42\":2,\"66\":1,\"110\":3,\"111\":2,\"114\":1,\"115\":14,\"116\":10}}],[\"mapedfilesizecommitlog\",{\"1\":{\"110\":1}}],[\"map<long\",{\"1\":{\"89\":1}}],[\"map<string\",{\"1\":{\"58\":1,\"112\":1}}],[\"map\",{\"1\":{\"58\":1,\"89\":1}}],[\"match\",{\"1\":{\"89\":1}}],[\"matched\",{\"1\":{\"57\":2}}],[\"math\",{\"1\":{\"39\":2,\"119\":2}}],[\"maxphyoffsetofconsumequeue\",{\"1\":{\"119\":3}}],[\"maxphyoffsetpulling\",{\"1\":{\"69\":1}}],[\"maxphysicoffset=\",{\"1\":{\"116\":1}}],[\"maxphysicoffset\",{\"1\":{\"116\":7}}],[\"maxretries\",{\"1\":{\"116\":2}}],[\"maxblank\",{\"1\":{\"110\":2}}],[\"maxmessagesize\",{\"1\":{\"96\":1}}],[\"maxoffsetpy\",{\"1\":{\"69\":1}}],[\"maxoffset\",{\"1\":{\"68\":1}}],[\"maxspan\",{\"1\":{\"57\":1}}],[\"maxtimeconsumecontinuously\",{\"1\":{\"56\":1}}],[\"max\",{\"1\":{\"39\":1,\"56\":3,\"57\":2,\"116\":1}}],[\"main0\",{\"1\":{\"83\":3}}],[\"main\",{\"1\":{\"38\":1,\"39\":2,\"83\":1}}],[\"me\",{\"1\":{\"116\":2}}],[\"messsage\",{\"1\":{\"67\":1}}],[\"messageext\",{\"1\":{\"115\":3}}],[\"messageextbrokerinner\",{\"1\":{\"115\":1}}],[\"messageaccessor\",{\"1\":{\"103\":2}}],[\"messagecloned\",{\"1\":{\"103\":4}}],[\"messageclientidsetter\",{\"1\":{\"102\":1}}],[\"messagedecoder\",{\"1\":{\"102\":1}}],[\"messagelist\",{\"1\":{\"102\":1}}],[\"messagelistener\",{\"1\":{\"56\":1}}],[\"messagelistenerconcurrently\",{\"1\":{\"55\":2}}],[\"messagelistenerorderly\",{\"1\":{\"55\":2}}],[\"messagesysflag\",{\"1\":{\"116\":5}}],[\"messages\",{\"1\":{\"102\":4}}],[\"messagestoreconfig\",{\"1\":{\"39\":3,\"63\":1,\"64\":4,\"69\":4,\"115\":4}}],[\"messagestore\",{\"1\":{\"39\":2,\"42\":1,\"64\":1}}],[\"messagebatch\",{\"1\":{\"102\":5}}],[\"messagequeuechanged\",{\"1\":{\"58\":1}}],[\"messagequeuelock\",{\"1\":{\"56\":1}}],[\"messagequeue\",{\"1\":{\"56\":9,\"57\":9,\"58\":1,\"69\":6,\"101\":2}}],[\"messagemode\",{\"0\":{\"49\":1},\"1\":{\"49\":1}}],[\"messagemodel\",{\"1\":{\"46\":1,\"49\":2,\"55\":2,\"57\":1,\"58\":1}}],[\"message\",{\"0\":{\"99\":1,\"100\":1,\"101\":1},\"1\":{\"41\":5,\"42\":1,\"57\":5,\"94\":2,\"96\":1,\"100\":1,\"101\":3,\"102\":13,\"103\":4,\"112\":3,\"115\":1}}],[\"method\",{\"1\":{\"57\":1}}],[\"methods\",{\"1\":{\"31\":2}}],[\"memory\",{\"0\":{\"25\":1},\"1\":{\"24\":1,\"57\":1,\"69\":3,\"110\":2}}],[\"medium\",{\"1\":{\"7\":1}}],[\"mqfaultstrategy\",{\"1\":{\"103\":3}}],[\"mqselected\",{\"1\":{\"101\":3}}],[\"mqset\",{\"1\":{\"58\":6}}],[\"mqbrokerexception\",{\"1\":{\"100\":1,\"101\":6}}],[\"mq客户端的实例\",{\"1\":{\"98\":1}}],[\"mqversion\",{\"1\":{\"89\":2}}],[\"mqallsize=\",{\"1\":{\"58\":1}}],[\"mqall\",{\"1\":{\"58\":4}}],[\"mqconsumerinner\",{\"1\":{\"57\":1}}],[\"mqclientinstance\",{\"1\":{\"57\":3,\"98\":9,\"103\":1}}],[\"mqclientapiimpl\",{\"1\":{\"55\":2,\"59\":1}}],[\"mqclientmanager\",{\"1\":{\"55\":1,\"98\":4}}],[\"mqclientfactory\",{\"1\":{\"55\":11,\"57\":5,\"58\":5,\"69\":1,\"98\":5,\"103\":7}}],[\"mqclientexception\",{\"1\":{\"55\":2,\"97\":2,\"98\":4,\"100\":1,\"101\":14,\"102\":2}}],[\"mqpullconsumer\",{\"1\":{\"47\":1}}],[\"mqpushconsumer\",{\"1\":{\"47\":1}}],[\"mqtracecontext\",{\"1\":{\"42\":1}}],[\"mq\",{\"1\":{\"11\":2,\"69\":11,\"75\":1,\"101\":16,\"103\":2,\"106\":1}}],[\"mysql主从复制\",{\"0\":{\"18\":1}}],[\"mysql\",{\"0\":{\"17\":1},\"1\":{\"13\":1,\"19\":1,\"107\":1,\"108\":1,\"110\":1}}],[\"my\",{\"1\":{\"9\":1}}],[\"most\",{\"1\":{\"31\":1}}],[\"module\",{\"1\":{\"3\":1}}],[\"more\",{\"1\":{\"3\":1}}],[\"md时\",{\"1\":{\"11\":2}}],[\"md时自动目录可用\",{\"1\":{\"3\":1}}],[\"md文件\",{\"1\":{\"6\":1}}],[\"md\",{\"1\":{\"3\":3,\"6\":2,\"11\":1}}],[\"volatile\",{\"1\":{\"96\":1}}],[\"void\",{\"1\":{\"30\":1,\"39\":2,\"55\":1,\"56\":2,\"57\":6,\"58\":2,\"64\":1,\"66\":1,\"67\":2,\"69\":1,\"71\":3,\"84\":2,\"97\":1,\"98\":2,\"115\":1,\"116\":3}}],[\"version\",{\"1\":{\"89\":2}}],[\"validatenameserversetting\",{\"1\":{\"101\":1}}],[\"validators\",{\"1\":{\"100\":1,\"101\":1,\"102\":2}}],[\"value2version\",{\"1\":{\"89\":1}}],[\"value\",{\"1\":{\"57\":1,\"67\":5,\"69\":1,\"84\":1,\"98\":1,\"103\":1,\"112\":1}}],[\"various\",{\"1\":{\"55\":1}}],[\"vue\",{\"1\":{\"3\":3,\"6\":1}}],[\"vuepress\",{\"0\":{\"6\":1},\"1\":{\"2\":2,\"3\":3,\"6\":5,\"7\":5,\"9\":1,\"10\":3,\"12\":2}}],[\"v3\",{\"1\":{\"3\":1,\"89\":1}}],[\"v2\",{\"1\":{\"3\":2,\"41\":1}}],[\"url\",{\"1\":{\"98\":1}}],[\"uniq\",{\"1\":{\"102\":1}}],[\"unit\",{\"1\":{\"96\":1,\"111\":2,\"116\":2}}],[\"unregisterbroker\",{\"1\":{\"90\":2}}],[\"unlockdelaytimemills\",{\"1\":{\"58\":1}}],[\"unlock\",{\"1\":{\"58\":1,\"84\":2,\"89\":1}}],[\"unmodifiablelist\",{\"1\":{\"56\":1}}],[\"using\",{\"1\":{\"31\":1,\"103\":2}}],[\"user\",{\"1\":{\"55\":1}}],[\"use\",{\"1\":{\"3\":2}}],[\"utilities\",{\"1\":{\"31\":1}}],[\"utility\",{\"1\":{\"31\":1}}],[\"util\",{\"0\":{\"23\":1},\"1\":{\"23\":3,\"24\":1}}],[\"updatefaultitem\",{\"1\":{\"101\":5}}],[\"updatetopicrouteinfofromnameserver\",{\"1\":{\"80\":1,\"103\":2}}],[\"updatetopicsubscribeinfowhensubscriptionchanged\",{\"1\":{\"55\":1}}],[\"updatepullfromwhichnode\",{\"1\":{\"69\":3}}],[\"updateprocessqueuetableinrebalance\",{\"1\":{\"58\":3}}],[\"updatemasteraddress\",{\"1\":{\"67\":1}}],[\"updateoffset\",{\"1\":{\"57\":1}}],[\"update\",{\"1\":{\"3\":1,\"69\":1}}],[\"1gb\",{\"1\":{\"110\":2}}],[\"1ms\",{\"1\":{\"116\":1}}],[\"1m\",{\"1\":{\"110\":1}}],[\"1是正常发送那一次\",{\"1\":{\"101\":1}}],[\"128\",{\"1\":{\"94\":1}}],[\"120秒没收到\",{\"1\":{\"90\":1}}],[\"120s\",{\"1\":{\"84\":2}}],[\"11\",{\"1\":{\"89\":1}}],[\"1s\",{\"1\":{\"67\":1}}],[\"1l\",{\"1\":{\"57\":1}}],[\"15\",{\"1\":{\"55\":1}}],[\"1\",{\"1\":{\"7\":2,\"49\":1,\"52\":3,\"55\":1,\"56\":2,\"57\":3,\"64\":3,\"68\":1,\"89\":1,\"101\":2,\"109\":1,\"111\":3,\"115\":2,\"119\":2}}],[\"16k\",{\"1\":{\"110\":1}}],[\"16\",{\"1\":{\"3\":2}}],[\"1024\",{\"1\":{\"96\":3}}],[\"10分钟打印一次配置信息\",{\"0\":{\"85\":1}}],[\"10秒检测一次\",{\"1\":{\"80\":1}}],[\"10s\",{\"1\":{\"71\":1,\"72\":1,\"84\":2}}],[\"10912\",{\"1\":{\"64\":2}}],[\"10911\",{\"1\":{\"64\":3}}],[\"100\",{\"1\":{\"57\":1,\"69\":1}}],[\"10000\",{\"1\":{\"39\":1,\"57\":1}}],[\"1000\",{\"1\":{\"39\":1,\"56\":1,\"57\":1,\"66\":3,\"67\":1,\"71\":2,\"103\":1,\"116\":1,\"119\":1}}],[\"10ms\",{\"1\":{\"56\":1,\"67\":1,\"115\":1}}],[\"10\",{\"1\":{\"3\":1,\"39\":1,\"40\":1,\"56\":2,\"67\":1,\"69\":1,\"71\":1,\"84\":3}}],[\"即可\",{\"1\":{\"46\":1,\"56\":1}}],[\"即可启用\",{\"1\":{\"3\":1}}],[\"即可达成目标\",{\"1\":{\"3\":1}}],[\"中作为下一步的入参\",{\"1\":{\"119\":1}}],[\"中都是同一套\",{\"1\":{\"116\":1}}],[\"中推理出来的\",{\"1\":{\"116\":1}}],[\"中有个\",{\"1\":{\"116\":1}}],[\"中有提到\",{\"1\":{\"41\":1}}],[\"中查找\",{\"1\":{\"112\":1}}],[\"中查找之前多加一个根据\",{\"1\":{\"111\":1}}],[\"中只有\",{\"1\":{\"112\":1}}],[\"中准确定位到消息所处具体的文件的具体位置起始\",{\"1\":{\"111\":1}}],[\"中提到的\",{\"1\":{\"101\":1}}],[\"中提到了\",{\"1\":{\"80\":1}}],[\"中与该\",{\"1\":{\"89\":1}}],[\"中维护的五个数据表都是\",{\"1\":{\"89\":1}}],[\"中典型的\",{\"1\":{\"89\":1}}],[\"中删除\",{\"1\":{\"84\":5}}],[\"中删除过期\",{\"1\":{\"84\":1}}],[\"中读取消息数据转发给消费队列\",{\"1\":{\"77\":1}}],[\"中读数据\",{\"1\":{\"66\":1}}],[\"中存储的消息在\",{\"1\":{\"116\":1}}],[\"中存储的\",{\"1\":{\"70\":1}}],[\"中设置\",{\"1\":{\"69\":1}}],[\"中以\",{\"1\":{\"69\":1}}],[\"中找到\",{\"1\":{\"64\":2}}],[\"中剔除订阅关系错误的消息\",{\"1\":{\"58\":1}}],[\"中根据\",{\"1\":{\"57\":1}}],[\"中间\",{\"1\":{\"57\":1}}],[\"中间件\",{\"1\":{\"13\":1}}],[\"中语义一致\",{\"1\":{\"57\":1}}],[\"中注册那一步存入\",{\"1\":{\"57\":1}}],[\"中取出消息进行消费\",{\"1\":{\"58\":1}}],[\"中取出\",{\"1\":{\"56\":1,\"57\":2}}],[\"中英都是官方名称\",{\"1\":{\"51\":1}}],[\"中的物理偏移量\",{\"1\":{\"116\":1}}],[\"中的消息是否损坏\",{\"1\":{\"116\":1}}],[\"中的消息在\",{\"1\":{\"111\":1}}],[\"中的偏移量\",{\"1\":{\"111\":3,\"112\":1}}],[\"中的数据则是在\",{\"1\":{\"119\":1}}],[\"中的数据来自\",{\"1\":{\"111\":1}}],[\"中的数据复制到\",{\"1\":{\"102\":1}}],[\"中的绝对位置\",{\"1\":{\"110\":1}}],[\"中的过期请求\",{\"1\":{\"98\":1}}],[\"中的内容\",{\"1\":{\"92\":1}}],[\"中的每个\",{\"1\":{\"67\":1}}],[\"中的保存数据\",{\"1\":{\"66\":1}}],[\"中的上报\",{\"1\":{\"66\":1}}],[\"中的订阅复制一份给\",{\"1\":{\"55\":1}}],[\"中的三种发送消息的方式对于\",{\"1\":{\"42\":1}}],[\"中的\",{\"1\":{\"42\":1,\"66\":1,\"112\":2,\"115\":1,\"116\":3}}],[\"中的脚本部分\",{\"1\":{\"6\":1}}],[\"中搜索对应关键字\",{\"1\":{\"41\":1}}],[\"中关于\",{\"1\":{\"40\":1}}],[\"中自认为比较核心的内容\",{\"1\":{\"13\":1}}],[\"中\",{\"1\":{\"3\":1,\"5\":1,\"19\":2,\"42\":1,\"56\":1,\"57\":2,\"69\":1,\"77\":1,\"87\":1,\"98\":1,\"102\":1,\"108\":1,\"110\":1,\"116\":1,\"119\":1}}],[\"中引入\",{\"1\":{\"3\":1}}],[\"把找到的\",{\"1\":{\"84\":1}}],[\"把消息写入\",{\"1\":{\"77\":1}}],[\"把消息提交给\",{\"1\":{\"57\":1}}],[\"把\",{\"1\":{\"3\":1,\"13\":1,\"40\":1,\"55\":2,\"98\":2}}],[\"不建议看\",{\"1\":{\"119\":1}}],[\"不足\",{\"1\":{\"119\":1}}],[\"不为\",{\"1\":{\"116\":1}}],[\"不为空\",{\"1\":{\"57\":1}}],[\"不打算贴的原因是很容易跟前文逻辑混淆\",{\"1\":{\"116\":1}}],[\"不展开看了\",{\"1\":{\"115\":1}}],[\"不重要\",{\"1\":{\"115\":1}}],[\"不能过长\",{\"1\":{\"115\":1}}],[\"不能相同\",{\"1\":{\"65\":1}}],[\"不正常直接返回\",{\"1\":{\"115\":1}}],[\"不管是\",{\"1\":{\"112\":1,\"115\":1}}],[\"不可能把\",{\"1\":{\"110\":1}}],[\"不满足批量发送条件会直接抛异常\",{\"1\":{\"102\":1}}],[\"不同于前两个文件的顺序写\",{\"1\":{\"112\":1}}],[\"不同硬盘\",{\"1\":{\"110\":1}}],[\"不同模式下返回结果的处理\",{\"1\":{\"101\":1}}],[\"不同场景对消息队列的要求是不一样的\",{\"1\":{\"44\":1}}],[\"不等于\",{\"1\":{\"98\":1}}],[\"不符合要求就抛个异常提醒用户修改\",{\"1\":{\"98\":1}}],[\"不会在没有刷盘任务的时候一直空转\",{\"1\":{\"115\":1}}],[\"不会主动关闭\",{\"1\":{\"90\":1}}],[\"不会向\",{\"1\":{\"77\":1}}],[\"不存在则创建后返回\",{\"1\":{\"98\":1}}],[\"不存在就把这个\",{\"1\":{\"89\":1}}],[\"不存在的\",{\"1\":{\"77\":1}}],[\"不懂的先去看\",{\"1\":{\"89\":1}}],[\"不熟悉的话最好先看看\",{\"1\":{\"89\":1}}],[\"不熟悉的小伙伴强烈建议跟着\",{\"1\":{\"67\":1}}],[\"不必深究\",{\"1\":{\"84\":1,\"110\":1}}],[\"不太一样的地方是\",{\"1\":{\"80\":1}}],[\"不是\",{\"1\":{\"65\":1,\"84\":1}}],[\"不认识的话\",{\"1\":{\"65\":1}}],[\"不需要像顺序消费一样从\",{\"1\":{\"60\":1}}],[\"不再赘述\",{\"1\":{\"59\":1}}],[\"不处于\",{\"1\":{\"57\":1}}],[\"不算是控流\",{\"1\":{\"57\":1}}],[\"不清楚客户端配置的可以去看一眼\",{\"1\":{\"55\":1}}],[\"不想画图\",{\"1\":{\"52\":1}}],[\"不断的从本地队列里取出消息进行处理\",{\"1\":{\"46\":1}}],[\"不过缺点是\",{\"1\":{\"120\":1}}],[\"不过通常是\",{\"1\":{\"110\":1}}],[\"不过还是老样子\",{\"1\":{\"103\":1}}],[\"不过这条流程本来就写的很成问题\",{\"1\":{\"84\":1}}],[\"不过这里我们看文件名就能轻松定位到\",{\"1\":{\"38\":1}}],[\"不过\",{\"1\":{\"67\":1}}],[\"不过大同小异\",{\"1\":{\"60\":1}}],[\"不过集群也是从本地内存里读\",{\"1\":{\"57\":1}}],[\"不过处理方式一样\",{\"1\":{\"57\":1}}],[\"不过在分布式系统里你总能找到很多现成的功能拿来复用\",{\"1\":{\"46\":1}}],[\"不过就先这样吧\",{\"1\":{\"3\":1}}],[\"不详细罗列了\",{\"1\":{\"37\":1}}],[\"不理解\",{\"1\":{\"25\":1}}],[\"不用怕忘了关\",{\"1\":{\"4\":1}}],[\"不知道具体版本可以直接\",{\"1\":{\"3\":1}}],[\"不然\",{\"1\":{\"3\":1}}],[\"不要在\",{\"1\":{\"3\":1}}],[\"cqoffset\",{\"1\":{\"116\":6}}],[\"cqext\",{\"1\":{\"116\":1}}],[\"cq文件\",{\"1\":{\"116\":1}}],[\"cq\",{\"1\":{\"111\":2,\"116\":15}}],[\"cqnode\",{\"1\":{\"111\":13}}],[\"cidallsize=\",{\"1\":{\"58\":1}}],[\"cidall\",{\"1\":{\"58\":7}}],[\"cicd\",{\"1\":{\"13\":1}}],[\"cur\",{\"1\":{\"116\":1}}],[\"current\",{\"1\":{\"96\":1}}],[\"currentreportedoffset\",{\"1\":{\"65\":1,\"66\":2}}],[\"currenttimemillis\",{\"1\":{\"56\":1,\"65\":1,\"84\":2,\"89\":1,\"101\":8,\"103\":2}}],[\"customize\",{\"1\":{\"3\":1}}],[\"charset\",{\"1\":{\"94\":1}}],[\"channelhandlercontext\",{\"1\":{\"89\":1,\"90\":1}}],[\"channel\",{\"1\":{\"55\":1,\"66\":4,\"81\":1,\"84\":29,\"89\":5,\"90\":1,\"103\":1}}],[\"channeleventlistener\",{\"1\":{\"39\":1,\"81\":1,\"84\":1}}],[\"changed\",{\"1\":{\"58\":3}}],[\"changeinstancenametopid\",{\"1\":{\"55\":1,\"98\":1}}],[\"changelog\",{\"1\":{\"3\":1}}],[\"checkstorestatus\",{\"1\":{\"115\":4}}],[\"checksum\",{\"1\":{\"89\":1}}],[\"checkpoint\",{\"0\":{\"113\":1},\"1\":{\"109\":1,\"116\":1,\"119\":4}}],[\"checkforbiddenhooklist\",{\"1\":{\"103\":1}}],[\"checkexecutor\",{\"1\":{\"103\":1}}],[\"checkrequestqueue\",{\"1\":{\"103\":1}}],[\"checkmessageandreturnsize\",{\"1\":{\"119\":1}}],[\"checkmessage\",{\"1\":{\"100\":1,\"101\":1,\"102\":2,\"115\":1}}],[\"checkclientinbroker\",{\"1\":{\"55\":1}}],[\"checkconfig\",{\"1\":{\"55\":2,\"98\":2}}],[\"check\",{\"1\":{\"55\":1}}],[\"ctx\",{\"1\":{\"42\":1,\"89\":6,\"90\":1}}],[\"ctrl+f找关键字\",{\"1\":{\"2\":1}}],[\"cause\",{\"1\":{\"115\":1}}],[\"canwrite\",{\"1\":{\"116\":2}}],[\"can\",{\"1\":{\"110\":1,\"116\":1}}],[\"cancel\",{\"1\":{\"71\":2}}],[\"cachedmessagesizeinmib\",{\"1\":{\"57\":1}}],[\"cachedmessagecount\",{\"1\":{\"57\":1}}],[\"call\",{\"1\":{\"101\":1,\"103\":2}}],[\"calltimeout\",{\"1\":{\"101\":3}}],[\"callback\",{\"1\":{\"57\":3,\"94\":1,\"101\":2}}],[\"callable\",{\"1\":{\"23\":2}}],[\"case\",{\"1\":{\"55\":6,\"57\":4,\"58\":2,\"64\":2,\"89\":1,\"98\":4,\"101\":3,\"103\":3,\"116\":4}}],[\"catch\",{\"1\":{\"39\":1,\"57\":6,\"58\":2,\"66\":1,\"71\":1,\"84\":2,\"89\":1,\"94\":1,\"97\":1,\"101\":4,\"102\":1,\"116\":1}}],[\"cyclicbarrier\",{\"1\":{\"23\":1,\"27\":1}}],[\"coomitlog\",{\"1\":{\"115\":1}}],[\"coordinating\",{\"1\":{\"31\":1}}],[\"count\",{\"1\":{\"112\":2}}],[\"countdownlatch2\",{\"1\":{\"66\":1}}],[\"countdownlatch\",{\"1\":{\"23\":1,\"27\":1,\"40\":1,\"66\":1,\"115\":1}}],[\"code\",{\"1\":{\"110\":1}}],[\"copies\",{\"1\":{\"102\":1}}],[\"copysubscription\",{\"1\":{\"55\":1}}],[\"copyonwritearrayset<integer>\",{\"1\":{\"96\":1}}],[\"copyonwritearrayset\",{\"1\":{\"23\":1}}],[\"copyonwritearraylist<mappedfile>\",{\"1\":{\"110\":2}}],[\"copyonwritearraylist\",{\"1\":{\"23\":1}}],[\"cost\",{\"1\":{\"101\":1}}],[\"costtimesync\",{\"1\":{\"103\":3}}],[\"costtimeasync\",{\"1\":{\"103\":3}}],[\"costtime\",{\"1\":{\"101\":3}}],[\"correcttagsoffset\",{\"1\":{\"57\":1}}],[\"core\",{\"1\":{\"56\":1}}],[\"comitlog\",{\"1\":{\"119\":1}}],[\"com\",{\"1\":{\"103\":1}}],[\"compressed\",{\"1\":{\"103\":1}}],[\"compress\",{\"1\":{\"103\":1}}],[\"compressmsgbodyoverhowmuch\",{\"1\":{\"96\":1}}],[\"compareandset\",{\"1\":{\"67\":1}}],[\"compute\",{\"1\":{\"57\":1}}],[\"computepullfromwherewithexception\",{\"1\":{\"57\":1}}],[\"completedfuture\",{\"1\":{\"42\":1,\"115\":4}}],[\"completablefuture<putmessagestatus>\",{\"1\":{\"115\":3}}],[\"completablefuture<putmessageresult>\",{\"1\":{\"115\":2}}],[\"completablefuture\",{\"1\":{\"42\":1,\"115\":4}}],[\"commpressed\",{\"1\":{\"103\":1}}],[\"communicationmode\",{\"1\":{\"57\":1,\"101\":8,\"103\":3}}],[\"commitcommitlogthoroughinterval\",{\"1\":{\"115\":1}}],[\"commitcommitlogleastpages\",{\"1\":{\"115\":1}}],[\"commitintervalcommitlog\",{\"1\":{\"115\":1}}],[\"commitrealtimeservice\",{\"1\":{\"115\":5}}],[\"commit\",{\"1\":{\"76\":1,\"77\":2,\"116\":1}}],[\"commitoffset\",{\"1\":{\"57\":1}}],[\"commitoffsetvalue\",{\"1\":{\"57\":4}}],[\"commitoffsetenable\",{\"1\":{\"57\":3}}],[\"commitlogdispatcherbuildindex\",{\"1\":{\"116\":2}}],[\"commitlogdispatcherbuildconsumequeue\",{\"1\":{\"116\":5}}],[\"commitlogservice\",{\"1\":{\"115\":4}}],[\"commitlog\",{\"0\":{\"110\":1,\"115\":1},\"1\":{\"39\":1,\"42\":3,\"64\":1,\"66\":2,\"67\":1,\"108\":4,\"109\":1,\"110\":25,\"111\":9,\"112\":13,\"113\":1,\"115\":12,\"116\":13,\"119\":10}}],[\"common\",{\"1\":{\"31\":2,\"89\":1}}],[\"command\",{\"1\":{\"30\":1}}],[\"collection<message>\",{\"1\":{\"102\":1}}],[\"collections\",{\"0\":{\"26\":1},\"1\":{\"24\":1,\"26\":1,\"56\":1,\"58\":2}}],[\"color\",{\"1\":{\"10\":2}}],[\"connectionlist\",{\"1\":{\"67\":2}}],[\"connection\",{\"1\":{\"66\":2,\"68\":1}}],[\"connect\",{\"1\":{\"65\":1,\"101\":1}}],[\"connectmaster\",{\"1\":{\"65\":3,\"66\":1,\"67\":2}}],[\"constructor\",{\"1\":{\"116\":1}}],[\"consumingmsgorderlytreemap\",{\"1\":{\"56\":2,\"60\":1}}],[\"consuming\",{\"0\":{\"51\":1}}],[\"consumequeuetable\",{\"1\":{\"119\":2}}],[\"consumequeueext\",{\"0\":{\"117\":1}}],[\"consumequeuefile\",{\"1\":{\"111\":1}}],[\"consumequeue\",{\"0\":{\"111\":1,\"116\":1},\"1\":{\"76\":1,\"108\":4,\"109\":1,\"110\":1,\"111\":23,\"112\":3,\"113\":1,\"115\":1,\"116\":13,\"117\":3,\"118\":1,\"119\":6}}],[\"consumebatchsize\",{\"1\":{\"56\":1}}],[\"consumeexecutor\",{\"1\":{\"56\":9,\"57\":2}}],[\"consumeorderlycontext\",{\"1\":{\"56\":1}}],[\"consumeorderly\",{\"1\":{\"55\":2}}],[\"consumefromwhere\",{\"1\":{\"51\":1}}],[\"consume\",{\"1\":{\"51\":3,\"56\":2,\"57\":1,\"116\":2}}],[\"consumemessage\",{\"1\":{\"56\":2}}],[\"consumemessagebatchmaxsize\",{\"1\":{\"56\":1}}],[\"consumemessagethread\",{\"1\":{\"56\":1}}],[\"consumemessageconcurrentlyservice\",{\"1\":{\"55\":4,\"60\":1}}],[\"consumemessageservice\",{\"0\":{\"56\":1},\"1\":{\"55\":4,\"56\":3,\"57\":3}}],[\"consumemessageorderlyservice\",{\"1\":{\"55\":4,\"56\":7}}],[\"consumemessageorderly\",{\"1\":{\"46\":1}}],[\"consumemessagehooklist\",{\"1\":{\"42\":1}}],[\"consumeroffset\",{\"1\":{\"109\":2}}],[\"consumerfilter\",{\"1\":{\"109\":2}}],[\"consumersendmessageback\",{\"1\":{\"59\":1}}],[\"consumerequest\",{\"1\":{\"56\":12,\"57\":3}}],[\"consumerequestqueue\",{\"1\":{\"56\":1}}],[\"consumertable\",{\"1\":{\"55\":2,\"57\":2}}],[\"consumergroup\",{\"0\":{\"48\":1},\"1\":{\"48\":1,\"52\":1,\"57\":9,\"58\":5,\"77\":3,\"98\":1}}],[\"consumer\",{\"0\":{\"47\":1,\"55\":1},\"1\":{\"42\":1,\"46\":5,\"47\":1,\"49\":2,\"51\":3,\"52\":2,\"54\":1,\"55\":8,\"56\":1,\"57\":14,\"58\":11,\"59\":4,\"60\":1,\"62\":1,\"69\":5,\"70\":1,\"72\":1,\"77\":13,\"98\":1}}],[\"consistency\",{\"0\":{\"25\":1},\"1\":{\"24\":1}}],[\"contains\",{\"1\":{\"101\":1}}],[\"control\",{\"1\":{\"57\":2}}],[\"controller\",{\"1\":{\"39\":2,\"41\":1,\"42\":1,\"83\":5}}],[\"context\",{\"1\":{\"56\":2,\"103\":2}}],[\"continue\",{\"1\":{\"66\":1,\"101\":4}}],[\"continueconsume\",{\"1\":{\"56\":5}}],[\"continuously\",{\"1\":{\"56\":2}}],[\"contoller\",{\"1\":{\"41\":1}}],[\"concrete\",{\"1\":{\"31\":1}}],[\"concurrentmap<string\",{\"1\":{\"58\":2,\"89\":1,\"103\":1}}],[\"concurrentmap<messagequeue\",{\"1\":{\"58\":1}}],[\"concurrentskiplistset\",{\"1\":{\"23\":1}}],[\"concurrentskiplistmap\",{\"1\":{\"23\":1,\"26\":1}}],[\"concurrentlinkedqueue\",{\"1\":{\"23\":1}}],[\"concurrentlinkeddeque\",{\"1\":{\"23\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"58\":2,\"103\":1}}],[\"concurrenthashmap<messagequeue\",{\"1\":{\"58\":1}}],[\"concurrenthashmap\",{\"1\":{\"23\":1,\"26\":2,\"98\":2}}],[\"concurrent\",{\"0\":{\"23\":1,\"26\":1},\"1\":{\"23\":3,\"24\":2,\"26\":4}}],[\"configurations\",{\"1\":{\"31\":1}}],[\"config\",{\"1\":{\"3\":2,\"7\":1,\"55\":1,\"89\":1,\"109\":1,\"115\":1}}],[\"crc32\",{\"1\":{\"89\":1}}],[\"created\",{\"1\":{\"98\":1}}],[\"createtopickey\",{\"1\":{\"96\":1}}],[\"createandupdatequeuedata\",{\"1\":{\"89\":1}}],[\"createresponsecommand\",{\"1\":{\"89\":1}}],[\"createnamesrvcontroller\",{\"1\":{\"83\":1}}],[\"createbrokercontroller\",{\"1\":{\"39\":1,\"42\":1,\"64\":3}}],[\"create\",{\"1\":{\"9\":1,\"55\":1,\"96\":1,\"98\":4,\"103\":1}}],[\"creatememoryhistory\",{\"1\":{\"3\":2}}],[\"cross\",{\"1\":{\"6\":3}}],[\"clonemessage\",{\"1\":{\"103\":2}}],[\"clone\",{\"1\":{\"103\":1}}],[\"closechannel\",{\"1\":{\"84\":2}}],[\"close\",{\"1\":{\"66\":1,\"84\":1}}],[\"closemaster\",{\"1\":{\"66\":3}}],[\"closedchannelexception\",{\"1\":{\"65\":1}}],[\"clusteraddrtable\",{\"1\":{\"81\":1,\"84\":4,\"87\":1,\"88\":2,\"89\":4}}],[\"clustername\",{\"1\":{\"81\":1,\"84\":5,\"87\":1,\"88\":2,\"89\":4}}],[\"cluster\",{\"1\":{\"80\":1,\"84\":3,\"87\":1,\"88\":1}}],[\"clustering\",{\"1\":{\"49\":1,\"55\":2,\"57\":1,\"58\":1}}],[\"clienterrorcode\",{\"1\":{\"101\":4}}],[\"clientconfig\",{\"1\":{\"55\":1}}],[\"clientid=\",{\"1\":{\"58\":1}}],[\"clientid\",{\"1\":{\"55\":2,\"98\":2}}],[\"clienthousekeepingservice\",{\"1\":{\"39\":3}}],[\"client\",{\"1\":{\"39\":3,\"55\":4,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"80\":1,\"94\":1,\"98\":4}}],[\"classfilter\",{\"1\":{\"57\":3}}],[\"class\",{\"1\":{\"31\":2,\"57\":3,\"69\":1,\"83\":1,\"89\":3}}],[\"classes\",{\"1\":{\"31\":1}}],[\"cleanexpiremsgexecutors\",{\"1\":{\"55\":1}}],[\"clean\",{\"1\":{\"9\":1,\"84\":1}}],[\"cl\",{\"1\":{\"4\":1}}],[\"i++\",{\"1\":{\"94\":1,\"116\":1}}],[\"ip\",{\"1\":{\"89\":3,\"102\":1}}],[\"id\",{\"1\":{\"58\":2,\"64\":1,\"69\":2,\"89\":3,\"96\":1}}],[\"ide\",{\"1\":{\"41\":1}}],[\"illegal\",{\"1\":{\"57\":2,\"115\":1}}],[\"ignored\",{\"1\":{\"57\":1}}],[\"ignore\",{\"1\":{\"39\":1}}],[\"ismappedfilematchedrecover\",{\"1\":{\"119\":1}}],[\"istransientstorepoolenable\",{\"1\":{\"115\":2}}],[\"istimetoreportoffset\",{\"1\":{\"66\":1}}],[\"iswaitstoremsgok\",{\"1\":{\"115\":1}}],[\"isfirstcreateinqueue\",{\"1\":{\"116\":1}}],[\"isfull\",{\"1\":{\"115\":1}}],[\"isforceregister\",{\"1\":{\"39\":1}}],[\"ishavetopicrouterinfo\",{\"1\":{\"103\":1}}],[\"isretryanotherbrokerwhennotstoreok\",{\"1\":{\"101\":1}}],[\"isrejecttransactionmessage\",{\"1\":{\"42\":1}}],[\"isbrokertopicconfigchanged\",{\"1\":{\"89\":1}}],[\"issues\",{\"1\":{\"103\":1}}],[\"issuggestpullingfromslave\",{\"1\":{\"69\":1}}],[\"issendmessagewithvipchannel\",{\"1\":{\"98\":1}}],[\"isstopped\",{\"1\":{\"57\":2,\"58\":1,\"66\":1}}],[\"isok\",{\"1\":{\"115\":1}}],[\"isorder\",{\"1\":{\"58\":4}}],[\"isoder\",{\"1\":{\"58\":1}}],[\"iscqwriteable\",{\"1\":{\"116\":1}}],[\"isconnectbrokerbyuser\",{\"1\":{\"69\":1}}],[\"isconsumeorderly\",{\"1\":{\"58\":1}}],[\"isclassfiltermode\",{\"1\":{\"57\":2}}],[\"ispostsubscriptionwhenpull\",{\"1\":{\"57\":2}}],[\"ispreviouslylocked\",{\"1\":{\"57\":2}}],[\"isextwriteenable\",{\"1\":{\"116\":1}}],[\"isempty\",{\"1\":{\"57\":1,\"67\":1,\"84\":3,\"89\":1}}],[\"isenabledlegercommitlog\",{\"1\":{\"39\":1,\"64\":1,\"116\":1}}],[\"islocked\",{\"1\":{\"57\":1}}],[\"isdropped\",{\"1\":{\"56\":2}}],[\"isunitmode\",{\"1\":{\"55\":1}}],[\"is\",{\"1\":{\"42\":1}}],[\"if\",{\"1\":{\"39\":11,\"42\":2,\"55\":7,\"56\":6,\"57\":24,\"58\":8,\"64\":1,\"65\":4,\"66\":6,\"67\":3,\"69\":5,\"71\":3,\"84\":13,\"89\":15,\"97\":1,\"98\":3,\"101\":14,\"103\":8,\"110\":1,\"115\":10,\"116\":7,\"119\":1}}],[\"impl\",{\"1\":{\"57\":2}}],[\"implementation\",{\"1\":{\"31\":1}}],[\"import\",{\"1\":{\"3\":1}}],[\"i\",{\"1\":{\"19\":2,\"94\":2,\"108\":1,\"116\":2}}],[\"io\",{\"1\":{\"13\":4,\"66\":1,\"67\":5,\"68\":1,\"84\":1,\"110\":8,\"114\":1}}],[\"item\",{\"1\":{\"89\":3}}],[\"iterator<queuedata>\",{\"1\":{\"84\":1}}],[\"iterator<entry<long\",{\"1\":{\"84\":1,\"89\":1}}],[\"iterator<entry<string\",{\"1\":{\"84\":5}}],[\"iterator\",{\"1\":{\"84\":7,\"89\":1}}],[\"itqueuedata\",{\"1\":{\"84\":4}}],[\"ittopicqueuetable\",{\"1\":{\"84\":4}}],[\"itbrokeraddrtable\",{\"1\":{\"84\":4}}],[\"itbrokerlivetable\",{\"1\":{\"84\":3}}],[\"it\",{\"1\":{\"3\":1,\"57\":1,\"84\":13,\"89\":4}}],[\"innodb\",{\"1\":{\"108\":1}}],[\"inner\",{\"1\":{\"98\":2}}],[\"invokesyncimpl\",{\"1\":{\"103\":1}}],[\"invokeid\",{\"1\":{\"101\":9}}],[\"incrementandget\",{\"1\":{\"103\":1}}],[\"include\",{\"1\":{\"31\":1}}],[\"initiate\",{\"1\":{\"102\":1}}],[\"initialize\",{\"1\":{\"42\":1,\"83\":1,\"84\":1}}],[\"index文件最后的刷盘时间戳\",{\"1\":{\"119\":1}}],[\"indexmsgtimestamp\",{\"1\":{\"113\":1,\"119\":1}}],[\"indexcount\",{\"1\":{\"112\":5}}],[\"indexheader\",{\"1\":{\"112\":4}}],[\"indexdata\",{\"1\":{\"112\":8}}],[\"indexfile\",{\"0\":{\"118\":1},\"1\":{\"112\":5,\"113\":1,\"116\":1,\"119\":2}}],[\"index\",{\"0\":{\"112\":1},\"1\":{\"76\":1,\"108\":3,\"109\":1,\"112\":11,\"119\":3}}],[\"inetsocketaddress\",{\"1\":{\"65\":1}}],[\"integer\",{\"1\":{\"103\":1,\"116\":1}}],[\"interruptedexception\",{\"1\":{\"57\":2,\"100\":1,\"101\":4,\"116\":1}}],[\"interval\",{\"1\":{\"56\":3,\"66\":3}}],[\"interface\",{\"1\":{\"30\":1}}],[\"intro\",{\"1\":{\"101\":1,\"103\":1}}],[\"int\",{\"1\":{\"57\":4,\"69\":1,\"88\":4,\"94\":1,\"96\":6,\"101\":2,\"102\":2,\"103\":1,\"112\":1,\"116\":4,\"119\":1}}],[\"info\",{\"1\":{\"55\":2,\"57\":5,\"58\":1,\"66\":2,\"84\":7,\"89\":1,\"98\":1,\"101\":5,\"116\":1}}],[\"information\",{\"1\":{\"3\":1,\"110\":1}}],[\"instance\",{\"1\":{\"98\":6,\"103\":2}}],[\"instanceof\",{\"1\":{\"55\":2,\"101\":4}}],[\"instancename\",{\"1\":{\"55\":1,\"98\":1}}],[\"inatancename\",{\"1\":{\"55\":1}}],[\"in\",{\"1\":{\"3\":2,\"31\":1,\"57\":1,\"84\":1,\"89\":2,\"96\":1,\"102\":1,\"110\":2,\"115\":1}}],[\"ico\",{\"1\":{\"3\":1}}],[\"ps\",{\"1\":{\"104\":1,\"110\":1}}],[\"pid\",{\"1\":{\"98\":1}}],[\"pid+纳秒级时间戳\",{\"1\":{\"55\":1}}],[\"p\",{\"1\":{\"81\":1}}],[\"physicoffset\",{\"1\":{\"116\":3}}],[\"physicmsgtimestamp\",{\"1\":{\"113\":1,\"119\":1}}],[\"physical\",{\"1\":{\"69\":1}}],[\"phyoffset=\",{\"1\":{\"116\":1}}],[\"phyoffset\",{\"1\":{\"112\":2,\"116\":2}}],[\"phaser\",{\"1\":{\"23\":1,\"27\":1}}],[\"perm\",{\"1\":{\"88\":1}}],[\"permission\",{\"1\":{\"42\":1,\"96\":1}}],[\"persist\",{\"1\":{\"57\":1}}],[\"putint\",{\"1\":{\"116\":1}}],[\"putifabsent\",{\"1\":{\"103\":1}}],[\"putlong\",{\"1\":{\"116\":2}}],[\"putrequest\",{\"1\":{\"115\":1}}],[\"putresultfuture\",{\"1\":{\"115\":3}}],[\"putmessagepositioninfowrapper\",{\"1\":{\"116\":3}}],[\"putmessagepositioninfo\",{\"1\":{\"116\":7}}],[\"putmessagecontext\",{\"1\":{\"115\":1}}],[\"putmessagelock\",{\"1\":{\"115\":1}}],[\"putmessagestatus\",{\"1\":{\"67\":2,\"115\":6}}],[\"putmessage\",{\"1\":{\"57\":1,\"115\":1}}],[\"putmessageresult\",{\"1\":{\"42\":3,\"115\":2}}],[\"put\",{\"1\":{\"57\":3,\"67\":1,\"69\":1,\"89\":5,\"98\":1,\"112\":2,\"115\":5}}],[\"pullfromwhichnodetable\",{\"1\":{\"69\":4}}],[\"pullmsg\",{\"1\":{\"58\":2}}],[\"pullmessageprocessor\",{\"1\":{\"69\":3,\"72\":1}}],[\"pullmessage\",{\"1\":{\"57\":15,\"69\":1,\"72\":1}}],[\"pullmessageservicescheduledthread\",{\"1\":{\"57\":2}}],[\"pullmessageservice这两块\",{\"1\":{\"56\":1}}],[\"pullmessageservice\",{\"0\":{\"57\":1},\"1\":{\"55\":2,\"57\":14,\"60\":1}}],[\"pullkernelimpl\",{\"1\":{\"57\":2,\"69\":1}}],[\"pullsysflag\",{\"1\":{\"57\":1}}],[\"pullinterval\",{\"1\":{\"57\":2}}],[\"pullcallback\",{\"1\":{\"57\":4}}],[\"pullresultext\",{\"1\":{\"69\":1}}],[\"pullresult\",{\"1\":{\"57\":17}}],[\"pullrequestqueue\",{\"1\":{\"57\":9}}],[\"pullrequest\",{\"1\":{\"57\":73}}],[\"pullrequestholdservice\",{\"1\":{\"39\":2}}],[\"pulltimedelaymillswhenexception\",{\"1\":{\"57\":4}}],[\"pullapiwrapper\",{\"1\":{\"55\":3,\"57\":2,\"69\":1}}],[\"pull\",{\"1\":{\"46\":2,\"47\":1,\"53\":1,\"54\":1,\"55\":1,\"57\":12,\"58\":1,\"60\":2,\"77\":3}}],[\"push2slavemaxoffset\",{\"1\":{\"67\":8}}],[\"pushconsumer\",{\"1\":{\"55\":1}}],[\"push\",{\"1\":{\"46\":3,\"47\":1,\"53\":1,\"55\":2,\"58\":2,\"77\":2}}],[\"public\",{\"1\":{\"39\":2,\"55\":1,\"56\":2,\"57\":10,\"58\":2,\"64\":1,\"66\":1,\"67\":1,\"69\":2,\"71\":2,\"84\":2,\"89\":2,\"90\":1,\"96\":1,\"97\":1,\"98\":2,\"100\":1,\"101\":2,\"102\":1,\"103\":2,\"115\":3,\"116\":2,\"119\":2}}],[\"position\",{\"1\":{\"111\":1}}],[\"pos\",{\"1\":{\"102\":3}}],[\"port\",{\"1\":{\"89\":1}}],[\"port>\",{\"1\":{\"89\":2}}],[\"point\",{\"0\":{\"51\":1}}],[\"pom\",{\"0\":{\"37\":1},\"1\":{\"37\":1}}],[\"pools\",{\"1\":{\"31\":1}}],[\"pre\",{\"1\":{\"116\":1}}],[\"preindexno\",{\"1\":{\"112\":1}}],[\"prefix\",{\"1\":{\"58\":2}}],[\"prevbody\",{\"1\":{\"103\":2}}],[\"prevbrokerliveinfo\",{\"1\":{\"89\":2}}],[\"prevrequestoffset\",{\"1\":{\"57\":5}}],[\"previouslylocked\",{\"1\":{\"57\":1}}],[\"prepared\",{\"1\":{\"42\":1,\"116\":1}}],[\"prime\",{\"1\":{\"57\":3}}],[\"private\",{\"1\":{\"56\":1,\"57\":9,\"58\":2,\"65\":1,\"67\":2,\"71\":1,\"81\":5,\"84\":1,\"87\":5,\"88\":12,\"96\":11,\"101\":1,\"102\":1,\"103\":17,\"112\":1,\"116\":1}}],[\"priorityblockingqueue\",{\"1\":{\"23\":1}}],[\"printstacktrace\",{\"1\":{\"94\":1}}],[\"printf\",{\"1\":{\"94\":1}}],[\"print\",{\"1\":{\"10\":1}}],[\"protocol\",{\"1\":{\"89\":1}}],[\"protected\",{\"1\":{\"58\":3,\"96\":1,\"103\":2}}],[\"producertable\",{\"1\":{\"98\":3}}],[\"producergroup\",{\"1\":{\"96\":4,\"97\":1,\"98\":8}}],[\"producergroupname\",{\"1\":{\"94\":1}}],[\"producer\",{\"0\":{\"95\":1,\"99\":1},\"1\":{\"54\":1,\"55\":1,\"67\":2,\"77\":6,\"91\":1,\"94\":7,\"95\":1,\"98\":18,\"99\":3,\"101\":4,\"103\":2,\"104\":2}}],[\"property\",{\"1\":{\"42\":1}}],[\"properties\",{\"0\":{\"25\":1},\"1\":{\"24\":1,\"102\":1,\"112\":2}}],[\"process\",{\"1\":{\"110\":1}}],[\"processreadevent\",{\"1\":{\"66\":1,\"68\":1}}],[\"processrequest\",{\"1\":{\"42\":1,\"69\":3,\"72\":1}}],[\"processpullresult\",{\"1\":{\"57\":1,\"69\":1}}],[\"processconsumeresult\",{\"1\":{\"56\":1,\"59\":1}}],[\"processqueuetable\",{\"1\":{\"58\":4}}],[\"processqueue>\",{\"1\":{\"58\":2}}],[\"processqueue\",{\"1\":{\"56\":15,\"57\":14,\"58\":1}}],[\"processor\",{\"1\":{\"41\":2,\"42\":4,\"81\":1,\"89\":2}}],[\"processing\",{\"1\":{\"31\":1}}],[\"providing\",{\"1\":{\"31\":1}}],[\"provides\",{\"1\":{\"31\":1}}],[\"provider\",{\"1\":{\"6\":2}}],[\"provide\",{\"1\":{\"3\":1,\"31\":1}}],[\"pro\",{\"1\":{\"3\":2}}],[\"pagecache\",{\"1\":{\"115\":1,\"120\":6}}],[\"page\",{\"1\":{\"110\":2,\"115\":1}}],[\"parseint\",{\"1\":{\"103\":1}}],[\"parselong\",{\"1\":{\"58\":1}}],[\"parseboolean\",{\"1\":{\"42\":1}}],[\"part\",{\"1\":{\"57\":1}}],[\"palette\",{\"1\":{\"10\":1}}],[\"package\",{\"1\":{\"6\":2}}],[\"pat\",{\"1\":{\"4\":1,\"5\":2}}],[\"pnpm\",{\"1\":{\"3\":5,\"6\":3,\"9\":4}}],[\"please\",{\"1\":{\"3\":1,\"98\":1}}],[\"plugins\",{\"1\":{\"3\":1}}],[\"plugin\",{\"1\":{\"3\":4,\"7\":2}}],[\"ssd\",{\"1\":{\"110\":4}}],[\"should\",{\"1\":{\"103\":1}}],[\"shutdown\",{\"1\":{\"55\":1,\"57\":1,\"94\":1,\"98\":1,\"115\":1}}],[\"sms\",{\"1\":{\"101\":4}}],[\"same\",{\"1\":{\"89\":1}}],[\"salve\",{\"1\":{\"67\":2}}],[\"s\",{\"1\":{\"84\":2,\"94\":1,\"101\":10}}],[\"swapbytebuffer\",{\"1\":{\"67\":1}}],[\"switch\",{\"1\":{\"55\":2,\"57\":1,\"58\":1,\"64\":1,\"89\":2,\"98\":2,\"101\":1,\"103\":2,\"115\":1,\"116\":1}}],[\"size\",{\"1\":{\"58\":3,\"69\":1,\"102\":2,\"111\":4,\"116\":13,\"119\":1}}],[\"sd\",{\"1\":{\"57\":5}}],[\"some\",{\"1\":{\"66\":1}}],[\"socket\",{\"1\":{\"89\":2}}],[\"socketaddress\",{\"1\":{\"65\":4}}],[\"socketchannel\",{\"1\":{\"65\":5,\"68\":1}}],[\"sort\",{\"1\":{\"58\":2}}],[\"so\",{\"1\":{\"57\":1,\"66\":1}}],[\"sysflag\",{\"1\":{\"57\":2}}],[\"system\",{\"1\":{\"56\":1,\"58\":1,\"65\":1,\"84\":2,\"89\":2,\"94\":1,\"96\":1,\"101\":8,\"102\":2,\"103\":3}}],[\"syncsubscriptiongroupconfig\",{\"1\":{\"71\":1}}],[\"syncdelayoffset\",{\"1\":{\"71\":1}}],[\"syncconsumeroffset\",{\"1\":{\"71\":1}}],[\"synctopicconfig\",{\"1\":{\"71\":1}}],[\"synchronization\",{\"1\":{\"115\":1}}],[\"synchronizers\",{\"0\":{\"27\":1},\"1\":{\"24\":1}}],[\"synchronizedmap\",{\"1\":{\"26\":2}}],[\"synchronized\",{\"1\":{\"13\":1,\"26\":2,\"55\":1,\"56\":1}}],[\"synchronise\",{\"1\":{\"71\":1}}],[\"syncall\",{\"1\":{\"71\":3}}],[\"syncflushtimeout\",{\"1\":{\"67\":1}}],[\"sync\",{\"1\":{\"64\":1,\"101\":4,\"103\":1,\"115\":3}}],[\"syntaxerror\",{\"1\":{\"3\":1}}],[\"success\",{\"1\":{\"89\":1}}],[\"suggest\",{\"1\":{\"69\":13}}],[\"suggesttodo\",{\"1\":{\"55\":1,\"98\":2,\"101\":2}}],[\"suspend\",{\"1\":{\"57\":3}}],[\"subtable\",{\"1\":{\"58\":3}}],[\"subscriptiongroup\",{\"1\":{\"109\":1}}],[\"subscriptiongroupconfig\",{\"1\":{\"69\":1}}],[\"subscriptioninner\",{\"1\":{\"58\":2}}],[\"subscription\",{\"1\":{\"57\":1}}],[\"subscriptiondata>\",{\"1\":{\"58\":4}}],[\"subscriptiondata\",{\"1\":{\"57\":4}}],[\"subexpression\",{\"1\":{\"57\":4}}],[\"submitreplicarequest\",{\"1\":{\"115\":1}}],[\"submit\",{\"1\":{\"56\":1}}],[\"submitconsumerequest\",{\"1\":{\"56\":4,\"57\":3}}],[\"submitconsumerequestlater\",{\"1\":{\"56\":1}}],[\"submitflushrequest\",{\"1\":{\"42\":1,\"115\":4}}],[\"slotpos\",{\"1\":{\"112\":2}}],[\"slot\",{\"1\":{\"112\":6}}],[\"slavesynchronize\",{\"1\":{\"71\":4}}],[\"slavesyncfuture\",{\"1\":{\"71\":5}}],[\"slaveackoffset\",{\"1\":{\"68\":1}}],[\"slaverequestoffset\",{\"1\":{\"68\":1}}],[\"slave刷盘超时的状态\",{\"1\":{\"67\":1}}],[\"slavemaxoffset\",{\"1\":{\"66\":1}}],[\"slave\",{\"0\":{\"71\":1},\"1\":{\"40\":1,\"61\":2,\"62\":2,\"63\":6,\"64\":3,\"65\":4,\"66\":4,\"67\":9,\"68\":4,\"69\":4,\"70\":2,\"71\":3,\"89\":4,\"115\":2,\"116\":2}}],[\"sleep\",{\"1\":{\"28\":1,\"116\":1}}],[\"still\",{\"1\":{\"101\":1}}],[\"step\",{\"1\":{\"66\":1}}],[\"step4\",{\"0\":{\"66\":1},\"1\":{\"63\":1}}],[\"step3\",{\"0\":{\"66\":1},\"1\":{\"63\":1,\"66\":2}}],[\"step2\",{\"0\":{\"65\":1},\"1\":{\"63\":1,\"66\":1}}],[\"step1\",{\"0\":{\"64\":1},\"1\":{\"63\":1}}],[\"structure\",{\"1\":{\"84\":1}}],[\"strategy\",{\"1\":{\"58\":4}}],[\"string>\",{\"1\":{\"84\":1,\"89\":3}}],[\"string>>\",{\"1\":{\"84\":1,\"89\":1}}],[\"string2socketaddress\",{\"1\":{\"65\":1}}],[\"string\",{\"1\":{\"57\":3,\"58\":2,\"65\":2,\"84\":8,\"88\":4,\"89\":6,\"96\":4,\"101\":9,\"103\":1,\"112\":2}}],[\"static\",{\"1\":{\"58\":1,\"102\":1}}],[\"status\",{\"1\":{\"56\":2}}],[\"state\",{\"1\":{\"55\":1,\"98\":1}}],[\"startfactory\",{\"1\":{\"98\":2}}],[\"startswith\",{\"1\":{\"58\":2}}],[\"startscheduledtask\",{\"1\":{\"55\":1,\"98\":1}}],[\"started\",{\"1\":{\"55\":1,\"57\":1,\"66\":1,\"98\":1}}],[\"startprocessorbyha\",{\"1\":{\"39\":1}}],[\"start\",{\"0\":{\"95\":1,\"97\":1,\"98\":1},\"1\":{\"39\":15,\"55\":23,\"57\":2,\"64\":11,\"65\":1,\"83\":2,\"92\":1,\"94\":2,\"96\":1,\"97\":6,\"98\":10,\"99\":1,\"101\":2,\"115\":4}}],[\"storestatsservice\",{\"1\":{\"115\":2}}],[\"storecheckpoint\",{\"1\":{\"113\":1}}],[\"storepathrootdir\",{\"1\":{\"110\":1}}],[\"storeutil\",{\"1\":{\"69\":1}}],[\"store\",{\"1\":{\"37\":1,\"60\":1,\"62\":2,\"108\":1,\"110\":2,\"111\":4,\"112\":1,\"115\":1,\"116\":4}}],[\"styles\",{\"1\":{\"10\":2}}],[\"sql语句\",{\"1\":{\"19\":1}}],[\"sql\",{\"1\":{\"13\":1,\"19\":3}}],[\"space\",{\"1\":{\"116\":1}}],[\"specify\",{\"1\":{\"98\":1}}],[\"specified\",{\"1\":{\"55\":1}}],[\"spin\",{\"1\":{\"115\":1}}],[\"spi\",{\"1\":{\"13\":1}}],[\"springcloud\",{\"1\":{\"13\":1}}],[\"springboot\",{\"1\":{\"13\":1}}],[\"spring\",{\"1\":{\"13\":1}}],[\"scannotactivebroker\",{\"1\":{\"84\":4}}],[\"sc\",{\"1\":{\"65\":1}}],[\"schedule\",{\"1\":{\"55\":1,\"57\":1}}],[\"scheduleatfixedrate\",{\"1\":{\"39\":1,\"71\":1,\"84\":1}}],[\"scheduledtask\",{\"1\":{\"71\":1}}],[\"scheduledthreadpoolexecutor\",{\"1\":{\"31\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"23\":1,\"30\":1,\"39\":1,\"55\":2,\"57\":4,\"71\":1,\"84\":4,\"103\":2}}],[\"scss文件中进行修改\",{\"1\":{\"10\":1}}],[\"scripts\",{\"1\":{\"6\":1}}],[\"src\",{\"1\":{\"6\":2,\"10\":2}}],[\"sequence\",{\"1\":{\"110\":1}}],[\"sequential\",{\"1\":{\"110\":3}}],[\"seconds\",{\"1\":{\"84\":1}}],[\"secrets\",{\"1\":{\"5\":1}}],[\"selectonemessagequeue\",{\"1\":{\"101\":2}}],[\"selector\",{\"1\":{\"65\":1,\"66\":1}}],[\"select\",{\"1\":{\"66\":1}}],[\"selectionkey\",{\"1\":{\"65\":1}}],[\"selectconsumer\",{\"1\":{\"57\":1}}],[\"servicethread\",{\"1\":{\"57\":2,\"64\":1}}],[\"services\",{\"1\":{\"55\":1}}],[\"servicestate\",{\"1\":{\"55\":10,\"98\":10,\"101\":1,\"103\":3}}],[\"service\",{\"1\":{\"55\":6,\"56\":1,\"57\":4,\"66\":3,\"68\":1,\"81\":1,\"96\":1,\"98\":2,\"115\":4,\"116\":2}}],[\"server\",{\"1\":{\"39\":5,\"43\":1,\"55\":1,\"59\":1,\"81\":1,\"87\":1,\"88\":1}}],[\"sendstatus\",{\"1\":{\"101\":1}}],[\"sendkernelimpl\",{\"1\":{\"101\":7,\"103\":3}}],[\"sendcallback\",{\"1\":{\"101\":3,\"103\":1}}],[\"senddefaultimpl\",{\"1\":{\"101\":5}}],[\"sendresult\",{\"1\":{\"94\":3,\"100\":1,\"101\":12,\"103\":2}}],[\"sendmsgtimeout\",{\"1\":{\"96\":1}}],[\"sendmsgback\",{\"1\":{\"59\":1}}],[\"sendmessage\",{\"1\":{\"103\":2}}],[\"sendmessagewithvipchannel=\",{\"1\":{\"98\":1}}],[\"sendmessagehooklist\",{\"1\":{\"42\":1,\"103\":1}}],[\"sendmessageprocessor\",{\"0\":{\"42\":1},\"1\":{\"42\":3,\"115\":1}}],[\"sendheartbeattoallbrokerwithlock\",{\"1\":{\"55\":1,\"98\":1}}],[\"sending\",{\"1\":{\"42\":1}}],[\"sendprocessor\",{\"1\":{\"42\":2}}],[\"send\",{\"0\":{\"99\":1,\"100\":1,\"101\":1},\"1\":{\"41\":5,\"42\":1,\"59\":1,\"94\":1,\"99\":1,\"100\":2,\"101\":9,\"103\":1,\"104\":1}}],[\"semaphore\",{\"1\":{\"23\":1,\"27\":1}}],[\"see\",{\"1\":{\"3\":1}}],[\"setflushedwhere\",{\"1\":{\"116\":1}}],[\"setlogicsmsgtimestamp\",{\"1\":{\"116\":1}}],[\"setlistenport\",{\"1\":{\"64\":1}}],[\"setphysicmsgtimestamp\",{\"1\":{\"116\":1}}],[\"setputmessageentiretimemax\",{\"1\":{\"115\":1}}],[\"setproducergroup\",{\"1\":{\"97\":1}}],[\"setpreviouslylocked\",{\"1\":{\"57\":1}}],[\"setuniqid\",{\"1\":{\"102\":1}}],[\"setup\",{\"1\":{\"3\":4}}],[\"setresponsecode\",{\"1\":{\"101\":5}}],[\"setremark\",{\"1\":{\"42\":1,\"89\":2}}],[\"settopic\",{\"1\":{\"100\":1,\"101\":1,\"102\":2,\"103\":1}}],[\"settimestamp\",{\"1\":{\"89\":1}}],[\"setbody等待发送\",{\"1\":{\"102\":1}}],[\"setbody\",{\"1\":{\"89\":1,\"102\":2,\"103\":1}}],[\"setbrokerid\",{\"1\":{\"64\":1}}],[\"sethaserveraddr\",{\"1\":{\"89\":2}}],[\"sethalistenport\",{\"1\":{\"64\":1}}],[\"set<integer>\",{\"1\":{\"96\":1}}],[\"set<string>\",{\"1\":{\"84\":1,\"89\":1}}],[\"set<string>>\",{\"1\":{\"84\":1}}],[\"set<string>>>\",{\"1\":{\"84\":1}}],[\"set<string\",{\"1\":{\"81\":1,\"87\":1,\"88\":1}}],[\"set<messagequeue>\",{\"1\":{\"58\":2}}],[\"set<messagequeue>>\",{\"1\":{\"58\":2}}],[\"setsuggestwhichbrokerid\",{\"1\":{\"69\":2}}],[\"setsuggestpullingfromslave\",{\"1\":{\"69\":1}}],[\"setaccessmessageinmemorymaxratio\",{\"1\":{\"69\":1}}],[\"setallocatemessagequeuestrategy\",{\"1\":{\"55\":1,\"58\":1}}],[\"setdropped\",{\"1\":{\"57\":1}}],[\"setnextoffset\",{\"1\":{\"57\":4}}],[\"setoffsetstore\",{\"1\":{\"55\":1}}],[\"setmasteraddr\",{\"1\":{\"71\":2,\"89\":2}}],[\"setmqclientfactory\",{\"1\":{\"55\":1,\"58\":1}}],[\"setmessagemodel\",{\"1\":{\"55\":1,\"58\":1}}],[\"setcommittedwhere\",{\"1\":{\"116\":1}}],[\"setcounter\",{\"1\":{\"89\":1}}],[\"setconsumergroup\",{\"1\":{\"55\":1,\"58\":1}}],[\"setcode\",{\"1\":{\"42\":1,\"89\":2}}],[\"set\",{\"1\":{\"3\":1,\"69\":1,\"115\":1}}],[\"searchproplugin\",{\"1\":{\"3\":1}}],[\"searchpro\",{\"1\":{\"3\":1}}],[\"search\",{\"1\":{\"3\":2}}],[\"svg\",{\"1\":{\"3\":2}}],[\"插件\",{\"0\":{\"7\":1}}],[\"插件使用错误\",{\"1\":{\"3\":1}}],[\"插件更新了\",{\"1\":{\"3\":1}}],[\"<=\",{\"1\":{\"116\":1}}],[\"<0\",{\"1\":{\"89\":1}}],[\"<1\",{\"1\":{\"89\":1}}],[\"<\",{\"1\":{\"57\":3,\"67\":1,\"84\":3,\"94\":1,\"101\":2,\"103\":2,\"116\":1,\"119\":1}}],[\"<catalog\",{\"1\":{\"3\":1}}],[\"<catalog>\",{\"1\":{\"3\":1}}],[\"<autocatalog\",{\"1\":{\"3\":1}}],[\">>\",{\"1\":{\"81\":1,\"87\":1,\"88\":1}}],[\">=\",{\"1\":{\"67\":3,\"89\":1}}],[\">服务\",{\"1\":{\"50\":1}}],[\">网关\",{\"1\":{\"50\":1}}],[\">即可\",{\"1\":{\"3\":1}}],[\">\",{\"1\":{\"3\":1,\"39\":3,\"52\":1,\"55\":2,\"56\":1,\"57\":11,\"58\":2,\"64\":1,\"66\":3,\"67\":3,\"69\":1,\"81\":1,\"83\":3,\"84\":2,\"87\":2,\"88\":2,\"101\":1,\"102\":2,\"103\":1,\"110\":2,\"112\":1,\"115\":4}}],[\"目的是为了区分不同的\",{\"1\":{\"98\":1}}],[\"目前可以简单理解为就是\",{\"1\":{\"110\":1}}],[\"目前还不知道所有\",{\"1\":{\"102\":1}}],[\"目前还被我下了\",{\"1\":{\"3\":1}}],[\"目前已同步的最大\",{\"1\":{\"67\":1}}],[\"目前一共六种负载均衡策略\",{\"1\":{\"58\":1}}],[\"目前执行器\",{\"1\":{\"56\":1}}],[\"目前\",{\"1\":{\"50\":1}}],[\"目前消息队列是单独更新\",{\"1\":{\"13\":1}}],[\"目录\",{\"1\":{\"110\":1,\"111\":1}}],[\"目录下的\",{\"1\":{\"110\":1}}],[\"目录下的三个文件进行自定义\",{\"1\":{\"10\":1}}],[\"目录下没有readme\",{\"1\":{\"11\":1}}],[\"目录下必须有\",{\"1\":{\"6\":1}}],[\"目录有约定\",{\"1\":{\"6\":1}}],[\"目录自动生成\",{\"1\":{\"3\":1}}],[\"反馈给\",{\"1\":{\"69\":1}}],[\"反馈已同步的偏移量\",{\"1\":{\"68\":1}}],[\"反射\",{\"1\":{\"13\":1}}],[\"反正一个意思\",{\"1\":{\"115\":1}}],[\"反正不懂\",{\"1\":{\"6\":1}}],[\"反正默认启用\",{\"1\":{\"3\":1}}],[\"反正浏览量最高的两篇分别是雷蛇键盘无响应和lastpass密码错误\",{\"1\":{\"3\":1}}],[\"反而不用去管他\",{\"1\":{\"3\":1}}],[\"合理利用\",{\"1\":{\"3\":1}}],[\"blank\",{\"1\":{\"110\":3,\"116\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"103\":2}}],[\"blog\",{\"1\":{\"1\":2,\"3\":1}}],[\"bytes\",{\"1\":{\"102\":4}}],[\"byte\",{\"1\":{\"89\":2,\"102\":5,\"111\":5,\"112\":11,\"113\":1,\"116\":1}}],[\"bytebufferindex\",{\"1\":{\"116\":6}}],[\"bytebuffer\",{\"1\":{\"67\":1}}],[\"bytebufferread\",{\"1\":{\"67\":2}}],[\"bodylength=\",{\"1\":{\"115\":1}}],[\"body\",{\"1\":{\"59\":1,\"96\":1,\"103\":3}}],[\"boolean\",{\"1\":{\"42\":1,\"55\":1,\"56\":2,\"57\":6,\"58\":3,\"65\":1,\"66\":2,\"67\":2,\"84\":2,\"89\":1,\"96\":1,\"98\":2,\"101\":1,\"103\":1,\"116\":3,\"119\":1}}],[\"busy\",{\"1\":{\"120\":1}}],[\"buff\",{\"1\":{\"102\":1}}],[\"buffer\",{\"1\":{\"102\":4,\"116\":1}}],[\"buyer\",{\"1\":{\"96\":1}}],[\"bug\",{\"1\":{\"57\":1,\"103\":1,\"116\":1}}],[\"but\",{\"1\":{\"57\":1,\"58\":1}}],[\"buildsysflag\",{\"1\":{\"57\":1}}],[\"build\",{\"1\":{\"3\":2,\"6\":5,\"9\":1,\"116\":1}}],[\"being\",{\"1\":{\"110\":1}}],[\"be\",{\"1\":{\"103\":1,\"110\":1,\"115\":1}}],[\"been\",{\"1\":{\"98\":1}}],[\"begin\",{\"1\":{\"112\":1}}],[\"beginphyoffset\",{\"1\":{\"112\":1}}],[\"beginstarttime\",{\"1\":{\"103\":2}}],[\"beginaccept\",{\"1\":{\"64\":1,\"67\":1}}],[\"begintimestamp\",{\"1\":{\"112\":2}}],[\"begintimestampprev\",{\"1\":{\"101\":12}}],[\"begintimestampfirst\",{\"1\":{\"101\":5}}],[\"begintime\",{\"1\":{\"56\":3,\"115\":2}}],[\"because\",{\"1\":{\"57\":1,\"84\":6}}],[\"before于\",{\"1\":{\"25\":1}}],[\"before\",{\"1\":{\"25\":3,\"98\":1,\"110\":1}}],[\"break\",{\"1\":{\"55\":5,\"56\":6,\"57\":4,\"58\":3,\"64\":1,\"67\":1,\"84\":3,\"98\":2,\"101\":3,\"103\":3,\"116\":2}}],[\"breadcrumb\",{\"1\":{\"3\":2}}],[\"broadcasting\",{\"1\":{\"49\":1,\"55\":1,\"58\":1}}],[\"brokerssent\",{\"1\":{\"101\":5}}],[\"brokerstatsmanager\",{\"1\":{\"39\":2}}],[\"brokerstartup\",{\"1\":{\"38\":1,\"39\":3,\"64\":3,\"69\":1}}],[\"brokerversion\",{\"1\":{\"89\":2}}],[\"brokerdata\",{\"1\":{\"84\":7,\"88\":1,\"89\":11}}],[\"brokerdata>>\",{\"1\":{\"84\":1}}],[\"brokerdata>\",{\"1\":{\"81\":1,\"87\":1,\"88\":1}}],[\"brokercluster\",{\"1\":{\"81\":1}}],[\"brokerconfig\",{\"1\":{\"39\":2,\"64\":1}}],[\"brokercontroller\",{\"1\":{\"39\":4,\"40\":1,\"41\":1,\"42\":4,\"64\":2,\"71\":2,\"115\":1}}],[\"brokerliveinfo\",{\"1\":{\"84\":1,\"88\":2,\"89\":8}}],[\"brokerliveinfo>>\",{\"1\":{\"84\":2}}],[\"brokerliveinfo>\",{\"1\":{\"81\":1,\"84\":3,\"87\":1,\"88\":1}}],[\"brokerlivetable\",{\"1\":{\"81\":1,\"84\":11,\"87\":1,\"88\":2,\"89\":4}}],[\"brokeraddrsmap\",{\"1\":{\"89\":2}}],[\"brokeraddrs\",{\"1\":{\"88\":1}}],[\"brokeraddrfound\",{\"1\":{\"84\":11}}],[\"brokeraddr\",{\"1\":{\"81\":2,\"84\":11,\"87\":2,\"88\":5,\"89\":9,\"103\":2}}],[\"brokeraddrtable\",{\"1\":{\"81\":1,\"84\":3,\"87\":1,\"88\":2,\"89\":6}}],[\"brokeraddress\",{\"1\":{\"69\":1}}],[\"brokerhousekeepingservice\",{\"1\":{\"81\":1,\"84\":2}}],[\"brokerrole\",{\"1\":{\"69\":1,\"71\":2,\"116\":1}}],[\"brokerid\",{\"1\":{\"64\":3,\"65\":2,\"69\":8,\"84\":3,\"87\":3,\"88\":2,\"89\":7}}],[\"brokerinfo\",{\"1\":{\"40\":3}}],[\"brokerbusy\",{\"1\":{\"57\":4}}],[\"brokernames\",{\"1\":{\"84\":3,\"89\":5}}],[\"brokernamefound\",{\"1\":{\"84\":7}}],[\"brokername\",{\"1\":{\"57\":1,\"69\":2,\"81\":2,\"84\":2,\"87\":3,\"88\":6,\"89\":8,\"101\":1}}],[\"brokerfastfailure\",{\"1\":{\"39\":2}}],[\"brokerouterapi\",{\"1\":{\"39\":3,\"40\":2}}],[\"broker\",{\"0\":{\"35\":1,\"36\":1,\"37\":1,\"89\":1,\"90\":1},\"1\":{\"35\":3,\"36\":1,\"37\":2,\"39\":3,\"40\":9,\"41\":6,\"42\":5,\"43\":1,\"46\":1,\"51\":1,\"55\":5,\"56\":1,\"57\":11,\"59\":1,\"62\":3,\"63\":3,\"64\":3,\"65\":1,\"69\":7,\"70\":1,\"71\":1,\"73\":1,\"76\":3,\"77\":10,\"80\":7,\"81\":2,\"84\":25,\"87\":4,\"88\":6,\"89\":23,\"90\":7,\"91\":1,\"96\":2,\"101\":8,\"103\":1,\"108\":1,\"110\":3,\"115\":3,\"119\":3,\"120\":4}}],[\"binlog\",{\"1\":{\"19\":6,\"21\":1}}],[\"bak\",{\"1\":{\"109\":4}}],[\"batchsize\",{\"1\":{\"56\":1}}],[\"batch\",{\"0\":{\"102\":1},\"1\":{\"41\":1,\"101\":1,\"102\":1}}],[\"based\",{\"1\":{\"31\":1}}],[\"balloon\",{\"1\":{\"7\":1}}],[\"back\",{\"1\":{\"7\":1,\"42\":1,\"59\":1}}],[\"研究路径导航\",{\"1\":{\"3\":1}}],[\"早几年前就修正了我说的问题\",{\"1\":{\"3\":1}}],[\"话说我真的觉得雷蛇那个看起来吊炸天的内置在设备里主动帮你安装驱动功能最大的作用是检测你这把键盘用多久了\",{\"1\":{\"3\":1}}],[\"head\",{\"1\":{\"111\":1}}],[\"header\",{\"1\":{\"103\":1}}],[\"hello\",{\"1\":{\"94\":1}}],[\"hook\",{\"1\":{\"103\":2}}],[\"host\",{\"1\":{\"102\":1}}],[\"housekeeping\",{\"1\":{\"66\":1}}],[\"home\",{\"1\":{\"55\":1,\"110\":2}}],[\"hope\",{\"1\":{\"2\":1,\"3\":1,\"6\":1,\"8\":1,\"9\":1}}],[\"have\",{\"1\":{\"89\":1}}],[\"haconnection\",{\"0\":{\"68\":1},\"1\":{\"67\":2,\"68\":1}}],[\"haclient\",{\"1\":{\"64\":1,\"65\":3,\"66\":4,\"67\":7}}],[\"halistenport\",{\"1\":{\"63\":2,\"64\":5,\"67\":1}}],[\"ha\",{\"0\":{\"61\":1},\"1\":{\"60\":1,\"62\":2,\"63\":1,\"64\":1,\"66\":1,\"70\":1}}],[\"handle\",{\"1\":{\"67\":1,\"71\":1}}],[\"handleschedulemessageservice\",{\"1\":{\"64\":1}}],[\"handleslavesynchronize\",{\"1\":{\"39\":1,\"71\":2}}],[\"handleputmessageresultfuture\",{\"1\":{\"42\":2}}],[\"handler\",{\"1\":{\"41\":4,\"42\":2,\"81\":1,\"89\":3}}],[\"hasnext\",{\"1\":{\"84\":7,\"89\":1}}],[\"haserver\",{\"1\":{\"89\":1}}],[\"haserveraddr\",{\"1\":{\"40\":2,\"89\":3}}],[\"haservice\",{\"0\":{\"67\":1},\"1\":{\"64\":6,\"65\":1,\"66\":3,\"67\":7,\"68\":1}}],[\"hashslotnum\",{\"1\":{\"112\":2}}],[\"hashslot\",{\"1\":{\"112\":4}}],[\"hashslotcount\",{\"1\":{\"112\":2}}],[\"hashset<string>\",{\"1\":{\"89\":1}}],[\"hashset<messagequeue>\",{\"1\":{\"58\":1}}],[\"hash\",{\"1\":{\"111\":4,\"112\":4}}],[\"hashcode\",{\"1\":{\"57\":9,\"102\":1,\"112\":4,\"116\":2}}],[\"hashmap<long\",{\"1\":{\"88\":1,\"89\":1}}],[\"hashmap<string\",{\"1\":{\"81\":5,\"84\":1,\"87\":5,\"88\":5}}],[\"hashmap\",{\"1\":{\"26\":5,\"84\":1,\"89\":1,\"108\":1,\"112\":2}}],[\"has\",{\"1\":{\"57\":1,\"66\":1,\"98\":1}}],[\"happen\",{\"1\":{\"25\":3}}],[\"https\",{\"1\":{\"3\":1,\"103\":1}}],[\"hm\",{\"1\":{\"3\":1}}],[\"谷歌顺利添加了\",{\"1\":{\"3\":1}}],[\"avoid\",{\"1\":{\"102\":1}}],[\"availableprocessors\",{\"1\":{\"103\":2}}],[\"available\",{\"1\":{\"96\":1}}],[\"auto\",{\"1\":{\"96\":1}}],[\"at\",{\"1\":{\"84\":1,\"101\":3}}],[\"atomicinteger\",{\"1\":{\"103\":2}}],[\"atomiclong\",{\"1\":{\"69\":3,\"89\":1}}],[\"atomic\",{\"1\":{\"23\":2}}],[\"aka\",{\"1\":{\"84\":1,\"89\":1,\"96\":1,\"116\":1}}],[\"allbytes\",{\"1\":{\"102\":5}}],[\"allsize\",{\"1\":{\"102\":3}}],[\"all\",{\"1\":{\"84\":1}}],[\"allocaterequest\",{\"1\":{\"115\":2}}],[\"allocateresultset\",{\"1\":{\"58\":7}}],[\"allocateresult\",{\"1\":{\"58\":4}}],[\"allocatemappedfileservice\",{\"1\":{\"115\":5}}],[\"allocatemessagequeuestrategyname=\",{\"1\":{\"58\":2}}],[\"allocatemessagequeuestrategy\",{\"1\":{\"58\":4}}],[\"allocatemessagequeueaveragely\",{\"1\":{\"50\":1,\"58\":1}}],[\"allocate\",{\"1\":{\"58\":2}}],[\"allowed\",{\"1\":{\"3\":1}}],[\"already\",{\"1\":{\"55\":1,\"98\":1}}],[\"appenddata\",{\"1\":{\"66\":1}}],[\"appendtocommitlog\",{\"1\":{\"66\":1}}],[\"append\",{\"1\":{\"66\":1}}],[\"appendmessageresult\",{\"1\":{\"115\":1}}],[\"appendmessagecallback\",{\"1\":{\"115\":1}}],[\"appendmessage\",{\"1\":{\"42\":1,\"66\":1,\"115\":3,\"116\":2}}],[\"apache\",{\"1\":{\"62\":1,\"89\":2,\"103\":1,\"110\":1,\"111\":1,\"112\":1,\"116\":1}}],[\"api\",{\"1\":{\"55\":1,\"103\":1}}],[\"accumulate\",{\"1\":{\"102\":1}}],[\"accessed\",{\"1\":{\"110\":2}}],[\"access\",{\"1\":{\"101\":1,\"110\":4}}],[\"acceptsocketservice\",{\"1\":{\"64\":2,\"67\":7}}],[\"ack\",{\"1\":{\"56\":1,\"59\":1}}],[\"acl\",{\"1\":{\"37\":2,\"73\":1}}],[\"acl等等\",{\"1\":{\"36\":1}}],[\"acl等均有关系\",{\"1\":{\"35\":1}}],[\"action\",{\"1\":{\"3\":4,\"4\":2}}],[\"actions\",{\"1\":{\"3\":4}}],[\"a\",{\"1\":{\"31\":2,\"110\":1}}],[\"assert\",{\"1\":{\"103\":1}}],[\"assists\",{\"1\":{\"31\":1}}],[\"aslist\",{\"1\":{\"96\":1}}],[\"asyncsenderexecutor\",{\"1\":{\"103\":2}}],[\"asyncsenderthreadpoolqueue\",{\"1\":{\"103\":3}}],[\"asyncsendmessage\",{\"1\":{\"42\":3,\"115\":1}}],[\"async\",{\"1\":{\"57\":1,\"64\":1,\"101\":1,\"103\":1,\"115\":1}}],[\"asyncputmessage\",{\"1\":{\"42\":4,\"115\":6}}],[\"asyncpreparemessage\",{\"1\":{\"42\":1}}],[\"asyncprocessrequest\",{\"1\":{\"42\":2}}],[\"asynchronous\",{\"1\":{\"31\":1,\"115\":1}}],[\"as\",{\"1\":{\"31\":2}}],[\"args\",{\"1\":{\"83\":1}}],[\"array\",{\"1\":{\"116\":1}}],[\"arraycopy\",{\"1\":{\"102\":2}}],[\"arraylist<checkforbiddenhook>\",{\"1\":{\"103\":2}}],[\"arraylist<endtransactionhook>\",{\"1\":{\"103\":2}}],[\"arraylist<sendmessagehook>\",{\"1\":{\"103\":2}}],[\"arraylist<byte\",{\"1\":{\"102\":1}}],[\"arraylist<messagequeue>\",{\"1\":{\"58\":1}}],[\"arrays\",{\"1\":{\"96\":1,\"101\":1}}],[\"arrayblockingqueue\",{\"1\":{\"23\":1}}],[\"are\",{\"1\":{\"3\":2}}],[\"aqs\",{\"1\":{\"13\":1,\"23\":2}}],[\"addlast\",{\"1\":{\"116\":2}}],[\"addr\",{\"1\":{\"65\":3}}],[\"address\",{\"1\":{\"55\":1,\"88\":1}}],[\"addall\",{\"1\":{\"58\":2}}],[\"add\",{\"1\":{\"3\":1,\"6\":1,\"89\":2,\"102\":1,\"115\":1}}],[\"another\",{\"1\":{\"98\":1}}],[\"and\",{\"1\":{\"31\":3,\"84\":1,\"103\":1,\"116\":2}}],[\"an\",{\"1\":{\"3\":1}}],[\"analytics\",{\"1\":{\"3\":1}}],[\"a1\",{\"1\":{\"3\":2}}],[\"添加了一个\",{\"1\":{\"84\":1}}],[\"添加新队列失败时\",{\"1\":{\"58\":1}}],[\"添加\",{\"1\":{\"3\":1}}],[\"这篇幅已经太长了\",{\"1\":{\"119\":1}}],[\"这三种\",{\"1\":{\"119\":1}}],[\"这三个属性足够\",{\"1\":{\"57\":1}}],[\"这儿的逻辑跟\",{\"1\":{\"116\":1}}],[\"这跟硬盘的物理设计有关\",{\"1\":{\"110\":1}}],[\"这些数据结构的读写都是直接对内存操作\",{\"1\":{\"108\":1}}],[\"这些简单介绍下\",{\"1\":{\"13\":1}}],[\"这也是为啥所有性能压力的场景我们都要想方设法不让请求直接打在数据库上\",{\"1\":{\"107\":1}}],[\"这也是为什么大家都喜欢在数据库前加一层\",{\"1\":{\"107\":1}}],[\"这段不用看\",{\"1\":{\"116\":1}}],[\"这段\",{\"1\":{\"103\":1}}],[\"这段判定的作用跟上面的\",{\"1\":{\"98\":1}}],[\"这两种角色都看作客户端\",{\"1\":{\"98\":1}}],[\"这是发送异步消息失败也是重试两次\",{\"1\":{\"96\":1}}],[\"这是个\",{\"1\":{\"94\":1}}],[\"这是第二种首次注册的情况\",{\"1\":{\"89\":1}}],[\"这是\",{\"1\":{\"80\":1}}],[\"这是由它的设计决定的\",{\"1\":{\"79\":1}}],[\"这是用户指定\",{\"1\":{\"69\":1}}],[\"这阅读部分代码需要注意一点\",{\"1\":{\"67\":1}}],[\"这一处不规范导致多了一堆迷一样的判定\",{\"1\":{\"84\":1}}],[\"这一步\",{\"1\":{\"69\":1}}],[\"这一步的入口实际上就是在broker\",{\"1\":{\"64\":1}}],[\"这一层从理论模型角度看是加在消费行为之前的\",{\"1\":{\"58\":1}}],[\"这样相当于写消息操作都在堆外内存\",{\"1\":{\"120\":1}}],[\"这样请求方就可以直接从\",{\"1\":{\"115\":1}}],[\"这样当\",{\"1\":{\"89\":1}}],[\"这样什么\",{\"1\":{\"67\":1}}],[\"这样一旦\",{\"1\":{\"62\":1}}],[\"这样才能分辨是什么请求\",{\"1\":{\"41\":1}}],[\"这方法有两种实现\",{\"1\":{\"57\":1}}],[\"这俩也是一套\",{\"1\":{\"103\":1}}],[\"这俩方法就相当于是手动实现了一遍\",{\"1\":{\"67\":1}}],[\"这俩\",{\"1\":{\"57\":1,\"68\":1}}],[\"这么一个初始化方法\",{\"1\":{\"42\":1}}],[\"这就来到了\",{\"1\":{\"108\":1}}],[\"这就跟内存编程产生了极大的不同\",{\"1\":{\"108\":1}}],[\"这就是自动创建主题机制的那个\",{\"1\":{\"96\":1}}],[\"这就是\",{\"1\":{\"71\":1,\"110\":1}}],[\"这就不展开了\",{\"1\":{\"57\":1}}],[\"这就\",{\"1\":{\"37\":1}}],[\"这里相当于默认了\",{\"1\":{\"119\":1}}],[\"这里你就把\",{\"1\":{\"116\":1}}],[\"这里还有个概念是\",{\"1\":{\"115\":1}}],[\"这里还是先不展开说明\",{\"1\":{\"101\":1}}],[\"这里看这好几个分支\",{\"1\":{\"115\":1}}],[\"这里说的消息属性就是\",{\"1\":{\"112\":1}}],[\"这里存储的是\",{\"1\":{\"111\":1}}],[\"这里异步转发的数据实际上就是\",{\"1\":{\"111\":1}}],[\"这里\",{\"1\":{\"98\":1,\"102\":2}}],[\"这里为了满足并发的需要用的是\",{\"1\":{\"98\":1}}],[\"这里简单说一下\",{\"1\":{\"98\":1}}],[\"这里简单说说其他没出现过的方法\",{\"1\":{\"67\":1}}],[\"这里要做的事情就是\",{\"1\":{\"98\":1}}],[\"这里也先提一下\",{\"1\":{\"96\":1}}],[\"这里开始详细聊聊\",{\"1\":{\"91\":1}}],[\"这里开始往后也不用看\",{\"1\":{\"89\":1}}],[\"这里标记为首次注册\",{\"1\":{\"89\":1}}],[\"这里提到的\",{\"1\":{\"89\":1}}],[\"这里是我们要看的同步\",{\"1\":{\"101\":1}}],[\"这里是以同步的方式拿到返回结果\",{\"1\":{\"94\":1}}],[\"这里是从\",{\"1\":{\"84\":1}}],[\"这里是给\",{\"1\":{\"67\":1}}],[\"这里会先执行\",{\"1\":{\"83\":1}}],[\"这里推拉两种模式主要是从使用角度\",{\"1\":{\"77\":1}}],[\"这里所说的元数据指的是\",{\"1\":{\"70\":1}}],[\"这里决定是否主从切换\",{\"1\":{\"69\":1}}],[\"这里直接来看这部分逻辑是如何实现的\",{\"1\":{\"69\":1}}],[\"这里我把\",{\"1\":{\"57\":1}}],[\"这里我们看普通的即可\",{\"1\":{\"115\":1}}],[\"这里我们看非批量发送的处理逻辑\",{\"1\":{\"42\":1}}],[\"这里我们直接去看\",{\"1\":{\"96\":1}}],[\"这里我们更进一步\",{\"1\":{\"69\":1}}],[\"这里我们来看一下它\",{\"1\":{\"64\":1}}],[\"这里我们就来看看\",{\"1\":{\"41\":1}}],[\"这里它默认所有的\",{\"1\":{\"57\":1}}],[\"这里就只注明个别参数的含义\",{\"1\":{\"115\":1}}],[\"这里就假设读者已经顺利完成了\",{\"1\":{\"92\":1}}],[\"这里就是前面说的\",{\"1\":{\"103\":1}}],[\"这里就是之前心跳包时候说的\",{\"1\":{\"89\":1}}],[\"这里就是你自己实现的\",{\"1\":{\"56\":1}}],[\"这里就不罗列了\",{\"1\":{\"58\":1}}],[\"这里就统称执行器\",{\"1\":{\"56\":1}}],[\"这里初始化\",{\"1\":{\"55\":1}}],[\"这里只介绍\",{\"1\":{\"119\":1}}],[\"这里只分析this\",{\"1\":{\"89\":1}}],[\"这里只初始化\",{\"1\":{\"55\":1}}],[\"这里只需要知道每个模块大致功能的即可\",{\"1\":{\"37\":1}}],[\"这里又来到一个\",{\"1\":{\"55\":1}}],[\"这里做两件事\",{\"1\":{\"55\":1}}],[\"这里面有一步设置消费组\",{\"1\":{\"55\":1}}],[\"这里面涉及到了\",{\"1\":{\"42\":1}}],[\"这里的逻辑基本上是\",{\"1\":{\"119\":1}}],[\"这里的源码如果看着迷茫可以先跳过\",{\"1\":{\"42\":1}}],[\"这里的\",{\"1\":{\"42\":1,\"66\":1,\"67\":1,\"84\":1,\"110\":1}}],[\"这里逻辑实际上是反过来的\",{\"1\":{\"40\":1}}],[\"这里顺便看一下\",{\"1\":{\"40\":1}}],[\"这里发布一些杂七杂八\",{\"1\":{\"0\":1}}],[\"这部分不展开\",{\"1\":{\"117\":1}}],[\"这部分源码分析放到\",{\"1\":{\"89\":1}}],[\"这部分代码也在\",{\"1\":{\"72\":1}}],[\"这部分代码就在\",{\"1\":{\"65\":1}}],[\"这部分代码就不展开分析了\",{\"1\":{\"59\":1}}],[\"这部分就类似\",{\"1\":{\"80\":1}}],[\"这部分就类似路由功能\",{\"1\":{\"80\":1}}],[\"这部分就不展开了\",{\"1\":{\"57\":1}}],[\"这部分就是前文提到的消费位点的存储\",{\"1\":{\"55\":1}}],[\"这部分可以直接看官方文档\",{\"1\":{\"45\":1}}],[\"这部分在持久化篇展开\",{\"1\":{\"39\":1}}],[\"这部分提供了阻塞\",{\"1\":{\"29\":1}}],[\"这部分还没想好\",{\"1\":{\"13\":1}}],[\"这个机制的引入就是为了解决这个问题\",{\"1\":{\"120\":1}}],[\"这个其实也没啥可看的\",{\"1\":{\"116\":1}}],[\"这个任务必须实现\",{\"1\":{\"116\":1}}],[\"这个线程就不停的执行\",{\"1\":{\"116\":1}}],[\"这个线程只有在开启\",{\"1\":{\"115\":1}}],[\"这个线程专门负责自动创建\",{\"1\":{\"115\":1}}],[\"这个提交重复请求\",{\"1\":{\"115\":1}}],[\"这个文件就是用来记录刷盘时间点的\",{\"1\":{\"113\":1}}],[\"这个待消费的消息队列就是\",{\"1\":{\"111\":1}}],[\"这个设计巧妙的地方在于\",{\"1\":{\"110\":1}}],[\"这个在桌面应用里很常见\",{\"1\":{\"107\":1}}],[\"这个可就太长了\",{\"1\":{\"103\":1}}],[\"这个可以自己去看代码\",{\"1\":{\"57\":1}}],[\"这个展开也超长\",{\"1\":{\"103\":1}}],[\"这个循环\",{\"1\":{\"102\":1}}],[\"这个空的\",{\"1\":{\"101\":1}}],[\"这个定时任务是扫描并移除\",{\"1\":{\"98\":1}}],[\"这个变量名\",{\"1\":{\"98\":1,\"101\":1}}],[\"这个默认值是走\",{\"1\":{\"98\":1}}],[\"这个先无视\",{\"1\":{\"96\":1}}],[\"这个概念后面细说\",{\"1\":{\"96\":1}}],[\"这个前面分析过了\",{\"1\":{\"90\":1}}],[\"这个情况下\",{\"1\":{\"89\":1}}],[\"这个就是集群路由表\",{\"1\":{\"88\":1}}],[\"这个就任重道远了\",{\"1\":{\"3\":1}}],[\"这个里面存的是\",{\"1\":{\"88\":1}}],[\"这个数据表里存储的是每个\",{\"1\":{\"88\":1}}],[\"这个主从集群的集群名存储在\",{\"1\":{\"87\":1}}],[\"这个是翻译上存在已久的争议\",{\"1\":{\"110\":1}}],[\"这个是消息发送失败时\",{\"1\":{\"96\":1}}],[\"这个是压缩消息的阈值\",{\"1\":{\"96\":1}}],[\"这个是\",{\"1\":{\"88\":1}}],[\"这个是controller\",{\"1\":{\"84\":1}}],[\"这个是线程之间交换变量值的\",{\"1\":{\"23\":1}}],[\"这个过程也是通讯协议从设计到实践的过程\",{\"1\":{\"89\":1}}],[\"这个过程中会处理命令行参数\",{\"1\":{\"83\":1}}],[\"这个过程你就可以想成一个指向数组下标的指针在不断移动\",{\"1\":{\"67\":1}}],[\"这个说是\",{\"1\":{\"81\":1}}],[\"这个同步是单向的\",{\"1\":{\"71\":1}}],[\"这个不用看\",{\"1\":{\"69\":1}}],[\"这个没啥可说的\",{\"1\":{\"69\":1}}],[\"这个值就是\",{\"1\":{\"68\":1}}],[\"这个也是\",{\"1\":{\"67\":1}}],[\"这个顾名思义\",{\"1\":{\"67\":1}}],[\"这个类内部依然包含一个\",{\"1\":{\"111\":1}}],[\"这个类你简单理解它内部包含一个\",{\"1\":{\"110\":1}}],[\"这个类也简单\",{\"1\":{\"89\":1}}],[\"这个类就可以看作是路由功能的实现\",{\"1\":{\"86\":1}}],[\"这个类就是用来管理连接和网络\",{\"1\":{\"68\":1}}],[\"这个类\",{\"1\":{\"67\":1}}],[\"这个读写队列跟前几篇讲的读写分离技巧是一样的\",{\"1\":{\"67\":1}}],[\"这个流程叫消息确认\",{\"1\":{\"59\":1}}],[\"这个方法本来也不打算贴的\",{\"1\":{\"116\":1}}],[\"这个方法自己去看吧\",{\"1\":{\"116\":1}}],[\"这个方法\",{\"1\":{\"103\":1}}],[\"这个方法这里不过多展开了\",{\"1\":{\"101\":1}}],[\"这个方法就不详细展开了\",{\"1\":{\"89\":1}}],[\"这个方法就是\",{\"1\":{\"56\":1}}],[\"这个方法正常的调用方式是通过\",{\"1\":{\"84\":1}}],[\"这个方法是线程安全的\",{\"1\":{\"103\":1}}],[\"这个方法是从\",{\"1\":{\"84\":1}}],[\"这个方法是如何被调用的\",{\"1\":{\"56\":1}}],[\"这个方法的调用时机时机是\",{\"1\":{\"67\":1}}],[\"这个方法会解码读到的数据\",{\"1\":{\"66\":1}}],[\"这个方法也很长\",{\"1\":{\"57\":1}}],[\"这个\",{\"1\":{\"56\":1,\"57\":2,\"77\":1,\"84\":1,\"98\":1,\"102\":1,\"115\":1,\"116\":2,\"119\":1}}],[\"这个初始化方法中有一个步骤就是注册\",{\"1\":{\"42\":1}}],[\"这个动作happen\",{\"1\":{\"25\":1}}],[\"这个框架\",{\"1\":{\"13\":1}}],[\"这个功能是\",{\"1\":{\"4\":1}}],[\"这依赖关系设计\",{\"1\":{\"3\":1}}],[\"during\",{\"1\":{\"101\":1}}],[\"duplicate\",{\"1\":{\"98\":1}}],[\"directly\",{\"1\":{\"110\":1}}],[\"diff\",{\"1\":{\"69\":2}}],[\"dispatchrequest\",{\"1\":{\"116\":10}}],[\"dispatchreadrequest\",{\"1\":{\"66\":1}}],[\"dispatch\",{\"1\":{\"116\":6}}],[\"dispatcherlist\",{\"1\":{\"116\":5}}],[\"dispatcher\",{\"1\":{\"97\":1}}],[\"dispatchtoconsume\",{\"1\":{\"57\":4}}],[\"dispathtoconsume\",{\"1\":{\"56\":2}}],[\"data\",{\"1\":{\"57\":1,\"84\":1}}],[\"dark\",{\"1\":{\"3\":1,\"10\":1}}],[\"drop\",{\"1\":{\"57\":1}}],[\"dlq\",{\"1\":{\"55\":1}}],[\"dledger\",{\"1\":{\"39\":1,\"64\":1}}],[\"d\",{\"1\":{\"3\":1,\"101\":2}}],[\"dodispatch\",{\"1\":{\"116\":2}}],[\"doappend\",{\"1\":{\"110\":1,\"115\":1}}],[\"dowaittransfer\",{\"1\":{\"67\":2}}],[\"doreput\",{\"1\":{\"116\":2}}],[\"dorebalance\",{\"1\":{\"55\":2,\"58\":7}}],[\"doregisterbrokerall\",{\"1\":{\"40\":1}}],[\"docreatemappedfile\",{\"1\":{\"115\":1}}],[\"doc\",{\"1\":{\"32\":1}}],[\"docs\",{\"1\":{\"1\":1,\"3\":1,\"9\":4}}],[\"does\",{\"1\":{\"3\":1}}],[\"depending\",{\"1\":{\"115\":1}}],[\"deprecated\",{\"1\":{\"3\":1,\"54\":1,\"55\":1,\"119\":1}}],[\"destroyed\",{\"1\":{\"84\":7}}],[\"decodecommandcustomheader\",{\"1\":{\"89\":1}}],[\"decoder\",{\"1\":{\"89\":3}}],[\"decode\",{\"1\":{\"67\":1,\"68\":1,\"89\":1}}],[\"demo\",{\"1\":{\"67\":1,\"89\":1}}],[\"delayoffset\",{\"1\":{\"109\":2}}],[\"delay\",{\"1\":{\"57\":2,\"58\":1}}],[\"defaultasyncsenderexecutor\",{\"1\":{\"103\":2}}],[\"defaulttopicqueuenums\",{\"1\":{\"96\":1}}],[\"defaultrequestprocessor就是我们要找的类\",{\"1\":{\"89\":1}}],[\"defaultbrokerid\",{\"1\":{\"69\":1}}],[\"defaultmessagestore\",{\"1\":{\"64\":2,\"65\":1,\"66\":1,\"67\":3,\"69\":2,\"115\":6,\"116\":17,\"119\":4}}],[\"defaultmqproducerimpl\",{\"0\":{\"98\":1,\"101\":1,\"103\":1},\"1\":{\"96\":5,\"97\":3,\"98\":1,\"100\":1,\"101\":3,\"103\":2}}],[\"defaultmqproducer\",{\"0\":{\"96\":1,\"97\":1,\"100\":1,\"102\":1},\"1\":{\"55\":1,\"94\":2,\"95\":2,\"96\":3,\"97\":1,\"98\":10,\"101\":8,\"103\":9}}],[\"defaultmqpullconsumerimpl\",{\"1\":{\"54\":1,\"57\":1}}],[\"defaultmqpullconsumer\",{\"1\":{\"54\":1}}],[\"defaultmqpushconsumerimpl\",{\"1\":{\"55\":3,\"57\":22,\"58\":3,\"69\":1}}],[\"defaultmqpushconsumer\",{\"1\":{\"47\":1,\"51\":1,\"53\":1,\"54\":1,\"55\":17,\"56\":2,\"57\":8,\"58\":3,\"60\":1}}],[\"defaultlitepullconsumer\",{\"1\":{\"47\":1,\"54\":1}}],[\"default\",{\"1\":{\"42\":2,\"55\":2,\"57\":1,\"58\":1,\"94\":1,\"98\":4,\"101\":1,\"103\":1}}],[\"debug\",{\"0\":{\"4\":1}}],[\"devops\",{\"1\":{\"13\":2}}],[\"dev\",{\"1\":{\"3\":1,\"6\":3,\"9\":2}}],[\"黑模式\",{\"1\":{\"3\":1}}],[\"一直填充到\",{\"1\":{\"116\":1}}],[\"一直要等到从库完成数据同步才会返回给客户端\",{\"1\":{\"21\":1}}],[\"一是消息的物理偏移量\",{\"1\":{\"116\":1}}],[\"一种是分布式\",{\"1\":{\"115\":1}}],[\"一种请求做了区分\",{\"1\":{\"42\":1}}],[\"一条消息可以被所有\",{\"1\":{\"77\":1}}],[\"一次至少提交几个页\",{\"1\":{\"115\":1}}],[\"一次的同步显然有点慢\",{\"1\":{\"72\":1}}],[\"一次最多读\",{\"1\":{\"66\":1}}],[\"一旦追平\",{\"1\":{\"67\":1}}],[\"一方面你可以去查书\",{\"1\":{\"59\":1}}],[\"一定会有\",{\"1\":{\"56\":1}}],[\"一起添加到\",{\"1\":{\"55\":1}}],[\"一样\",{\"1\":{\"55\":1,\"116\":1}}],[\"一样也是\",{\"1\":{\"54\":1}}],[\"一样必须唯一\",{\"1\":{\"48\":1}}],[\"一一对应的\",{\"1\":{\"98\":1}}],[\"一一对应\",{\"1\":{\"48\":1,\"98\":1}}],[\"一部分\",{\"1\":{\"42\":1}}],[\"一堆\",{\"1\":{\"41\":1}}],[\"一堆原子类组成的包\",{\"1\":{\"23\":1}}],[\"一堆折腾之后\",{\"1\":{\"3\":1}}],[\"一些零碎内容\",{\"1\":{\"13\":1}}],[\"一些简单的\",{\"1\":{\"13\":1}}],[\"一张图需要两种风格对应白\",{\"1\":{\"3\":1}}],[\"一个文件写满之后写入下一个文件\",{\"1\":{\"110\":1}}],[\"一个消费组可以包含多个消费者\",{\"1\":{\"77\":1}}],[\"一个是普通的注册\",{\"1\":{\"89\":1}}],[\"一个是带\",{\"1\":{\"89\":1}}],[\"一个是\",{\"1\":{\"69\":2}}],[\"一个是仓库本身关于\",{\"1\":{\"4\":1}}],[\"一个个提交\",{\"1\":{\"60\":1}}],[\"一个老长的\",{\"1\":{\"57\":1}}],[\"一个处理各种请求\",{\"1\":{\"43\":1}}],[\"一个线程调用\",{\"1\":{\"30\":1}}],[\"一个特定\",{\"1\":{\"30\":1}}],[\"一个\",{\"1\":{\"3\":2,\"87\":3,\"96\":1,\"98\":1}}],[\"格式背景图\",{\"1\":{\"3\":1}}],[\"flip\",{\"1\":{\"67\":3,\"116\":1}}],[\"flushdisktype\",{\"1\":{\"115\":2}}],[\"flushresultfuture\",{\"1\":{\"115\":1}}],[\"flushrealtimeservice\",{\"1\":{\"115\":4}}],[\"flushcommitlogservice的\",{\"1\":{\"115\":1}}],[\"flushcommitlogservice\",{\"1\":{\"115\":7}}],[\"flush\",{\"1\":{\"67\":1,\"115\":6}}],[\"flow\",{\"1\":{\"57\":2}}],[\"flexible\",{\"1\":{\"31\":1}}],[\"fetchlockobject\",{\"1\":{\"56\":1}}],[\"fetchnameserveraddr\",{\"1\":{\"55\":1}}],[\"few\",{\"1\":{\"31\":1}}],[\"field\",{\"1\":{\"116\":2}}],[\"findconsumequeue\",{\"1\":{\"116\":2}}],[\"findconsumeridlist\",{\"1\":{\"58\":1}}],[\"findbrokeraddressinsubscribe\",{\"1\":{\"69\":3}}],[\"findbrokerresult\",{\"1\":{\"69\":3}}],[\"finally\",{\"1\":{\"84\":2,\"89\":1}}],[\"final\",{\"1\":{\"56\":6,\"57\":12,\"58\":9,\"67\":2,\"69\":3,\"81\":5,\"84\":1,\"87\":5,\"88\":5,\"89\":11,\"96\":4,\"98\":1,\"101\":4,\"103\":11,\"115\":1,\"116\":8}}],[\"fixed\",{\"1\":{\"110\":1}}],[\"fix\",{\"1\":{\"57\":2,\"103\":1}}],[\"firstmsgoffset\",{\"1\":{\"57\":5}}],[\"first\",{\"1\":{\"51\":1,\"57\":2,\"89\":1}}],[\"fill\",{\"1\":{\"116\":1}}],[\"fillpreblank\",{\"1\":{\"116\":2}}],[\"filterserverlist\",{\"1\":{\"89\":4}}],[\"filterserver\",{\"1\":{\"89\":2}}],[\"filterserver列表的对应关系\",{\"1\":{\"88\":1}}],[\"filterservertableprivate\",{\"1\":{\"88\":1}}],[\"filterservertable\",{\"1\":{\"81\":1,\"84\":2,\"87\":1,\"88\":1,\"89\":2}}],[\"filterservermanager\",{\"1\":{\"39\":2}}],[\"filter\",{\"1\":{\"57\":1,\"81\":1,\"87\":1,\"88\":1}}],[\"filtermessagehooklist\",{\"1\":{\"55\":1}}],[\"filechannel\",{\"1\":{\"115\":1}}],[\"filewatchservice\",{\"1\":{\"39\":2}}],[\"file\",{\"0\":{\"112\":1},\"1\":{\"3\":1,\"108\":1,\"110\":2,\"112\":1,\"115\":1}}],[\"faqurl\",{\"1\":{\"55\":2,\"98\":4,\"101\":4}}],[\"failed\",{\"1\":{\"55\":3,\"57\":1,\"58\":1,\"97\":1,\"98\":2,\"101\":2,\"102\":1}}],[\"fastremotingserver\",{\"1\":{\"39\":2}}],[\"factory\",{\"1\":{\"31\":1,\"55\":1}}],[\"false\",{\"1\":{\"10\":1,\"39\":2,\"55\":2,\"56\":1,\"57\":14,\"58\":2,\"69\":1,\"71\":2,\"84\":1,\"89\":1,\"96\":1,\"101\":3,\"103\":2,\"116\":1}}],[\"favicon\",{\"1\":{\"3\":1}}],[\"ffeaec\",{\"1\":{\"10\":1}}],[\"found\",{\"1\":{\"57\":2,\"66\":1,\"101\":1,\"123\":1}}],[\"force\",{\"1\":{\"115\":2}}],[\"format\",{\"1\":{\"101\":5}}],[\"forbidden\",{\"1\":{\"42\":1}}],[\"for\",{\"1\":{\"3\":1,\"31\":2,\"56\":1,\"57\":1,\"58\":1,\"67\":2,\"89\":1,\"94\":1,\"101\":1,\"102\":3,\"116\":1}}],[\"following\",{\"1\":{\"3\":1}}],[\"from\",{\"1\":{\"3\":2,\"51\":3,\"55\":1,\"57\":2,\"64\":1,\"84\":6,\"110\":1,\"116\":2}}],[\"futures\",{\"1\":{\"31\":1}}],[\"futuretask\",{\"1\":{\"31\":1}}],[\"future\",{\"0\":{\"1\":1},\"1\":{\"23\":1,\"115\":1}}],[\"level\",{\"1\":{\"103\":1}}],[\"length\",{\"1\":{\"84\":1,\"102\":3,\"110\":2,\"115\":1}}],[\"legacy\",{\"1\":{\"6\":2}}],[\"lambda\",{\"1\":{\"84\":1}}],[\"later\",{\"1\":{\"57\":1,\"59\":1}}],[\"larger\",{\"1\":{\"57\":1}}],[\"lastexitok\",{\"1\":{\"119\":2}}],[\"lastbrokername\",{\"1\":{\"101\":2}}],[\"lastupdatetimestamp\",{\"1\":{\"84\":1,\"89\":2}}],[\"lastwritetimestamp\",{\"1\":{\"65\":1,\"66\":1}}],[\"last\",{\"1\":{\"51\":1,\"84\":4}}],[\"lastpass\",{\"1\":{\"3\":1}}],[\"long\",{\"1\":{\"56\":1,\"57\":7,\"58\":2,\"66\":1,\"67\":3,\"69\":5,\"84\":3,\"89\":1,\"101\":7,\"103\":2,\"115\":2,\"116\":5,\"119\":3}}],[\"looking\",{\"1\":{\"55\":1}}],[\"loadconsumequeue\",{\"1\":{\"119\":1}}],[\"load\",{\"1\":{\"55\":4,\"119\":1}}],[\"location\",{\"1\":{\"110\":1}}],[\"local\",{\"1\":{\"56\":1,\"57\":1}}],[\"localfileoffsetstore\",{\"1\":{\"55\":3}}],[\"lockinterruptibly\",{\"1\":{\"84\":2,\"89\":1}}],[\"lock\",{\"1\":{\"84\":5,\"89\":2,\"109\":1,\"115\":2}}],[\"locked\",{\"1\":{\"57\":1}}],[\"lockall\",{\"1\":{\"55\":1}}],[\"locksupport\",{\"1\":{\"23\":1}}],[\"locks\",{\"1\":{\"23\":2}}],[\"logicoffset\",{\"1\":{\"116\":3}}],[\"logic\",{\"1\":{\"116\":1}}],[\"logicsmsgtimestamp\",{\"1\":{\"113\":1,\"119\":1}}],[\"log\",{\"0\":{\"4\":1},\"1\":{\"39\":1,\"55\":2,\"56\":1,\"57\":16,\"58\":5,\"66\":5,\"67\":1,\"71\":1,\"76\":1,\"77\":2,\"84\":11,\"89\":2,\"97\":1,\"98\":1,\"101\":10,\"115\":1,\"116\":5}}],[\"logo\",{\"1\":{\"3\":1}}],[\"limit\",{\"1\":{\"116\":1}}],[\"linux\",{\"1\":{\"114\":1}}],[\"linkedlist<commitlogdispatcher>\",{\"1\":{\"116\":1}}],[\"linkedlist<>\",{\"1\":{\"67\":2,\"116\":1}}],[\"linkedtransferqueue\",{\"1\":{\"23\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"103\":1}}],[\"linkedblockingqueue<pullrequest>\",{\"1\":{\"57\":2}}],[\"linkedblockingqueue\",{\"1\":{\"23\":1,\"56\":1}}],[\"linkedblockingdeque\",{\"1\":{\"23\":1}}],[\"link\",{\"1\":{\"6\":2}}],[\"light\",{\"1\":{\"3\":1,\"10\":1}}],[\"list里\",{\"1\":{\"102\":1}}],[\"listenport\",{\"1\":{\"64\":2}}],[\"listener\",{\"1\":{\"56\":1,\"84\":2}}],[\"list<byte\",{\"1\":{\"102\":1}}],[\"list<queuedata>\",{\"1\":{\"84\":1}}],[\"list<queuedata>>>\",{\"1\":{\"84\":1}}],[\"list<queuedata>>\",{\"1\":{\"81\":1,\"84\":1,\"87\":1,\"88\":1}}],[\"list<haconnection>\",{\"1\":{\"67\":1}}],[\"list<message>\",{\"1\":{\"102\":2}}],[\"list<messagequeue>\",{\"1\":{\"58\":2}}],[\"list<messageext>\",{\"1\":{\"56\":2}}],[\"list<string>\",{\"1\":{\"58\":1,\"81\":1,\"87\":1,\"88\":1,\"89\":1}}],[\"list\",{\"0\":{\"3\":1,\"40\":1},\"1\":{\"39\":1,\"58\":1,\"102\":2,\"103\":1,\"115\":3}}],[\"type\",{\"1\":{\"116\":4}}],[\"tmpmessage\",{\"1\":{\"103\":4}}],[\"tmp\",{\"1\":{\"102\":3}}],[\"tctable\",{\"1\":{\"89\":3}}],[\"tbw102\",{\"1\":{\"77\":3}}],[\"tls\",{\"1\":{\"65\":1}}],[\"tansferok\",{\"1\":{\"67\":1}}],[\"take\",{\"1\":{\"57\":1}}],[\"takemessages\",{\"1\":{\"56\":2}}],[\"tagscode\",{\"1\":{\"116\":4}}],[\"taga\",{\"1\":{\"94\":1}}],[\"tag\",{\"1\":{\"52\":1,\"111\":5,\"116\":2}}],[\"tasks\",{\"1\":{\"31\":1,\"55\":1}}],[\"task\",{\"1\":{\"23\":1}}],[\"tasklist\",{\"1\":{\"3\":1}}],[\"tunable\",{\"1\":{\"31\":1}}],[\"timedif\",{\"1\":{\"112\":2}}],[\"timedelay\",{\"1\":{\"57\":2}}],[\"times++\",{\"1\":{\"101\":1}}],[\"times\",{\"1\":{\"101\":6}}],[\"timestotal\",{\"1\":{\"101\":3}}],[\"timestotal就是一条消息的发送总次数\",{\"1\":{\"101\":1}}],[\"timestamp\",{\"1\":{\"51\":1,\"98\":1}}],[\"timeout\",{\"1\":{\"57\":1,\"67\":2,\"101\":7,\"103\":6}}],[\"time\",{\"1\":{\"56\":2,\"57\":5,\"58\":1,\"66\":1,\"84\":4,\"115\":1}}],[\"timeunit\",{\"1\":{\"28\":1,\"39\":1,\"56\":1,\"57\":1,\"71\":1,\"84\":1,\"103\":1}}],[\"timing\",{\"0\":{\"28\":1},\"1\":{\"24\":1}}],[\"title\",{\"1\":{\"3\":1}}],[\"than\",{\"1\":{\"57\":1,\"110\":1}}],[\"that\",{\"1\":{\"31\":1}}],[\"this\",{\"1\":{\"39\":23,\"42\":5,\"55\":63,\"56\":13,\"57\":39,\"58\":24,\"64\":7,\"65\":11,\"66\":20,\"67\":16,\"69\":11,\"71\":8,\"84\":17,\"89\":16,\"96\":3,\"97\":5,\"98\":21,\"100\":2,\"101\":17,\"102\":1,\"103\":21,\"112\":1,\"115\":20,\"116\":28,\"119\":6}}],[\"throw\",{\"1\":{\"55\":1,\"98\":2,\"101\":6,\"102\":1,\"103\":2}}],[\"throwable\",{\"1\":{\"39\":1,\"57\":2,\"58\":2,\"71\":1}}],[\"throws\",{\"1\":{\"39\":1,\"55\":1,\"64\":1,\"65\":1,\"89\":1,\"97\":1,\"98\":2,\"100\":1,\"101\":3,\"102\":1}}],[\"threadindex\",{\"1\":{\"103\":2}}],[\"thread\",{\"1\":{\"30\":1,\"31\":1,\"57\":1,\"103\":3,\"116\":1}}],[\"threadfactoryimpl\",{\"1\":{\"56\":1,\"84\":1}}],[\"threadfactory\",{\"1\":{\"23\":1,\"103\":1}}],[\"threadpoolexecutor\",{\"1\":{\"23\":1,\"31\":1,\"56\":2,\"103\":2}}],[\"thenaccept\",{\"1\":{\"115\":1}}],[\"then\",{\"1\":{\"89\":1}}],[\"them\",{\"1\":{\"31\":1}}],[\"theme\",{\"1\":{\"2\":1,\"3\":2,\"6\":1,\"9\":1,\"10\":1}}],[\"the\",{\"1\":{\"3\":2,\"31\":4,\"42\":1,\"55\":3,\"57\":5,\"58\":1,\"71\":1,\"84\":3,\"89\":1,\"98\":3,\"102\":1,\"110\":1}}],[\"truncatemessagequeuenotmytopic\",{\"1\":{\"58\":1}}],[\"true\",{\"1\":{\"3\":1,\"39\":3,\"55\":1,\"56\":1,\"57\":8,\"58\":1,\"66\":1,\"84\":2,\"89\":1,\"98\":1,\"101\":4,\"103\":3,\"116\":1}}],[\"trantype\",{\"1\":{\"116\":2}}],[\"transientstorepool\",{\"0\":{\"120\":1},\"1\":{\"115\":5}}],[\"transient\",{\"1\":{\"96\":1}}],[\"transitioning\",{\"1\":{\"3\":1}}],[\"transferring\",{\"1\":{\"110\":1}}],[\"transferdata\",{\"1\":{\"68\":1}}],[\"transfer\",{\"1\":{\"67\":1}}],[\"transferok\",{\"1\":{\"67\":5}}],[\"transflag\",{\"1\":{\"42\":3}}],[\"transaction\",{\"1\":{\"42\":2,\"116\":4}}],[\"trace\",{\"1\":{\"97\":1}}],[\"tracedispatcher\",{\"1\":{\"55\":1,\"96\":2,\"97\":2}}],[\"trycreatemappedfile\",{\"1\":{\"115\":1}}],[\"trytofindtopicpublishinfo\",{\"1\":{\"101\":2,\"103\":2}}],[\"trylocklaterandreconsume\",{\"1\":{\"56\":2}}],[\"try\",{\"1\":{\"39\":1,\"57\":5,\"58\":2,\"66\":1,\"71\":1,\"84\":4,\"89\":2,\"94\":1,\"97\":1,\"101\":1,\"102\":1,\"115\":1,\"116\":2}}],[\"treemap等等\",{\"1\":{\"26\":1}}],[\"ts中添加\",{\"1\":{\"10\":1}}],[\"ts\",{\"1\":{\"3\":2}}],[\"total\",{\"1\":{\"69\":1}}],[\"touched\",{\"1\":{\"58\":1}}],[\"tostring\",{\"1\":{\"57\":2,\"101\":6}}],[\"topicwithnamespace\",{\"1\":{\"103\":1}}],[\"topicpublishinfo>\",{\"1\":{\"103\":2}}],[\"topicpublishinfo\",{\"1\":{\"98\":1,\"101\":8,\"103\":14}}],[\"topicpublishinfotable\",{\"1\":{\"98\":1,\"103\":5}}],[\"topicvalidator\",{\"1\":{\"96\":1}}],[\"topictest\",{\"1\":{\"94\":1,\"109\":1}}],[\"topicconfig>\",{\"1\":{\"89\":2}}],[\"topicconfig\",{\"1\":{\"89\":3}}],[\"topicconfigserializewrapper\",{\"1\":{\"89\":5}}],[\"topicconfigwrapper\",{\"1\":{\"40\":1,\"89\":11}}],[\"topics\",{\"1\":{\"109\":2}}],[\"topicsysflag\",{\"1\":{\"88\":1}}],[\"topicsubscribeinfotable\",{\"1\":{\"58\":2}}],[\"topicqueuetable\",{\"0\":{\"88\":1},\"1\":{\"81\":1,\"84\":4,\"87\":1,\"88\":1,\"89\":2,\"119\":1}}],[\"topic=\",{\"1\":{\"58\":1}}],[\"topicroutetable\",{\"1\":{\"55\":1}}],[\"topic+tag\",{\"1\":{\"52\":2}}],[\"topic\",{\"1\":{\"40\":2,\"46\":3,\"48\":3,\"52\":1,\"57\":3,\"58\":19,\"70\":1,\"76\":1,\"77\":10,\"81\":2,\"84\":7,\"87\":3,\"88\":4,\"89\":4,\"91\":3,\"96\":5,\"98\":2,\"100\":1,\"101\":7,\"102\":1,\"103\":13,\"110\":4,\"111\":7,\"112\":1,\"115\":1,\"116\":2}}],[\"top回到最上\",{\"1\":{\"7\":1}}],[\"tools\",{\"1\":{\"7\":1}}],[\"to\",{\"1\":{\"3\":4,\"7\":1,\"57\":3,\"67\":1,\"89\":1,\"102\":1,\"110\":1,\"116\":1}}],[\"todo\",{\"0\":{\"3\":1},\"1\":{\"102\":2}}],[\"学习和调试的记录\",{\"1\":{\"2\":1}}],[\"考虑将\",{\"1\":{\"1\":1}}],[\"博客性质的内容越来越少\",{\"1\":{\"12\":1}}],[\"博客\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(et(t,v[s],n)):e==="search"?self.postMessage(tt(t,v[s],n)):self.postMessage({suggestions:et(t,v[s],n),results:tt(t,v[s],n)})};
//# sourceMappingURL=index.js.map
